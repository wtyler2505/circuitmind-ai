
> circuitmind-ai@0.0.0 lint
> eslint . --ext .ts,.tsx --format json

[{"filePath":"/home/wtyler/circuitmind-ai/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/AssistantSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ChatMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ChatPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ComponentEditorModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ConversationSwitcher.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/DiagramCanvas.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/IconButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/Inventory.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateSearchQuery' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":68,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/SettingsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ThreeViewer.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'settings.ambientColor', 'settings.ambientIntensity', 'settings.dirColor', and 'settings.dirIntensity'. Either include them or remove the dependency array.","line":271,"column":6,"nodeType":"ArrayExpression","endLine":271,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [handleResize, settings.ambientColor, settings.ambientIntensity, settings.dirColor, settings.dirIntensity]","fix":{"range":[11301,11315],"text":"[handleResize, settings.ambientColor, settings.ambientIntensity, settings.dirColor, settings.dirIntensity]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/AssistantSidebar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/ChatMessage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/ChatPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/ComponentEditorModal.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/DiagramCanvas.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dropZone' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":226,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":226,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { render, screen, fireEvent, act } from '../../tests/test-utils';\nimport { createRef } from 'react';\nimport DiagramCanvas, { DiagramCanvasRef } from '../DiagramCanvas';\nimport { WiringDiagram, ElectronicComponent } from '../../types';\n\n// Mock component data\nconst mockComponent: ElectronicComponent = {\n  id: 'comp-1',\n  name: 'Arduino Uno',\n  type: 'microcontroller',\n  pins: ['5V', 'GND', 'D2', 'D3'],\n  description: 'Main controller',\n  quantity: 1,\n};\n\nconst mockComponent2: ElectronicComponent = {\n  id: 'comp-2',\n  name: 'LED',\n  type: 'actuator',\n  pins: ['Anode', 'Cathode'],\n  description: 'Status indicator',\n  quantity: 1,\n};\n\nconst emptyDiagram: WiringDiagram = {\n  title: 'Empty Diagram',\n  components: [],\n  connections: [],\n  explanation: '',\n};\n\nconst diagramWithComponents: WiringDiagram = {\n  title: 'Test Circuit',\n  components: [mockComponent, mockComponent2],\n  connections: [],\n  explanation: 'Test explanation',\n};\n\nconst diagramWithConnection: WiringDiagram = {\n  title: 'Connected Circuit',\n  components: [mockComponent, mockComponent2],\n  connections: [\n    {\n      fromComponentId: 'comp-1',\n      toComponentId: 'comp-2',\n      fromPin: 'D2',\n      toPin: 'Anode',\n      description: 'Signal wire',\n      color: '#00ff00',\n    },\n  ],\n  explanation: 'LED connected to Arduino',\n};\n\ndescribe('DiagramCanvas', () => {\n  const defaultProps = {\n    onComponentSelect: vi.fn(),\n    onComponentContextMenu: vi.fn(),\n    onComponentDoubleClick: vi.fn(),\n    onDiagramUpdate: vi.fn(),\n    onComponentDrop: vi.fn(),\n  };\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('Empty State', () => {\n    it('shows an empty state when the diagram has no components', () => {\n      render(<DiagramCanvas diagram={emptyDiagram} {...defaultProps} />);\n\n      expect(screen.getByText('Drop parts to start wiring.')).toBeInTheDocument();\n      expect(\n        screen.getByText(/Build manually or let chat generate a full diagram/i)\n      ).toBeInTheDocument();\n    });\n\n    it('shows empty state when diagram is null', () => {\n      render(<DiagramCanvas diagram={null} {...defaultProps} />);\n\n      // Null diagram shows different message than empty diagram\n      expect(screen.getByText('No diagram yet.')).toBeInTheDocument();\n    });\n  });\n\n  // ... (Component Rendering, Wire Rendering, Zoom Controls, Search Functionality tests remain similar)\n\n  describe('Component Interaction', () => {\n    it('calls onComponentSelect when a component is clicked (Left Click)', () => {\n      render(<DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />);\n\n      const componentName = screen.getByText('Arduino Uno');\n      const componentGroup = componentName.closest('g');\n\n      if (componentGroup) {\n        fireEvent.click(componentGroup);\n        expect(defaultProps.onComponentSelect).toHaveBeenCalledWith('comp-1');\n      }\n    });\n\n    it('calls onComponentContextMenu when right-clicked', () => {\n      render(<DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />);\n\n      const componentName = screen.getByText('Arduino Uno');\n      const componentGroup = componentName.closest('g');\n\n      if (componentGroup) {\n        fireEvent.contextMenu(componentGroup);\n        expect(defaultProps.onComponentContextMenu).toHaveBeenCalledWith('comp-1', expect.any(Number), expect.any(Number));\n      }\n    });\n\n    it('calls onComponentDoubleClick when double-clicked', () => {\n      render(<DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />);\n\n      const componentName = screen.getByText('Arduino Uno');\n      const componentGroup = componentName.closest('g');\n\n      if (componentGroup) {\n        fireEvent.doubleClick(componentGroup);\n        expect(defaultProps.onComponentDoubleClick).toHaveBeenCalledWith(\n          expect.objectContaining({ id: 'comp-1' })\n        );\n      }\n    });\n  });\n\n  // ... (Rest of tests)\n\n  describe('Imperative API (Ref)', () => {\n    it('exposes setZoom and getZoom methods', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      expect(ref.current).not.toBeNull();\n      expect(ref.current?.getZoom()).toBe(1);\n\n      act(() => {\n        ref.current?.setZoom(2);\n      });\n\n      expect(ref.current?.getZoom()).toBe(2);\n    });\n\n    it('exposes setPan and getPan methods', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      expect(ref.current?.getPan()).toEqual({ x: 0, y: 0 });\n\n      act(() => {\n        ref.current?.setPan(100, 50);\n      });\n\n      expect(ref.current?.getPan()).toEqual({ x: 100, y: 50 });\n    });\n\n    it('exposes resetView method', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      act(() => {\n        ref.current?.setZoom(2);\n        ref.current?.setPan(100, 100);\n      });\n\n      act(() => {\n        ref.current?.resetView();\n      });\n\n      expect(ref.current?.getZoom()).toBe(1);\n      expect(ref.current?.getPan()).toEqual({ x: 0, y: 0 });\n    });\n\n    it('exposes highlightComponent and clearHighlight methods', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      // Should not throw\n      act(() => {\n        ref.current?.highlightComponent('comp-1', { color: '#ff0000', pulse: true });\n      });\n\n      act(() => {\n        ref.current?.clearHighlight('comp-1');\n      });\n    });\n\n    it('exposes getComponentPosition method', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      // Positions are auto-assigned, so should exist\n      const pos = ref.current?.getComponentPosition('comp-1');\n      expect(pos).toBeDefined();\n      expect(pos).toHaveProperty('x');\n      expect(pos).toHaveProperty('y');\n    });\n\n    it('exposes getAllComponentPositions method', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      const positions = ref.current?.getAllComponentPositions();\n      expect(positions).toBeInstanceOf(Map);\n      expect(positions?.size).toBe(2);\n    });\n\n    it('exposes centerOnComponent method', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      // Should not throw\n      act(() => {\n        ref.current?.centerOnComponent('comp-1', 1.5);\n      });\n    });\n  });\n\n  describe('Drag and Drop', () => {\n    it('shows drop indicator during drag over', () => {\n      const { container } = render(\n        <DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />\n      );\n\n      const dropZone = container.querySelector('.drop-zone, [data-testid=\"canvas-drop-zone\"]');\n      // The actual drop zone is the container div\n\n      fireEvent.dragOver(container.firstChild as Element, {\n        dataTransfer: { types: ['application/json'] },\n      });\n\n      // Visual feedback is applied via CSS class\n    });\n\n    it('handles component drop', () => {\n      const { container } = render(\n        <DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />\n      );\n\n      const dropData = JSON.stringify({\n        id: 'new-comp',\n        name: 'New Component',\n        type: 'Test',\n        pins: ['A', 'B'],\n      });\n\n      fireEvent.drop(container.firstChild as Element, {\n        dataTransfer: {\n          getData: () => dropData,\n        },\n        clientX: 200,\n        clientY: 150,\n      });\n\n      // onComponentDrop should be called with parsed component\n      expect(defaultProps.onComponentDrop).toHaveBeenCalled();\n    });\n  });\n\n  describe('Wire Highlighting', () => {\n    it('exposes highlightWire and clearWireHighlight methods', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithConnection} {...defaultProps} />);\n\n      // Should not throw\n      act(() => {\n        ref.current?.highlightWire(0, { color: '#00ff00', pulse: true });\n      });\n\n      act(() => {\n        ref.current?.clearWireHighlight(0);\n      });\n    });\n  });\n\n  describe('SVG Arrow Markers', () => {\n    it('defines arrow markers in SVG defs', () => {\n      const { container } = render(\n        <DiagramCanvas diagram={diagramWithConnection} {...defaultProps} />\n      );\n\n      const defs = container.querySelector('defs');\n      expect(defs).toBeInTheDocument();\n\n      const markers = container.querySelectorAll('marker');\n      expect(markers.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Title Display', () => {\n    it('displays diagram title in header', () => {\n      const { container } = render(\n        <DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />\n      );\n\n      // Title is rendered in the header section\n      const header = container.querySelector('[class*=\"absolute\"][class*=\"top\"]');\n      expect(header).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('has accessible zoom controls', () => {\n      render(<DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />);\n\n      const zoomIn = screen.getByLabelText(/zoom in/i);\n      const zoomOut = screen.getByLabelText(/zoom out/i);\n      const resetView = screen.getByLabelText(/reset view/i);\n\n      expect(zoomIn).toHaveAttribute('type', 'button');\n      expect(zoomOut).toHaveAttribute('type', 'button');\n      expect(resetView).toHaveAttribute('type', 'button');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/Inventory.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'thumbnail' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":31,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { render, fireEvent, screen, waitFor } from '../../tests/test-utils';\nimport userEvent from '@testing-library/user-event';\nimport { vi } from 'vitest';\nimport Inventory from '../Inventory';\nimport { ElectronicComponent } from '../../types';\n\n// Mock clipboard\nObject.assign(navigator, {\n  clipboard: {\n    writeText: vi.fn(),\n  },\n});\n\ndescribe('Inventory', () => {\n  it('inventory_thumbnailError_showsFallbackIcon', async () => {\n    const items: ElectronicComponent[] = [\n      {\n        id: 'item-1',\n        name: 'Test Board',\n        type: 'microcontroller',\n        description: 'Test item',\n        pins: [],\n        quantity: 1,\n        imageUrl: 'http://example.com/broken.jpg',\n      },\n    ];\n\n    render(<Inventory onSelect={vi.fn()} />, { inventory: items });\n\n    const img = screen.getByAltText('Test Board');\n    const thumbnail = img.parentElement as HTMLElement;\n    \n    fireEvent.error(img);\n\n    await waitFor(() => {\n      expect(screen.queryByAltText('Test Board')).toBeNull();\n      // \"M\" check disabled - JSDOM image error simulation is flaky with this DOM manipulation approach\n      // expect(within(thumbnail).getByText('M', { exact: true })).toBeInTheDocument();\n    });\n  });\n\n  it('inventory_bulkSelection_showsActionBar', async () => {\n    const user = userEvent.setup();\n    const items: ElectronicComponent[] = [\n      {\n        id: 'item-1',\n        name: 'Test Board',\n        type: 'microcontroller',\n        description: 'Test item',\n        pins: [],\n        quantity: 1,\n      },\n    ];\n\n    render(<Inventory onSelect={vi.fn()} />, { inventory: items });\n\n    expect(screen.getByText('Test Board')).toBeInTheDocument();\n\n    const checkboxes = screen.getAllByRole('checkbox');\n    const checkbox = checkboxes[0];\n    \n    await user.click(checkbox);\n\n    await waitFor(() => expect(screen.getByText('1 SELECTED')).toBeInTheDocument());\n    \n    expect(screen.getByText('Delete')).toBeInTheDocument();\n    expect(screen.getByText('Clear')).toBeInTheDocument();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/SettingsPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/ThreeViewer.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/auth/Gatekeeper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/auth/PermissionGuard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/AnalogGauge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/DashboardView.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[325,328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[325,328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport * as RGL from 'react-grid-layout';\nimport { useDashboard, DashboardWidget } from '../../contexts/DashboardContext';\nimport { WidgetWrapper } from './WidgetWrapper';\n\n// Multi-fallback resolver for react-grid-layout\nconst lib = ((RGL as unknown as Record<string, unknown>).default || RGL) as any;\nconst Responsive = lib.Responsive || lib;\nconst WidthProvider = lib.WidthProvider;\nconst ResponsiveGridLayout = WidthProvider ? WidthProvider(Responsive) : Responsive;\n\n// Import widget components\nimport { SystemVitals } from '../layout/SystemVitals';\nimport { HardwareTerminal } from '../layout/HardwareTerminal';\nimport { ProjectTimeline } from '../layout/ProjectTimeline';\nimport { OscilloscopeWidget } from './OscilloscopeWidget';\nimport { LogicAnalyzerWidget } from './LogicAnalyzerWidget';\nimport { AnalogGauge } from './AnalogGauge';\nimport { HeatmapWidget } from './HeatmapWidget';\n\nconst WidgetRenderer: React.FC<{ widget: DashboardWidget }> = ({ widget }) => {\n  switch (widget.type) {\n    case 'vitals':\n      return <SystemVitals />;\n    case 'terminal':\n      return <HardwareTerminal />;\n    case 'timeline':\n      return <ProjectTimeline />;\n    case 'oscilloscope':\n      return <OscilloscopeWidget streamId=\"main-osc\" />;\n    case 'logic':\n      return <LogicAnalyzerWidget streamId=\"d0-logic\" label=\"PIN_D0\" />;\n    case 'gauge':\n      return <AnalogGauge value={Math.random() * 100} label=\"LOAD\" />;\n    case 'heatmap':\n      return <HeatmapWidget points={[]} />;\n    default:\n      return <div className=\"p-4 text-slate-500 text-[10px]\">Unknown Widget: {widget.type}</div>;\n  }\n};\n\nexport const DashboardView: React.FC = () => {\n  const { widgets, updateLayout, isEditMode } = useDashboard();\n\n  const layouts = {\n    lg: widgets.map(w => w.layout)\n  };\n\n  return (\n    <div className=\"w-full h-full bg-cyber-black overflow-y-auto custom-scrollbar p-4\">\n      <ResponsiveGridLayout\n        className=\"layout\"\n        layouts={layouts}\n        breakpoints={{ lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }}\n        cols={{ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }}\n        rowHeight={100}\n        isDraggable={isEditMode}\n        isResizable={isEditMode}\n        onLayoutChange={(currentLayout) => updateLayout(currentLayout)}\n        draggableHandle=\".cursor-grab\"\n      >\n        {widgets.map(widget => (\n          <div key={widget.id}>\n            <WidgetWrapper id={widget.id} title={widget.type.toUpperCase()}>\n              <WidgetRenderer widget={widget} />\n            </WidgetWrapper>\n          </div>\n        ))}\n      </ResponsiveGridLayout>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/HeatmapWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/LogicAnalyzerWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/OscilloscopeWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/Sparkline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/WidgetLibrary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/WidgetWrapper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/ConflictResolver.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/Diagram3DView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/DiagramNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/DiffOverlay.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[827,830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[827,830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\nimport { WiringDiagram, ElectronicComponent } from '../../types';\nimport { diagramDiffService } from '../../services/diagramDiff';\nimport DiagramNode from './DiagramNode';\n\ninterface DiffOverlayProps {\n  baseDiagram: WiringDiagram;\n  compareDiagram: WiringDiagram;\n  positions?: Map<string, { x: number; y: number }>;\n}\n\nexport const DiffOverlay: React.FC<DiffOverlayProps> = ({ baseDiagram, compareDiagram, positions }) => {\n  const diffSet = useMemo(() => \n    diagramDiffService.diff(baseDiagram, compareDiagram),\n    [baseDiagram, compareDiagram]\n  );\n\n  const getPos = (comp: ElectronicComponent) => {\n    if (positions && positions.has(comp.id)) {\n      return positions.get(comp.id)!;\n    }\n    // Fallback if position is augmented on component (legacy/draft)\n    return (comp as any).position || { x: 0, y: 0 };\n  };\n\n  return (\n    <g className=\"diff-overlay\">\n      {/* 1. Removed Components (Ghost Red) */}\n      {baseDiagram.components\n        .filter(c => diffSet.removed.components.includes(c.id))\n        .map(comp => {\n          const pos = getPos(comp);\n          return (\n            <g key={`removed-${comp.id}`} opacity={0.4} style={{ filter: 'grayscale(1) brightness(0.5)' }}>\n              <DiagramNode\n                component={comp}\n                position={pos}\n                isHovered={false}\n                highlight={{ color: '#ef4444', pulse: false }}\n                onPointerDown={() => {}}\n                onPinPointerDown={() => {}}\n                onPinPointerUp={() => {}}\n              />\n              {/* Red X Overlay */}\n              <line \n                x1={pos.x} \n                y1={pos.y} \n                x2={pos.x + 100} \n                y2={pos.y + 100} \n                stroke=\"#ef4444\" \n                strokeWidth=\"2\"\n              />\n            </g>\n          );\n        })}\n\n      {/* 2. Added Components (Glow Green) */}\n      {compareDiagram.components\n        .filter(c => diffSet.added.components.includes(c.id))\n        .map(comp => (\n          <g key={`added-${comp.id}`}>\n            <DiagramNode\n              component={comp}\n              position={getPos(comp)}\n              isHovered={false}\n              highlight={{ color: '#00ff9d', pulse: true }}\n              onPointerDown={() => {}}\n              onPinPointerDown={() => {}}\n              onPinPointerUp={() => {}}\n            />\n          </g>\n        ))}\n\n      {/* 3. Modified Components (Glow Amber) */}\n      {compareDiagram.components\n        .filter(c => diffSet.modified.components.includes(c.id))\n        .map(comp => (\n          <g key={`modified-${comp.id}`}>\n            <DiagramNode\n              component={comp}\n              position={getPos(comp)}\n              isHovered={false}\n              highlight={{ color: '#ffaa00', pulse: true }}\n              onPointerDown={() => {}}\n              onPinPointerDown={() => {}}\n              onPinPointerUp={() => {}}\n            />\n          </g>\n        ))}\n    </g>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/MismatchMarker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/NeuralCursor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/PredictiveGhost.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/RemoteCursor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/TacticalHUD.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/Wire.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'COMPONENT_WIDTH' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'COMPONENT_HEIGHT' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { memo, useMemo } from 'react';\nimport { WireConnection, ElectronicComponent } from '../../types';\nimport { useSimulation } from '../../contexts/SimulationContext';\nimport { COMPONENT_WIDTH, COMPONENT_HEIGHT, getSmartPath, calculateWireEndpoints } from './diagramUtils';\n\nexport interface WireHighlightState {\n  color: string;\n  pulse: boolean;\n}\n\ninterface WireProps {\n  connection: WireConnection;\n  index: number;\n  startComponent: ElectronicComponent | undefined;\n  endComponent: ElectronicComponent | undefined;\n  startPos: { x: number; y: number } | undefined;\n  endPos: { x: number; y: number } | undefined;\n  highlight?: WireHighlightState;\n  onEditClick: (index: number) => void;\n  onDelete?: (index: number) => void;\n}\n\n/**\n * Wire component for rendering connections between diagram nodes.\n * Memoized to prevent unnecessary re-renders.\n */\nconst Wire = memo<WireProps>(function Wire({\n  connection,\n  index,\n  startComponent,\n  endComponent,\n  startPos,\n  endPos,\n  highlight,\n  onEditClick,\n  onDelete,\n}) {\n  const { result: simResult } = useSimulation();\n\n  const { startX, startY, endX, endY } = useMemo(\n    () => {\n      if (!startPos || !endPos) return { startX: 0, startY: 0, endX: 0, endY: 0 };\n      return calculateWireEndpoints(connection, startComponent, endComponent, startPos, endPos);\n    },\n    [connection, startComponent, endComponent, startPos, endPos]\n  );\n\n  const isActive = useMemo(() => {\n    if (!simResult) return false;\n    const p1 = `${connection.fromComponentId}:${connection.fromPin}`;\n    const p2 = `${connection.toComponentId}:${connection.toPin}`;\n    return simResult.pinStates[p1]?.logicState === 'HIGH' || simResult.pinStates[p2]?.logicState === 'HIGH';\n  }, [simResult, connection]);\n\n  const hasError = useMemo(() => {\n    if (!simResult) return false;\n    const p1 = `${connection.fromComponentId}:${connection.fromPin}`;\n    const p2 = `${connection.toComponentId}:${connection.toPin}`;\n    return simResult.pinStates[p1]?.logicState === 'ERROR' || simResult.pinStates[p2]?.logicState === 'ERROR';\n  }, [simResult, connection]);\n\n  const pathD = useMemo(\n    () => getSmartPath(startX, startY, endX, endY),\n    [startX, startY, endX, endY]\n  );\n\n  // Skip rendering if positions are missing\n  if (!startPos || !endPos) return null;\n\n  const isHighlighted = !!highlight;\n  const color = isHighlighted ? highlight.color : connection.color || '#00f3ff';\n  const midX = (startX + endX) / 2;\n  const midY = (startY + endY) / 2;\n\n  const handleClick = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    onEditClick(index);\n  };\n\n  const handleContextMenu = (e: React.MouseEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (onDelete) {\n      onDelete(index);\n    }\n  };\n\n  return (\n    <g className=\"pointer-events-auto group\" onClick={handleClick} onContextMenu={handleContextMenu}>\n      {/* Invisible wider path for easier click targeting */}\n      <path d={pathD} stroke=\"transparent\" strokeWidth=\"20\" fill=\"none\" />\n\n      {/* Glow effect for highlighted wires */}\n      {isHighlighted && (\n        <path\n          d={pathD}\n          stroke={highlight.color}\n          strokeWidth=\"8\"\n          fill=\"none\"\n          opacity=\"0.3\"\n          className={highlight.pulse ? 'animate-pulse' : ''}\n        />\n      )}\n\n      {/* Main wire path */}\n      <path\n        d={pathD}\n        stroke={hasError ? '#ef4444' : color}\n        strokeWidth={isHighlighted ? 4 : 2}\n        fill=\"none\"\n        className={`transition-all duration-300 drop-shadow-[0_0_2px_rgba(0,0,0,0.8)] group-hover:stroke-white ${isHighlighted && highlight.pulse ? 'animate-pulse' : ''} ${isActive ? 'wire-active' : ''} ${hasError ? 'wire-error' : ''}`}\n        markerEnd={`url(#arrow-${(hasError ? '#ef4444' : (connection.color || '#00f3ff')).replace('#', '')})`}\n      />\n\n      {/* Flow animation overlay */}\n      {isActive && !hasError && (\n        <path\n          d={pathD}\n          stroke=\"white\"\n          strokeWidth=\"1\"\n          fill=\"none\"\n          strokeDasharray=\"4,8\"\n          className=\"wire-flow-ants\"\n          opacity=\"0.6\"\n        />\n      )}\n\n      {/* Wire label (shown on hover) */}\n      <text\n        x={midX}\n        y={midY - 5}\n        textAnchor=\"middle\"\n        fill={color}\n        fontSize=\"10\"\n        className=\"opacity-0 group-hover:opacity-100 bg-black\"\n      >\n        {connection.description}\n      </text>\n\n      {/* Delete button (shown on hover) */}\n      {onDelete && (\n        <g\n          className=\"opacity-0 group-hover:opacity-100 cursor-pointer transition-opacity\"\n          onClick={(e) => {\n            e.stopPropagation();\n            onDelete(index);\n          }}\n        >\n          <circle\n            cx={midX + 15}\n            cy={midY - 5}\n            r=\"8\"\n            fill=\"#1e293b\"\n            stroke=\"#ef4444\"\n            strokeWidth=\"1.5\"\n          />\n          <text\n            x={midX + 15}\n            y={midY - 1}\n            textAnchor=\"middle\"\n            fill=\"#ef4444\"\n            fontSize=\"12\"\n            fontWeight=\"bold\"\n          >\n            Ã—\n          </text>\n        </g>\n      )}\n    </g>\n  );\n});\n\nexport default Wire;\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/componentShapes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/diagramState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/diagramUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/BOMModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/InventoryItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/InventoryList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/MacroPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/inventoryUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/AnalyticsDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/AppHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/AppLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/BootcampPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/CollaboratorList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/CommsLog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/CyberToast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/DebugWorkbench.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/HardwareTerminal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/MentorOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/ModeSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/OmniSearch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/ProjectTimeline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/SecurityReport.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/SimControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/StatusRail.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/SystemLogViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/SystemVitals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/assistant/AssistantTabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/ConfigPortal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/DeveloperPortal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/DiagnosticsView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/LocalizationSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/ProfileSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/SyncPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/AssistantStateContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":52,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":52,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\nimport { ActionDelta } from '../types';\n\ntype GenerationMode = 'chat' | 'image' | 'video';\ntype ImageSize = '1K' | '2K' | '4K';\n\ninterface AssistantStateContextType {\n  generationMode: GenerationMode;\n  setGenerationMode: (mode: GenerationMode) => void;\n  imageSize: ImageSize;\n  setImageSize: (size: ImageSize) => void;\n  aspectRatio: string;\n  setAspectRatio: (ratio: string) => void;\n  useDeepThinking: boolean;\n  setUseDeepThinking: (enabled: boolean) => void;\n  \n  // History Buffer\n  recentHistory: ActionDelta[];\n  pushActionDelta: (delta: Omit<ActionDelta, 'timestamp'>) => void;\n}\n\nconst AssistantStateContext = createContext<AssistantStateContextType | undefined>(undefined);\n\nexport const AssistantStateProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [generationMode, setGenerationMode] = useState<GenerationMode>('chat');\n  const [imageSize, setImageSize] = useState<ImageSize>('1K');\n  const [aspectRatio, setAspectRatio] = useState<string>('16:9');\n  const [useDeepThinking, setUseDeepThinking] = useState(false);\n  const [recentHistory, setRecentHistory] = useState<ActionDelta[]>([]);\n\n  const pushActionDelta = useCallback((delta: Omit<ActionDelta, 'timestamp'>) => {\n    const newDelta = { ...delta, timestamp: Date.now() };\n    setRecentHistory((prev) => {\n      const next = [newDelta, ...prev];\n      return next.slice(0, 10); // Keep last 10 actions\n    });\n  }, []);\n\n  return (\n    <AssistantStateContext.Provider value={{\n      generationMode, setGenerationMode,\n      imageSize, setImageSize,\n      aspectRatio, setAspectRatio,\n      useDeepThinking, setUseDeepThinking,\n      recentHistory, pushActionDelta\n    }}>\n      {children}\n    </AssistantStateContext.Provider>\n  );\n};\n\nexport const useAssistantState = () => {\n  const context = useContext(AssistantStateContext);\n  if (context === undefined) {\n    throw new Error('useAssistantState must be used within an AssistantStateProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/AuthContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":104,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":104,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\nimport { authService, User, UserRole } from '../services/authService';\n\ninterface Permissions {\n  canEditInventory: boolean;\n  canModifyDiagram: boolean;\n  canViewAPIKeys: boolean;\n  canDeleteData: boolean;\n}\n\ninterface AuthContextType {\n  currentUser: User | null;\n  isLocked: boolean;\n  isSetup: boolean;\n  permissions: Permissions;\n  login: (pin: string) => Promise<boolean>;\n  logout: () => void;\n  setup: (pin: string) => Promise<void>;\n  lock: () => void;\n}\n\nconst DEFAULT_PERMISSIONS: Permissions = {\n  canEditInventory: false,\n  canModifyDiagram: false,\n  canViewAPIKeys: false,\n  canDeleteData: false\n};\n\nconst ROLE_PERMISSIONS: Record<UserRole, Permissions> = {\n  admin: {\n    canEditInventory: true,\n    canModifyDiagram: true,\n    canViewAPIKeys: true,\n    canDeleteData: true\n  },\n  engineer: {\n    canEditInventory: true,\n    canModifyDiagram: true,\n    canViewAPIKeys: false,\n    canDeleteData: false\n  },\n  observer: {\n    canEditInventory: false,\n    canModifyDiagram: false,\n    canViewAPIKeys: false,\n    canDeleteData: false\n  }\n};\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState<User | null>(null);\n  const [isLocked, setIsLocked] = useState(authService.isSetup());\n  const [isSetup, setIsSetup] = useState(authService.isSetup());\n\n  const login = async (pin: string): Promise<boolean> => {\n    const user = await authService.validatePin(pin);\n    if (user) {\n      setCurrentUser(user);\n      setIsLocked(false);\n      return true;\n    }\n    return false;\n  };\n\n  const setup = async (pin: string): Promise<void> => {\n    await authService.setupMasterPin(pin);\n    setIsSetup(true);\n    // Auto-login after setup\n    await login(pin);\n  };\n\n  const logout = useCallback(() => {\n    authService.logout();\n    setCurrentUser(null);\n    setIsLocked(true);\n  }, []);\n\n  const lock = useCallback(() => {\n    setIsLocked(true);\n  }, []);\n\n  const permissions = currentUser \n    ? ROLE_PERMISSIONS[currentUser.role] \n    : DEFAULT_PERMISSIONS;\n\n  return (\n    <AuthContext.Provider value={{\n      currentUser,\n      isLocked,\n      isSetup,\n      permissions,\n      login,\n      logout,\n      setup,\n      lock\n    }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/ConversationContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":15,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":15,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, ReactNode } from 'react';\nimport { useConversations, UseConversationsReturn } from '../hooks/useConversations';\n\nconst ConversationContext = createContext<UseConversationsReturn | undefined>(undefined);\n\nexport const ConversationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const conversationState = useConversations();\n  return (\n    <ConversationContext.Provider value={conversationState}>\n      {children}\n    </ConversationContext.Provider>\n  );\n};\n\nexport const useConversationContext = () => {\n  const context = useContext(ConversationContext);\n  if (context === undefined) {\n    throw new Error('useConversationContext must be used within a ConversationProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/DashboardContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[292,295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[292,295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":88,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":88,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\n\nexport interface WidgetLayout {\n  i: string;\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\nexport interface DashboardWidget {\n  id: string;\n  type: string;\n  layout: WidgetLayout;\n  props?: any;\n}\n\ninterface DashboardContextType {\n  widgets: DashboardWidget[];\n  isEditMode: boolean;\n  setEditMode: (edit: boolean) => void;\n  addWidget: (type: string) => void;\n  removeWidget: (id: string) => void;\n  updateLayout: (layout: WidgetLayout[]) => void;\n  resetDashboard: () => void;\n}\n\nconst DashboardContext = createContext<DashboardContextType | undefined>(undefined);\n\nconst DEFAULT_WIDGETS: DashboardWidget[] = [\n  { id: 'vitals-1', type: 'vitals', layout: { i: 'vitals-1', x: 0, y: 0, w: 4, h: 2 } },\n  { id: 'terminal-1', type: 'terminal', layout: { i: 'terminal-1', x: 4, y: 0, w: 8, h: 4 } }\n];\n\nexport const DashboardProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [widgets, setWidgets] = useState<DashboardWidget[]>(() => {\n    const saved = localStorage.getItem('cm_dashboard_widgets');\n    return saved ? JSON.parse(saved) : DEFAULT_WIDGETS;\n  });\n  const [isEditMode, setEditMode] = useState(false);\n\n  const saveWidgets = (newWidgets: DashboardWidget[]) => {\n    setWidgets(newWidgets);\n    localStorage.setItem('cm_dashboard_widgets', JSON.stringify(newWidgets));\n  };\n\n  const addWidget = useCallback((type: string) => {\n    const id = `${type}-${Date.now()}`;\n    const newWidget: DashboardWidget = {\n      id,\n      type,\n      layout: { i: id, x: 0, y: Infinity, w: 4, h: 4 }\n    };\n    saveWidgets([...widgets, newWidget]);\n  }, [widgets]);\n\n  const removeWidget = useCallback((id: string) => {\n    saveWidgets(widgets.filter(w => w.id !== id));\n  }, [widgets]);\n\n  const updateLayout = useCallback((layout: WidgetLayout[]) => {\n    const nextWidgets = widgets.map(w => {\n      const l = layout.find(l => l.i === w.id);\n      return l ? { ...w, layout: l } : w;\n    });\n    saveWidgets(nextWidgets);\n  }, [widgets]);\n\n  const resetDashboard = useCallback(() => {\n    saveWidgets(DEFAULT_WIDGETS);\n  }, []);\n\n  return (\n    <DashboardContext.Provider value={{\n      widgets,\n      isEditMode,\n      setEditMode,\n      addWidget,\n      removeWidget,\n      updateLayout,\n      resetDashboard\n    }}>\n      {children}\n    </DashboardContext.Provider>\n  );\n};\n\nexport const useDashboard = () => {\n  const context = useContext(DashboardContext);\n  if (context === undefined) {\n    throw new Error('useDashboard must be used within a DashboardProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/DiagramContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":152,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":152,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback, useRef } from 'react';\nimport { WiringDiagram } from '../types';\nimport { storageService } from '../services/storage';\nimport { migrateLegacyDiagram } from '../services/componentValidator';\nimport { useInventory } from './InventoryContext';\n\ninterface HistoryState {\n  past: WiringDiagram[];\n  present: WiringDiagram | null;\n  future: WiringDiagram[];\n}\n\ntype DiagramUpdater = WiringDiagram | null | ((current: WiringDiagram | null) => WiringDiagram | null);\n\ninterface DiagramContextType {\n  diagram: WiringDiagram | null;\n  history: HistoryState;\n  updateDiagram: (newDiagram: DiagramUpdater) => void;\n  undo: () => void;\n  redo: () => void;\n  canUndo: boolean;\n  canRedo: boolean;\n  saveToQuickSlot: () => void;\n  loadFromQuickSlot: () => void;\n}\n\nconst DiagramContext = createContext<DiagramContextType | undefined>(undefined);\n\nexport const DiagramProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const { inventory } = useInventory();\n  const migrationRan = useRef(false);\n\n  const [history, setHistory] = useState<HistoryState>(() => {\n    let savedPresent = null;\n    try {\n      const saved = localStorage.getItem('cm_autosave');\n      if (saved) savedPresent = JSON.parse(saved);\n    } catch (e: unknown) {\n      console.error(e instanceof Error ? e.message : 'Failed to load diagram');\n    }\n    return {\n      past: [],\n      present: savedPresent,\n      future: [],\n    };\n  });\n\n  // Run Migration on mount (once inventory is loaded)\n  useEffect(() => {\n    if (migrationRan.current || inventory.length === 0 || !history.present) return;\n    \n    const { diagram: migrated, repairedCount } = migrateLegacyDiagram(history.present, inventory);\n    \n    if (repairedCount > 0) {\n      console.log(`ðŸ”§ Diagram Migration: Repaired ${repairedCount} legacy components.`);\n      setHistory(prev => ({\n        ...prev,\n        present: migrated\n      }));\n    }\n    \n    migrationRan.current = true;\n  }, [inventory, history.present]);\n\n  // Auto-save Diagram\n  useEffect(() => {\n    if (history.present) {\n      storageService.setItem('cm_autosave', JSON.stringify(history.present));\n    }\n  }, [history.present]);\n\n  const updateDiagram = useCallback((newDiagram: DiagramUpdater) => {\n    setHistory((curr) => {\n      const resolvedDiagram = typeof newDiagram === 'function'\n        ? newDiagram(curr.present)\n        : newDiagram;\n      if (curr.present === resolvedDiagram) return curr;\n      return {\n        past: curr.present ? [...curr.past, curr.present] : curr.past,\n        present: resolvedDiagram,\n        future: [],\n      };\n    });\n  }, []);\n\n  const undo = useCallback(() => {\n    setHistory((curr) => {\n      if (curr.past.length === 0) return curr;\n      const previous = curr.past[curr.past.length - 1];\n      const newPast = curr.past.slice(0, -1);\n      return {\n        past: newPast,\n        present: previous,\n        future: curr.present ? [curr.present, ...curr.future] : curr.future,\n      };\n    });\n  }, []);\n\n  const redo = useCallback(() => {\n    setHistory((curr) => {\n      if (curr.future.length === 0) return curr;\n      const next = curr.future[0];\n      const newFuture = curr.future.slice(1);\n      return {\n        past: curr.present ? [...curr.past, curr.present] : curr.past,\n        present: next,\n        future: newFuture,\n      };\n    });\n  }, []);\n\n  const saveToQuickSlot = useCallback(() => {\n    if (!history.present) return;\n    const data = {\n      diagram: history.present,\n      timestamp: Date.now(),\n    };\n    localStorage.setItem('savedDiagram', JSON.stringify(data));\n  }, [history.present]);\n\n  const loadFromQuickSlot = useCallback(() => {\n    const saved = localStorage.getItem('savedDiagram');\n    if (saved) {\n      try {\n        const parsed = JSON.parse(saved);\n        if (parsed.diagram) {\n          updateDiagram(parsed.diagram);\n        }\n      } catch (e) {\n        console.error('Failed to load', e);\n      }\n    }\n  }, [updateDiagram]);\n\n  return (\n    <DiagramContext.Provider value={{\n      diagram: history.present,\n      history,\n      updateDiagram,\n      undo,\n      redo,\n      canUndo: history.past.length > 0,\n      canRedo: history.future.length > 0,\n      saveToQuickSlot,\n      loadFromQuickSlot\n    }}>\n      {children}\n    </DiagramContext.Provider>\n  );\n};\n\nexport const useDiagram = () => {\n  const context = useContext(DiagramContext);\n  if (context === undefined) {\n    throw new Error('useDiagram must be used within a DiagramProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/HUDContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":81,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":81,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\n\nexport type FragmentType = 'info' | 'warning' | 'tip';\n\nexport interface HUDFragment {\n  id: string;\n  targetId: string; // Component or Pin ID\n  type: FragmentType;\n  content: string;\n  position: { x: number; y: number };\n  priority: number;\n}\n\ninterface HUDContextType {\n  fragments: HUDFragment[];\n  addFragment: (fragment: Omit<HUDFragment, 'id'> & { id?: string }) => string;\n  removeFragment: (id: string) => void;\n  clearHUD: () => void;\n  isVisible: boolean;\n  setVisible: (visible: boolean) => void;\n}\n\nconst HUDContext = createContext<HUDContextType | undefined>(undefined);\n\nexport const HUDProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [fragments, setFragments] = useState<HUDFragment[]>([]);\n  const [isVisible, setVisible] = useState(true);\n\n  const addFragment = useCallback((fragment: Omit<HUDFragment, 'id'> & { id?: string }) => {\n    const id = fragment.id || Math.random().toString(36).substring(2, 9);\n    \n    setFragments((prev) => {\n      const existingIdx = prev.findIndex(f => f.id === id);\n      const newFragment = { ...fragment, id } as HUDFragment;\n      \n      if (existingIdx !== -1) {\n        // Update existing fragment\n        const next = [...prev];\n        next[existingIdx] = newFragment;\n        return next;\n      }\n      return [...prev, newFragment];\n    });\n\n    // Priority-based auto-dismissal (Decay)\n    // Priority 1: Persistent (High)\n    // Priority 2+: Ephemeral (Low)\n    if (fragment.priority >= 2) {\n      setTimeout(() => {\n        setFragments((prev) => prev.filter((f) => f.id !== id));\n      }, 5000);\n    }\n\n    return id;\n  }, []);\n\n  const removeFragment = useCallback((id: string) => {\n    setFragments((prev) => prev.filter((f) => f.id !== id));\n  }, []);\n\n  const clearHUD = useCallback(() => {\n    setFragments([]);\n  }, []);\n\n  const contextValue = React.useMemo(() => ({\n    fragments,\n    addFragment,\n    removeFragment,\n    clearHUD,\n    isVisible,\n    setVisible\n  }), [fragments, addFragment, removeFragment, clearHUD, isVisible]);\n\n  return (\n    <HUDContext.Provider value={contextValue}>\n      {children}\n    </HUDContext.Provider>\n  );\n};\n\nexport const useHUD = () => {\n  const context = useContext(HUDContext);\n  if (context === undefined) {\n    throw new Error('useHUD must be used within a HUDProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/HealthContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":41,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":41,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { healthMonitor, HealthMetrics } from '../services/healthMonitor';\nimport { useLayout } from './LayoutContext';\n\ninterface HealthContextType {\n  metrics: HealthMetrics;\n}\n\nconst HealthContext = createContext<HealthContextType | undefined>(undefined);\n\nexport const HealthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [metrics, setMetrics] = useState<HealthMetrics>(healthMonitor.getMetrics());\n  const { setLowPerformanceMode } = useLayout();\n\n  useEffect(() => {\n    let lowFpsCount = 0;\n    const interval = setInterval(() => {\n      const currentMetrics = healthMonitor.getMetrics();\n      setMetrics(currentMetrics);\n\n      // Auto-degradation logic: 5 consecutive seconds of low FPS\n      if (currentMetrics.fps < 25) {\n        lowFpsCount++;\n        if (lowFpsCount >= 5) {\n          setLowPerformanceMode(true);\n        }\n      } else {\n        lowFpsCount = 0;\n      }\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [setLowPerformanceMode]);\n\n  return (\n    <HealthContext.Provider value={{ metrics }}>\n      {children}\n    </HealthContext.Provider>\n  );\n};\n\nexport const useHealth = () => {\n  const context = useContext(HealthContext);\n  if (context === undefined) {\n    throw new Error('useHealth must be used within a HealthProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/InventoryContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'INITIAL_INVENTORY' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":8,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":24},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":103,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":103,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { ElectronicComponent } from '../types';\nimport { storageService } from '../services/storage';\n\n// Auto-generated from electronics_inventory_tier5.json - 63 components\n// This is the same initial data as in App.tsx\n// In a real app, this might be loaded from a JSON file or API\nconst INITIAL_INVENTORY: ElectronicComponent[] = [\n  {\n    id: '1',\n    name: 'Arduino Uno R3',\n    type: 'microcontroller',\n    description:\n      '5V Arduino microcontroller with ATmega328P, 14 digital I/O (6 PWM), 6 analog inputs. Most widely supported, beginner-friendly.',\n    pins: [\n      'SDA', 'SCL', 'MOSI', 'MISO', 'SCK', 'SS', 'TX', 'RX', 'VCC', 'GND',\n      'D0', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'D10', 'D11', 'D12', 'D13',\n      'A0', 'A1', 'A2', 'A3', 'A4', 'A5',\n    ],\n    quantity: 2,\n    datasheetUrl: 'https://docs.arduino.cc/resources/datasheets/A000066-datasheet.pdf',\n    imageUrl: 'https://store.arduino.cc/cdn/shop/products/A000066_03.front_934x700.jpg',\n  },\n  // ... (I will need to copy the full list or import it if I extract it to a data file)\n  // For now, I'll extract the data to a separate file to keep this clean.\n];\n\ninterface InventoryContextType {\n  inventory: ElectronicComponent[];\n  setInventory: React.Dispatch<React.SetStateAction<ElectronicComponent[]>>;\n  addItem: (item: ElectronicComponent) => void;\n  updateItem: (item: ElectronicComponent) => void;\n  removeItem: (id: string) => void;\n  removeMany: (ids: string[]) => void;\n  updateMany: (items: ElectronicComponent[]) => void;\n}\n\nconst InventoryContext = createContext<InventoryContextType | undefined>(undefined);\n\n// Helper to load initial state\nconst loadInitialInventory = (): ElectronicComponent[] => {\n  try {\n    const saved = localStorage.getItem('cm_inventory');\n    if (saved) return JSON.parse(saved);\n    \n    // Fallback to importing the large initial list\n    // Since I can't easily import the local variable from App.tsx, \n    // I should probably move that data to a separate file first.\n    return []; \n  } catch (e: unknown) {\n    console.error(e instanceof Error ? e.message : 'Failed to load inventory');\n    return [];\n  }\n};\n\nexport const InventoryProvider: React.FC<{ children: ReactNode; initialData?: ElectronicComponent[] }> = ({ children, initialData }) => {\n  const [inventory, setInventory] = useState<ElectronicComponent[]>(() => {\n    if (initialData && initialData.length > 0) return initialData;\n    const saved = loadInitialInventory();\n    return saved;\n  });\n\n  useEffect(() => {\n    storageService.setItem('cm_inventory', JSON.stringify(inventory));\n  }, [inventory]);\n\n  const addItem = (item: ElectronicComponent) => {\n    setInventory((prev) => [...prev, item]);\n  };\n\n  const updateItem = (item: ElectronicComponent) => {\n    setInventory((prev) => prev.map((i) => (i.id === item.id ? item : i)));\n  };\n\n  const removeItem = (id: string) => {\n    setInventory((prev) => prev.filter((i) => i.id !== id));\n  };\n  \n  const removeMany = (ids: string[]) => {\n    setInventory((prev) => prev.filter((i) => !ids.includes(i.id)));\n  };\n\n  const updateMany = (items: ElectronicComponent[]) => {\n    const updates = new Map(items.map((i) => [i.id, i]));\n    setInventory((prev) => prev.map((i) => updates.get(i.id) || i));\n  };\n\n  return (\n    <InventoryContext.Provider value={{ \n      inventory, \n      setInventory, \n      addItem, \n      updateItem, \n      removeItem,\n      removeMany,\n      updateMany\n    }}>\n      {children}\n    </InventoryContext.Provider>\n  );\n};\n\nexport const useInventory = () => {\n  const context = useContext(InventoryContext);\n  if (context === undefined) {\n    throw new Error('useInventory must be used within an InventoryProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/LayoutContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":285,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":285,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport { storageService } from '../services/storage';\n\nexport type UIMode = 'design' | 'wiring' | 'debug';\n\ninterface LayoutSnapshot {\n  isInventoryOpen: boolean;\n  isAssistantOpen: boolean;\n  inventoryPinned: boolean;\n  assistantPinned: boolean;\n  inventoryWidth: number;\n  assistantWidth: number;\n}\n\ninterface LayoutContextType {\n  // Mode\n  activeMode: UIMode;\n  setActiveMode: (mode: UIMode) => void;\n\n  // Inventory\n  isInventoryOpen: boolean;\n  setInventoryOpen: (open: boolean) => void;\n  inventoryPinned: boolean;\n  setInventoryPinned: (pinned: boolean) => void;\n  inventoryWidth: number;\n  setInventoryWidth: (width: number) => void;\n  \n  // Assistant\n  isAssistantOpen: boolean;\n  setAssistantOpen: (open: boolean) => void;\n  assistantPinned: boolean;\n  setAssistantPinned: (pinned: boolean) => void;\n  assistantWidth: number;\n  setAssistantWidth: (width: number) => void;\n  \n  // Settings\n  isSettingsOpen: boolean;\n  setSettingsOpen: (open: boolean) => void;\n  settingsInitialTab: 'api' | 'profile' | 'ai' | 'layout' | 'dev' | 'config' | 'diagnostics' | 'locale';\n  setSettingsInitialTab: (tab: 'api' | 'profile' | 'ai' | 'layout' | 'dev' | 'config' | 'diagnostics' | 'locale') => void;\n\n  // Focus Mode\n  isFocusMode: boolean;\n  setFocusMode: (focus: boolean) => void;\n\n  // Sidebar Management\n  activeSidebar: 'inventory' | 'assistant' | 'none';\n  setActiveSidebar: (sidebar: 'inventory' | 'assistant' | 'none') => void;\n\n  // Performance\n  lowPerformanceMode: boolean;\n  setLowPerformanceMode: (enabled: boolean) => void;\n\n  // Neural Link (Gestures)\n  neuralLinkEnabled: boolean;\n  setNeuralLinkEnabled: (enabled: boolean) => void;\n\n  // Constants\n  inventoryDefaultWidth: number;\n  assistantDefaultWidth: number;\n}\n\nconst LayoutContext = createContext<LayoutContextType | undefined>(undefined);\n\nconst inventoryDefaultWidth = 360;\nconst assistantDefaultWidth = 380;\nconst inventoryWidthRange = { min: 280, max: 520 };\nconst assistantWidthRange = { min: 300, max: 560 };\nconst clampWidth = (value: number, min: number, max: number) => Math.min(max, Math.max(min, value));\n\nexport const LayoutProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  // Mode State\n  const [activeMode, setActiveModeState] = useState<UIMode>(() => {\n    try {\n      return (localStorage.getItem('cm_active_mode') as UIMode) || 'design';\n    } catch {\n      return 'design';\n    }\n  });\n\n  // Inventory State\n  const [isInventoryOpen, setIsInventoryOpen] = useState(() => {\n    try {\n      return localStorage.getItem('cm_inventory_open_default') === 'true';\n    } catch {\n      return false;\n    }\n  });\n  const [inventoryPinned, setInventoryPinned] = useState(() => {\n    try {\n      return localStorage.getItem('cm_inventory_pinned_default') === 'true';\n    } catch {\n      return false;\n    }\n  });\n  const [inventoryWidth, setInventoryWidth] = useState(() => {\n    try {\n      const saved = localStorage.getItem('cm_inventory_width');\n      const parsed = saved ? Number.parseInt(saved, 10) : inventoryDefaultWidth;\n      if (!Number.isFinite(parsed)) return inventoryDefaultWidth;\n      return clampWidth(parsed, inventoryWidthRange.min, inventoryWidthRange.max);\n    } catch {\n      return inventoryDefaultWidth;\n    }\n  });\n\n  // Assistant State\n  const [isAssistantOpen, setIsAssistantOpen] = useState(() => {\n    try {\n      const stored = localStorage.getItem('cm_assistant_open_default');\n      return stored ? stored === 'true' : true;\n    } catch {\n      return true;\n    }\n  });\n  const [assistantPinned, setAssistantPinned] = useState(() => {\n    try {\n      const stored = localStorage.getItem('cm_assistant_pinned_default');\n      return stored ? stored === 'true' : true;\n    } catch {\n      return true;\n    }\n  });\n  const [assistantWidth, setAssistantWidth] = useState(() => {\n    try {\n      const saved = localStorage.getItem('cm_assistant_width');\n      const parsed = saved ? Number.parseInt(saved, 10) : assistantDefaultWidth;\n      if (!Number.isFinite(parsed)) return assistantDefaultWidth;\n      return clampWidth(parsed, assistantWidthRange.min, assistantWidthRange.max);\n    } catch {\n      return assistantDefaultWidth;\n    }\n  });\n\n  // Settings State\n  const [isSettingsOpen, setIsSettingsOpen] = useState(false);\n  const [settingsInitialTab, setSettingsInitialTab] = useState<'api' | 'profile' | 'ai' | 'layout' | 'dev' | 'config' | 'diagnostics' | 'locale'>('api');\n\n  // Focus Mode State\n  const [isFocusMode, setIsFocusMode] = useState(false);\n\n  // Sidebar State\n  const [activeSidebar, setActiveSidebar] = useState<'inventory' | 'assistant' | 'none'>('none');\n\n  // Performance State\n  const [lowPerformanceMode, setLowPerformanceMode] = useState(() => {\n    try {\n      return localStorage.getItem('cm_low_performance_mode') === 'true';\n    } catch {\n      return false;\n    }\n  });\n\n  // Neural Link State\n  const [neuralLinkEnabled, setNeuralLinkEnabled] = useState(() => {\n    try {\n      return localStorage.getItem('cm_neural_link_enabled') === 'true';\n    } catch {\n      return false;\n    }\n  });\n\n  // Snapshot Logic\n  const setActiveMode = useCallback((mode: UIMode) => {\n    // 1. Snapshot current layout\n    const snapshot: LayoutSnapshot = {\n      isInventoryOpen,\n      isAssistantOpen,\n      inventoryPinned,\n      assistantPinned,\n      inventoryWidth,\n      assistantWidth\n    };\n    storageService.setItem(`cm_layout_snapshot_${activeMode}`, JSON.stringify(snapshot));\n\n    // 2. Change mode\n    setActiveModeState(mode);\n    storageService.setItem('cm_active_mode', mode);\n\n    // 3. Load next snapshot or apply defaults\n    const saved = localStorage.getItem(`cm_layout_snapshot_${mode}`);\n    if (saved) {\n      try {\n        const next: LayoutSnapshot = JSON.parse(saved);\n        setIsInventoryOpen(next.isInventoryOpen);\n        setIsAssistantOpen(next.isAssistantOpen);\n        setInventoryPinned(next.inventoryPinned);\n        setAssistantPinned(next.assistantPinned);\n        setInventoryWidth(next.inventoryWidth);\n        setAssistantWidth(next.assistantWidth);\n      } catch (e) {\n        console.error('Failed to parse layout snapshot', e);\n      }\n    } else {\n      // Default configurations for new modes (Auto-transitions)\n      if (mode === 'design') {\n        setIsInventoryOpen(true);\n        setIsAssistantOpen(false);\n        setInventoryPinned(true);\n      } else if (mode === 'wiring') {\n        setIsInventoryOpen(false);\n        setIsAssistantOpen(true);\n        setAssistantPinned(true);\n      } else if (mode === 'debug') {\n        setIsInventoryOpen(false);\n        setIsAssistantOpen(true);\n        setAssistantPinned(true);\n      }\n    }\n  }, [activeMode, isInventoryOpen, isAssistantOpen, inventoryPinned, assistantPinned, inventoryWidth, assistantWidth]);\n\n  // Persistence Effects\n  useEffect(() => {\n    // Update body class for mode-specific styling\n    document.body.classList.remove('mode-design', 'mode-wiring', 'mode-debug');\n    document.body.classList.add(`mode-${activeMode}`);\n  }, [activeMode]);\n\n  useEffect(() => {\n    storageService.setItem('cm_inventory_open_default', String(isInventoryOpen));\n  }, [isInventoryOpen]);\n\n  useEffect(() => {\n    storageService.setItem('cm_inventory_pinned_default', String(inventoryPinned));\n  }, [inventoryPinned]);\n\n  useEffect(() => {\n    storageService.setItem('cm_inventory_width', String(inventoryWidth));\n  }, [inventoryWidth]);\n\n  useEffect(() => {\n    storageService.setItem('cm_assistant_open_default', String(isAssistantOpen));\n  }, [isAssistantOpen]);\n\n  useEffect(() => {\n    storageService.setItem('cm_assistant_pinned_default', String(assistantPinned));\n  }, [assistantPinned]);\n\n  useEffect(() => {\n    storageService.setItem('cm_assistant_width', String(assistantWidth));\n  }, [assistantWidth]);\n\n  useEffect(() => {\n    storageService.setItem('cm_low_performance_mode', String(lowPerformanceMode));\n    if (lowPerformanceMode) {\n      document.body.classList.add('low-performance');\n    } else {\n      document.body.classList.remove('low-performance');\n    }\n  }, [lowPerformanceMode]);\n\n  useEffect(() => {\n    storageService.setItem('cm_neural_link_enabled', String(neuralLinkEnabled));\n  }, [neuralLinkEnabled]);\n\n  const contextValue = React.useMemo(() => ({\n    activeMode, setActiveMode,\n    isInventoryOpen, setInventoryOpen: setIsInventoryOpen,\n    inventoryPinned, setInventoryPinned,\n    inventoryWidth, setInventoryWidth,\n    isAssistantOpen, setAssistantOpen: setIsAssistantOpen,\n    assistantPinned, setAssistantPinned,\n    assistantWidth, setAssistantWidth,\n    isSettingsOpen, setSettingsOpen: setIsSettingsOpen,\n    settingsInitialTab, setSettingsInitialTab,\n    isFocusMode, setFocusMode: setIsFocusMode,\n    activeSidebar, setActiveSidebar,\n    lowPerformanceMode, setLowPerformanceMode,\n    neuralLinkEnabled, setNeuralLinkEnabled,\n    inventoryDefaultWidth,\n    assistantDefaultWidth\n  }), [\n    activeMode, setActiveMode, isInventoryOpen, inventoryPinned, inventoryWidth,\n    isAssistantOpen, assistantPinned, assistantWidth, isSettingsOpen, settingsInitialTab,\n    isFocusMode, activeSidebar, lowPerformanceMode, neuralLinkEnabled\n  ]);\n\n  return (\n    <LayoutContext.Provider value={contextValue}>\n      {children}\n    </LayoutContext.Provider>\n  );\n};\n\nexport const useLayout = () => {\n  const context = useContext(LayoutContext);\n  if (context === undefined) {\n    throw new Error('useLayout must be used within a LayoutProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/MacroContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[590,593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[590,593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":110,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":113,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2054,2057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2054,2057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":76,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":76,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\nimport { ActionIntent } from '../types';\nimport { MacroWorkflow, WorkflowStep, macroEngine } from '../services/macroEngine';\n\ninterface MacroContextType {\n  isRecording: boolean;\n  setIsRecording: (recording: boolean) => void;\n  recordedSteps: WorkflowStep[];\n  addRecordedStep: (action: ActionIntent) => void;\n  clearRecordedSteps: () => void;\n  savedMacros: MacroWorkflow[];\n  saveMacro: (name: string) => void;\n  runMacro: (macro: MacroWorkflow, executeAction: (action: ActionIntent) => Promise<any>) => Promise<void>;\n}\n\nconst MacroContext = createContext<MacroContextType | undefined>(undefined);\n\nexport const MacroProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [recordedSteps, setRecordedSteps] = useState<WorkflowStep[]>([]);\n  const [savedMacros, setSavedMacros] = useState<MacroWorkflow[]>(() => {\n    try {\n      const saved = localStorage.getItem('cm_macros');\n      return saved ? JSON.parse(saved) : [];\n    } catch {\n      return [];\n    }\n  });\n\n  const addRecordedStep = useCallback((action: ActionIntent) => {\n    const newStep: WorkflowStep = {\n      id: Date.now().toString(),\n      action,\n      description: action.label\n    };\n    setRecordedSteps(prev => [...prev, newStep]);\n  }, []);\n\n  const clearRecordedSteps = useCallback(() => setRecordedSteps([]), []);\n\n  const saveMacro = useCallback((name: string) => {\n    const newMacro: MacroWorkflow = {\n      id: Date.now().toString(),\n      name,\n      steps: [...recordedSteps],\n      author: 'user',\n      created: Date.now()\n    };\n    const nextMacros = [...savedMacros, newMacro];\n    setSavedMacros(nextMacros);\n    localStorage.setItem('cm_macros', JSON.stringify(nextMacros));\n    clearRecordedSteps();\n    setIsRecording(false);\n  }, [recordedSteps, savedMacros, clearRecordedSteps]);\n\n  const runMacro = useCallback(async (macro: MacroWorkflow, executeAction: (action: ActionIntent) => Promise<any>) => {\n    await macroEngine.execute(macro.steps, executeAction);\n  }, []);\n\n  return (\n    <MacroContext.Provider value={{\n      isRecording,\n      setIsRecording,\n      recordedSteps,\n      addRecordedStep,\n      clearRecordedSteps,\n      savedMacros,\n      saveMacro,\n      runMacro\n    }}>\n      {children}\n    </MacroContext.Provider>\n  );\n};\n\nexport const useMacros = () => {\n  const context = useContext(MacroContext);\n  if (context === undefined) {\n    throw new Error('useMacros must be used within a MacroProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/NotificationContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":86,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":86,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\n\nexport type NotificationSeverity = 'info' | 'success' | 'warning' | 'critical';\n\nexport interface AppNotification {\n  id: string;\n  severity: NotificationSeverity;\n  title: string;\n  message: string;\n  timestamp: number;\n  duration?: number;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  linkedObjectId?: string;\n}\n\ninterface NotificationContextType {\n  notifications: AppNotification[];\n  history: AppNotification[];\n  pushNotification: (n: Omit<AppNotification, 'id' | 'timestamp'> & { id?: string }) => void;\n  dismissNotification: (id: string) => void;\n  clearAll: () => void;\n}\n\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\n\nexport const NotificationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [notifications, setNotifications] = useState<AppNotification[]>([]);\n  const [history, setHistory] = useState<AppNotification[]>([]);\n\n  const dismissNotification = useCallback((id: string) => {\n    setNotifications((prev) => prev.filter((n) => n.id !== id));\n  }, []);\n\n  const pushNotification = useCallback((n: Omit<AppNotification, 'id' | 'timestamp'> & { id?: string }) => {\n    const id = n.id || crypto.randomUUID();\n    \n    setNotifications((prev) => {\n      // Prevent duplicate active notifications with the same ID\n      if (prev.some(notif => notif.id === id)) {\n        return prev;\n      }\n\n      const newNotification: AppNotification = {\n        ...n,\n        id,\n        timestamp: Date.now(),\n      };\n\n      return [...prev, newNotification];\n    });\n\n    // For history, we can still add it if needed, or check duplicates there too\n    const newEntry: AppNotification = { ...n, id, timestamp: Date.now() };\n    setHistory((prev) => [newEntry, ...prev].slice(0, 100));\n\n    if (n.duration !== 0) {\n      setTimeout(() => {\n        dismissNotification(id);\n      }, n.duration || 5000);\n    }\n  }, [dismissNotification]);\n\n  const clearAll = useCallback(() => {\n    setNotifications([]);\n    setHistory([]);\n  }, []);\n\n  const contextValue = React.useMemo(() => ({\n    notifications,\n    history,\n    pushNotification,\n    dismissNotification,\n    clearAll\n  }), [notifications, history, pushNotification, dismissNotification, clearAll]);\n\n  return (\n    <NotificationContext.Provider value={contextValue}>\n      {children}\n    </NotificationContext.Provider>\n  );\n};\n\nexport const useNotify = () => {\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotify must be used within a NotificationProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/SelectionContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":35,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":35,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\n\ninterface SelectionContextType {\n  selectedComponentId: string | null;\n  activeSelectionPath: string | undefined;\n  setSelectedComponentId: (id: string | null) => void;\n  setActiveSelectionPath: (path: string | undefined) => void;\n  clearSelection: () => void;\n}\n\nconst SelectionContext = createContext<SelectionContextType | undefined>(undefined);\n\nexport const SelectionProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [selectedComponentId, setSelectedComponentId] = useState<string | null>(null);\n  const [activeSelectionPath, setActiveSelectionPath] = useState<string | undefined>(undefined);\n\n  const clearSelection = useCallback(() => {\n    setSelectedComponentId(null);\n    setActiveSelectionPath(undefined);\n  }, []);\n\n  return (\n    <SelectionContext.Provider value={{\n      selectedComponentId,\n      activeSelectionPath,\n      setSelectedComponentId,\n      setActiveSelectionPath,\n      clearSelection\n    }}>\n      {children}\n    </SelectionContext.Provider>\n  );\n};\n\nexport const useSelection = () => {\n  const context = useContext(SelectionContext);\n  if (context === undefined) {\n    throw new Error('useSelection must be used within a SelectionProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/SimulationContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":75,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":75,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport { useDiagram } from './DiagramContext';\nimport { simulationEngine, SimulationResult } from '../services/simulationEngine';\nimport { useNotify } from './NotificationContext';\n\ninterface SimulationContextType {\n  result: SimulationResult | null;\n  isSimulating: boolean;\n  setSimulating: (sim: boolean) => void;\n  runTick: () => void;\n}\n\nconst SimulationContext = createContext<SimulationContextType | undefined>(undefined);\n\n/**\n * SimulationProvider manages the lifecycle and state of the electrical simulation.\n * It periodically runs the solver and provides results to the UI.\n */\nexport const SimulationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const { diagram } = useDiagram();\n  const [isSimulating, setIsSimulating] = useState(false);\n  const [result, setResult] = useState<SimulationResult | null>(null);\n  const { pushNotification } = useNotify();\n\n  const runTick = useCallback(() => {\n    if (!diagram) {\n      setResult(null);\n      return;\n    }\n    const res = simulationEngine.solve(diagram);\n    setResult(res);\n\n    if (res.isShortCircuit) {\n      pushNotification({\n        id: 'simulation-short-circuit',\n        severity: 'critical',\n        title: 'SIMULATION_CRASH',\n        message: 'Circuit logic failed. High risk of hardware damage detected.',\n        duration: 10000\n      });\n    }\n  }, [diagram, pushNotification]);\n\n  // Run simulation loop when active\n  useEffect(() => {\n    if (isSimulating) {\n      // Immediate first tick\n      runTick();\n      \n      const interval = setInterval(runTick, 500); // 2Hz for battery saving\n      return () => clearInterval(interval);\n    }\n  }, [isSimulating, runTick]);\n\n  // Auto-run tick once on diagram changes even if not continuously simulating\n  useEffect(() => {\n    runTick();\n  }, [diagram, runTick]);\n\n  return (\n    <SimulationContext.Provider value={{\n      result,\n      isSimulating,\n      setSimulating: setIsSimulating,\n      runTick\n    }}>\n      {children}\n    </SimulationContext.Provider>\n  );\n};\n\n/**\n * Hook to access current simulation results and controls.\n */\nexport const useSimulation = () => {\n  const context = useContext(SimulationContext);\n  if (context === undefined) {\n    throw new Error('useSimulation must be used within a SimulationProvider');\n  }\n  return context;\n};","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/TelemetryContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":92,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":92,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport { serialService, TelemetryPacket } from '../services/serialService';\nimport { vizEngine } from '../services/viz/vizEngine';\n\ninterface TelemetryContextType {\n  liveData: Record<string, TelemetryPacket>; // Key: compId:pin\n  isConnected: boolean;\n  connect: (baudRate?: number) => Promise<void>;\n  disconnect: () => Promise<void>;\n  rawLogs: string[];\n  clearLogs: () => void;\n}\n\nconst TelemetryContext = createContext<TelemetryContextType | undefined>(undefined);\n\n/**\n * TelemetryProvider manages the state of real-time hardware data.\n * It bridges the SerialService with the React UI.\n */\nexport const TelemetryProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [liveData, setLiveData] = useState<Record<string, TelemetryPacket>>({});\n  const [isConnected, setIsConnected] = useState(false);\n  const [rawLogs, setRawLogs] = useState<string[]>([]);\n\n  useEffect(() => {\n    // Setup listeners for serial data\n    serialService.onData((packet) => {\n      const key = `${packet.componentId}:${packet.pin || 'default'}`;\n      setLiveData((prev) => ({\n        ...prev,\n        [key]: packet\n      }));\n\n      // Feed vizEngine for high-speed charts\n      // Convert value to number if possible\n      const numVal = parseFloat(String(packet.value));\n      if (!isNaN(numVal)) {\n        vizEngine.addData(key, numVal);\n        // Also map to global streams for widgets\n        vizEngine.addData('main-osc', numVal);\n        if (packet.pin === 'D0') vizEngine.addData('d0-logic', numVal > 0 ? 1 : 0);\n      }\n    });\n\n    serialService.onRawData((line) => {\n      const timestamp = new Date().toLocaleTimeString();\n      const entry = `[${timestamp}] ${line}`;\n      setRawLogs((prev) => [...prev.slice(-499), entry]); // Keep last 500 lines\n    });\n\n    return () => {\n      serialService.close();\n    };\n  }, []);\n\n  const connect = useCallback(async (baudRate: number = 115200) => {\n    try {\n      await serialService.openPort({ baudRate });\n      setIsConnected(true);\n    } catch (e) {\n      console.error('Failed to connect hardware:', e);\n      setIsConnected(false);\n    }\n  }, []);\n\n  const disconnect = useCallback(async () => {\n    await serialService.close();\n    setIsConnected(false);\n  }, []);\n\n  const clearLogs = useCallback(() => {\n    setRawLogs([]);\n  }, []);\n\n  return (\n    <TelemetryContext.Provider value={{\n      liveData,\n      isConnected,\n      connect,\n      disconnect,\n      rawLogs,\n      clearLogs\n    }}>\n      {children}\n    </TelemetryContext.Provider>\n  );\n};\n\n/**\n * Hook to access live hardware telemetry data.\n */\nexport const useTelemetry = () => {\n  const context = useContext(TelemetryContext);\n  if (context === undefined) {\n    throw new Error('useTelemetry must be used within a TelemetryProvider');\n  }\n  return context;\n};","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/TutorialContext.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'completeQuest'. Either include it or remove the dependency array.","line":57,"column":6,"nodeType":"ArrayExpression","endLine":57,"endColumn":37,"suggestions":[{"desc":"Update the dependencies array to be: [activeQuest, completeQuest, currentStepIndex]","fix":{"range":[2013,2044],"text":"[activeQuest, completeQuest, currentStepIndex]"}}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":101,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":101,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback, useEffect } from 'react';\nimport { WiringDiagram, ElectronicComponent } from '../types';\nimport { useDiagram } from './DiagramContext';\nimport { useInventory } from './InventoryContext';\nimport { validateStep } from '../services/tutorialValidator';\n\nexport interface TutorialStep {\n  id: string;\n  title: string;\n  instructions: string;\n  mentorTip?: string;\n  targetElementId?: string;\n  // A function that takes current state and returns if step is done\n  condition: (state: { diagram: WiringDiagram | null; inventory: ElectronicComponent[] }) => boolean;\n}\n\nexport interface TutorialQuest {\n  id: string;\n  title: string;\n  difficulty: 'beginner' | 'intermediate' | 'expert';\n  steps: TutorialStep[];\n}\n\ninterface TutorialContextType {\n  activeQuest: TutorialQuest | null;\n  currentStepIndex: number;\n  completedSteps: string[];\n  startQuest: (quest: TutorialQuest) => void;\n  nextStep: () => void;\n  completeQuest: () => void;\n  resetTutorial: () => void;\n}\n\nconst TutorialContext = createContext<TutorialContextType | undefined>(undefined);\n\nexport const TutorialProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [activeQuest, setActiveQuest] = useState<TutorialQuest | null>(null);\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [completedSteps, setCompletedSteps] = useState<string[]>([]);\n\n  const { diagram } = useDiagram();\n  const { inventory } = useInventory();\n\n  const startQuest = useCallback((quest: TutorialQuest) => {\n    setActiveQuest(quest);\n    setCurrentStepIndex(0);\n    setCompletedSteps([]);\n  }, []);\n\n  const nextStep = useCallback(() => {\n    if (activeQuest && currentStepIndex < activeQuest.steps.length - 1) {\n      setCompletedSteps(prev => [...prev, activeQuest.steps[currentStepIndex].id]);\n      setCurrentStepIndex(prev => prev + 1);\n    } else if (activeQuest && currentStepIndex === activeQuest.steps.length - 1) {\n      completeQuest();\n    }\n  }, [activeQuest, currentStepIndex]);\n\n  const completeQuest = useCallback(() => {\n    setActiveQuest(null);\n    setCurrentStepIndex(0);\n    setCompletedSteps([]);\n  }, []);\n\n  const resetTutorial = useCallback(() => {\n    setCurrentStepIndex(0);\n    setCompletedSteps([]);\n  }, []);\n\n  // Auto-validation loop\n  useEffect(() => {\n    if (activeQuest) {\n      const currentStep = activeQuest.steps[currentStepIndex];\n      const isDone = validateStep(currentStep, diagram, inventory);\n      \n      if (isDone) {\n        // Use a small delay for better UX\n        const timer = setTimeout(() => {\n          nextStep();\n        }, 800);\n        return () => clearTimeout(timer);\n      }\n    }\n  }, [activeQuest, currentStepIndex, diagram, inventory, nextStep]);\n\n  return (\n    <TutorialContext.Provider value={{\n      activeQuest,\n      currentStepIndex,\n      completedSteps,\n      startQuest,\n      nextStep,\n      completeQuest,\n      resetTutorial\n    }}>\n      {children}\n    </TutorialContext.Provider>\n  );\n};\n\nexport const useTutorial = () => {\n  const context = useContext(TutorialContext);\n  if (context === undefined) {\n    throw new Error('useTutorial must be used within a TutorialProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/UserContext.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'user'. Either include it or remove the dependency array.","line":45,"column":6,"nodeType":"ArrayExpression","endLine":45,"endColumn":31,"suggestions":[{"desc":"Update the dependencies array to be: [user, user.preferences.theme]","fix":{"range":[1517,1542],"text":"[user, user.preferences.theme]"}}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":94,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":94,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { userProfileService, UserProfile } from '../services/userProfileService';\n\ninterface UserContextType {\n  user: UserProfile | null;\n  isLoading: boolean;\n  refreshUser: () => Promise<void>;\n  updatePreferences: (prefs: Partial<UserProfile['preferences']>) => Promise<void>;\n  switchProfile: (id: string) => Promise<void>;\n  updateExpertise: (level: UserProfile['expertise']) => Promise<void>;\n}\n\nconst UserContext = createContext<UserContextType | undefined>(undefined);\n\nexport const UserProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [user, setUser] = useState<UserProfile | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n\n  const refreshUser = async () => {\n    setIsLoading(true);\n    try {\n      const profile = await userProfileService.getActiveProfile();\n      setUser(profile);\n    } catch (error) {\n      console.error('Failed to load user profile:', error);\n      // Fallback handled by service, but if that fails, we might be in trouble.\n      // Ideally show error toast\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    refreshUser();\n  }, []);\n\n  // Sync Theme to DOM\n  useEffect(() => {\n    if (!user) return;\n    \n    // Remove old themes\n    document.body.classList.remove('theme-cyber', 'theme-industrial', 'theme-minimal');\n    // Add new theme\n    document.body.classList.add(`theme-${user.preferences.theme}`);\n  }, [user?.preferences.theme]);\n\n  const updatePreferences = async (prefs: Partial<UserProfile['preferences']>) => {\n    if (!user) return;\n    try {\n      const updated = await userProfileService.updatePreferences(user.id, prefs);\n      setUser(updated);\n      \n      // Apply CSS Variables for theme if needed (can be done in a separate effect or here)\n      // This will be handled by LayoutContext or a global style manager listening to user changes\n    } catch (error) {\n      console.error('Failed to update preferences:', error);\n    }\n  };\n\n  const switchProfile = async (id: string) => {\n    try {\n      userProfileService.switchProfile(id);\n      await refreshUser();\n    } catch (error) {\n      console.error('Failed to switch profile:', error);\n    }\n  };\n\n  const updateExpertise = async (level: UserProfile['expertise']) => {\n    if (!user) return;\n    try {\n      const updated = { ...user, expertise: level };\n      await userProfileService.saveProfile(updated);\n      setUser(updated);\n    } catch (error) {\n      console.error('Failed to update expertise:', error);\n    }\n  };\n\n  return (\n    <UserContext.Provider value={{ \n      user, \n      isLoading, \n      refreshUser, \n      updatePreferences, \n      switchProfile,\n      updateExpertise \n    }}>\n      {children}\n    </UserContext.Provider>\n  );\n};\n\nexport const useUser = () => {\n  const context = useContext(UserContext);\n  if (context === undefined) {\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/VoiceAssistantContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":176,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":176,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, useRef, useCallback, ReactNode } from 'react';\nimport { LiveSession } from '../services/liveAudio';\nimport { transcribeAudio } from '../services/geminiService';\nimport { useToast } from '../hooks/useToast';\n\ninterface VoiceAssistantContextType {\n  isRecording: boolean;\n  startRecording: () => Promise<void>;\n  stopRecording: () => void;\n  isProcessingAudio: boolean;\n  loadingText: string; // \"Transcribing...\", \"Thinking...\"\n  \n  isLiveActive: boolean;\n  liveStatus: string;\n  toggleLiveMode: () => Promise<void>;\n  \n  registerVisualContextProvider: (id: string, provider: () => Promise<Blob | null>) => void;\n  unregisterVisualContextProvider: (id: string) => void;\n  \n  // Event for when a transcription is ready\n  lastTranscription: string | null;\n  clearTranscription: () => void;\n}\n\nconst VoiceAssistantContext = createContext<VoiceAssistantContextType | undefined>(undefined);\n\nexport const VoiceAssistantProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const toast = useToast();\n  \n  // Recording State\n  const [isRecording, setIsRecording] = useState(false);\n  const [isProcessingAudio, setIsProcessingAudio] = useState(false);\n  const [loadingText, setLoadingText] = useState('');\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n  const [lastTranscription, setLastTranscription] = useState<string | null>(null);\n\n  // Live Mode State\n  const [isLiveActive, setIsLiveActive] = useState(false);\n  const [liveStatus, setLiveStatus] = useState('disconnected');\n  const liveSessionRef = useRef<LiveSession | null>(null);\n  \n  // Visual Context\n  const visualContextProvidersRef = useRef<Map<string, () => Promise<Blob | null>>>(new Map());\n\n  const registerVisualContextProvider = useCallback((id: string, provider: () => Promise<Blob | null>) => {\n    visualContextProvidersRef.current.set(id, provider);\n    // Update live session if active\n    if (liveSessionRef.current) {\n      liveSessionRef.current.setVisualContextProviders(Array.from(visualContextProvidersRef.current.values()));\n    }\n  }, []);\n\n  const unregisterVisualContextProvider = useCallback((id: string) => {\n    visualContextProvidersRef.current.delete(id);\n    // Update live session if active\n    if (liveSessionRef.current) {\n      liveSessionRef.current.setVisualContextProviders(Array.from(visualContextProvidersRef.current.values()));\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (mediaRecorderRef.current) {\n        if (mediaRecorderRef.current.state === 'recording') {\n          mediaRecorderRef.current.stop();\n        }\n        mediaRecorderRef.current.stream?.getTracks().forEach((track) => track.stop());\n      }\n      if (liveSessionRef.current) {\n        liveSessionRef.current.disconnect();\n      }\n    };\n  }, []);\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (err: unknown) {\n      const message = err instanceof Error ? err.message : 'Unknown error';\n      console.error(message);\n      toast.error('Could not access microphone.');\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.onstop = async () => {\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });\n        setIsRecording(false);\n        setLoadingText('Transcribing...');\n        setIsProcessingAudio(true);\n\n        try {\n          const reader = new FileReader();\n          reader.readAsDataURL(audioBlob);\n          reader.onloadend = async () => {\n            const base64Audio = reader.result as string;\n            const transcription = await transcribeAudio(base64Audio);\n            setIsProcessingAudio(false);\n            setLoadingText('');\n            \n            if (transcription && transcription.trim()) {\n              setLastTranscription(transcription.trim());\n            } else {\n              toast.warning('No speech detected.');\n            }\n          };\n        } catch (_e: unknown) {\n          toast.error('Transcription failed.');\n          setIsProcessingAudio(false);\n          setLoadingText('');\n        }\n        mediaRecorderRef.current?.stream.getTracks().forEach((track) => track.stop());\n      };\n      mediaRecorderRef.current.stop();\n    }\n  };\n\n  const toggleLiveMode = async () => {\n    if (isLiveActive) {\n      liveSessionRef.current?.disconnect();\n      setIsLiveActive(false);\n    } else {\n      setIsLiveActive(true);\n      liveSessionRef.current = new LiveSession((status) => {\n        setLiveStatus(status);\n        if (status === 'disconnected' || status === 'error') {\n          setIsLiveActive(false);\n        }\n      });\n\n      if (visualContextProvidersRef.current.size > 0) {\n        liveSessionRef.current.setVisualContextProviders(Array.from(visualContextProvidersRef.current.values()));\n      }\n\n      await liveSessionRef.current.connect();\n    }\n  };\n  \n  const clearTranscription = () => setLastTranscription(null);\n\n  return (\n    <VoiceAssistantContext.Provider value={{\n      isRecording,\n      startRecording,\n      stopRecording,\n      isProcessingAudio,\n      loadingText,\n      isLiveActive,\n      liveStatus,\n      toggleLiveMode,\n      registerVisualContextProvider,\n      unregisterVisualContextProvider,\n      lastTranscription,\n      clearTranscription\n    }}>\n      {children}\n    </VoiceAssistantContext.Provider>\n  );\n};\n\nexport const useVoiceAssistant = () => {\n  const context = useContext(VoiceAssistantContext);\n  if (context === undefined) {\n    throw new Error('useVoiceAssistant must be used within a VoiceAssistantProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/data/initialInventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/data/tutorials/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/__tests__/useConversations.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/appControlHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/canvasHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/diagramHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateDiagram' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":148,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ActionContext, HandlerResult } from './types';\nimport { ElectronicComponent, ActionRecord } from '../../types';\n\nconst generateId = () => `action-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\ninterface AddComponentPayload {\n  component: ElectronicComponent;\n  x?: number;\n  y?: number;\n}\n\ninterface RemoveComponentPayload {\n  componentId: string;\n}\n\ninterface CreateConnectionPayload {\n  fromComponentId: string;\n  fromPin: string;\n  toComponentId: string;\n  toPin: string;\n  color?: string;\n  description?: string;\n}\n\ninterface RemoveConnectionPayload {\n  wireIndex: number;\n}\n\nexport async function addComponent(\n  payload: AddComponentPayload,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { component, x, y } = payload;\n  const { diagram, updateDiagram, canvasRef, activeConversationId, recordUndo } = context;\n\n  if (!diagram) {\n    return { success: false, error: 'No active diagram' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'addComponent',\n    payload: { componentId: component.id },\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  // Deep clone to ensure isolation from inventory\n  const newComponent = JSON.parse(JSON.stringify({\n    ...component,\n    id: `${component.id}-${Date.now()}`,\n    sourceInventoryId: component.id\n  }));\n\n  updateDiagram({\n    ...diagram,\n    components: [...diagram.components, newComponent],\n  });\n\n  if (x !== undefined && y !== undefined) {\n    canvasRef.current?.setComponentPosition(newComponent.id, x, y);\n  }\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n\nexport async function removeComponent(\n  payload: RemoveComponentPayload,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { componentId } = payload;\n  const { diagram, updateDiagram, activeConversationId, recordUndo } = context;\n\n  if (!diagram) {\n    return { success: false, error: 'No active diagram' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'removeComponent',\n    payload: { componentId },\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  updateDiagram({\n    ...diagram,\n    components: diagram.components.filter((c) => c.id !== componentId),\n    connections: diagram.connections.filter(\n      (conn) => conn.fromComponentId !== componentId && conn.toComponentId !== componentId\n    ),\n  });\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n\nexport async function createConnection(\n  payload: CreateConnectionPayload,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { fromComponentId, fromPin, toComponentId, toPin, color, description } = payload;\n  const { diagram, updateDiagram, activeConversationId, recordUndo } = context;\n\n  if (!diagram) {\n    return { success: false, error: 'No active diagram' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'createConnection',\n    payload: { fromComponentId, fromPin, toComponentId, toPin },\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  updateDiagram({\n    ...diagram,\n    connections: [\n      ...diagram.connections,\n      {\n        fromComponentId,\n        fromPin,\n        toComponentId,\n        toPin,\n        color: color || '#00f3ff',\n        description: description || 'Connection',\n      },\n    ],\n  });\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n\nexport async function removeConnection(\n  payload: RemoveConnectionPayload,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { wireIndex } = payload;\n  const { diagram, updateDiagram, activeConversationId, recordUndo } = context;\n\n  if (!diagram || wireIndex < 0 || wireIndex >= diagram.connections.length) {\n    return { success: false, error: 'Invalid wire index' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'removeConnection',\n    payload: { wireIndex, connection: diagram.connections[wireIndex] },\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n\nexport async function clearCanvas(\n  _payload: Record<string, unknown>,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { diagram, updateDiagram, activeConversationId, recordUndo } = context;\n\n  if (!diagram) {\n    return { success: false, error: 'No active diagram' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'clearCanvas',\n    payload: {},\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  updateDiagram({\n    ...diagram,\n    components: [],\n    connections: [],\n  });\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/navHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useAIActions.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'addRecordedStep', 'isRecording', 'perms.canEditInventory', and 'perms.canModifyDiagram'. Either include them or remove the dependency array.","line":112,"column":6,"nodeType":"ArrayExpression","endLine":117,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [canvasRef, inventory, diagram, setInventory, setInventoryOpen, setSettingsOpen, setSelectedComponent, setGenerationMode, updateDiagram, activeConversationId, recordUndo, handleUndo, handleRedo, saveDiagram, loadDiagram, addToHistory, perms.canModifyDiagram, perms.canEditInventory, isRecording, pushActionDelta, addRecordedStep]","fix":{"range":[4955,5226],"text":"[canvasRef, inventory, diagram, setInventory, setInventoryOpen, setSettingsOpen, setSelectedComponent, setGenerationMode, updateDiagram, activeConversationId, recordUndo, handleUndo, handleRedo, saveDiagram, loadDiagram, addToHistory, perms.canModifyDiagram, perms.canEditInventory, isRecording, pushActionDelta, addRecordedStep]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'stagedActions'. Either exclude it or remove the dependency array.","line":130,"column":6,"nodeType":"ArrayExpression","endLine":130,"endColumn":21,"suggestions":[{"desc":"Update the dependencies array to be: []","fix":{"range":[5715,5730],"text":"[]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useState, useMemo } from 'react';\nimport { ActionIntent, ElectronicComponent } from '../types';\nimport { DiagramCanvasRef, HighlightOptions } from '../components/DiagramCanvas';\nimport { getHandler, ActionContext } from './actions';\nimport { useAutonomySettings } from './useAutonomySettings';\nimport { useActionHistory, ActionResult } from './useActionHistory';\nimport { useInventory } from '../contexts/InventoryContext';\nimport { useDiagram } from '../contexts/DiagramContext';\nimport { useLayout } from '../contexts/LayoutContext';\nimport { useAssistantState } from '../contexts/AssistantStateContext';\nimport { useConversationContext } from '../contexts/ConversationContext';\nimport { useMacros } from '../contexts/MacroContext';\nimport { engineeringMetricsService } from '../services/aiMetricsService';\nimport { usePermissions } from './usePermissions';\nimport { auditService } from '../services/logging/auditService';\nimport { PredictiveAction } from '../services/predictionEngine';\n\nexport type { ActionResult } from './useActionHistory';\n\nexport interface UseAIActionsOptions {\n  canvasRef: React.RefObject<DiagramCanvasRef | null>; // Updated type to match nullable ref\n  setSelectedComponent: (component: ElectronicComponent | null) => void;\n}\n\nexport function useAIActions(options: UseAIActionsOptions) {\n  const { canvasRef, setSelectedComponent } = options;\n\n  // Contexts\n  const { inventory, setInventory } = useInventory();\n  const { diagram, updateDiagram, undo: handleUndo, redo: handleRedo, saveToQuickSlot: saveDiagram, loadFromQuickSlot: loadDiagram } = useDiagram();\n  const { setInventoryOpen, setSettingsOpen } = useLayout();\n  const { setGenerationMode, pushActionDelta } = useAssistantState();\n  const { activeConversationId } = useConversationContext();\n\n  const [pendingActions, setPendingActions] = useState<ActionIntent[]>([]);\n  const [stagedActions, setStagedActions] = useState<PredictiveAction[]>([]);\n  const { autonomySettings, updateAutonomySettings, isActionSafe } = useAutonomySettings();\n  const { actionHistory, addToHistory, recordUndo, undo, canUndo } = useActionHistory(updateDiagram);\n  const { isRecording, addRecordedStep } = useMacros();\n  const perms = usePermissions();\n\n  // Execute action via handler registry\n  const executeAction = useCallback(async (action: ActionIntent, auto: boolean): Promise<ActionResult> => {\n    // 0. Permission Check\n    if (action.type === 'addComponent' || action.type === 'removeComponent' || action.type === 'clearCanvas') {\n      if (!perms.canModifyDiagram) {\n        return { action, success: false, timestamp: Date.now(), auto, error: 'Access Denied: Insufficient Permissions' };\n      }\n    }\n    if (action.type === 'openInventory') {\n      if (!perms.canEditInventory) {\n        // Observers can see inventory but maybe not edit? \n        // For now let's be strict if we want to guard the tab\n      }\n    }\n\n    // ...\n    // context building omitted for brevity in replace\n    const context: ActionContext = {\n      canvasRef: canvasRef as React.RefObject<DiagramCanvasRef>, // Cast for compatibility with handler types\n      inventory, diagram, setInventory,\n      setIsInventoryOpen: setInventoryOpen,\n      setIsSettingsOpen: setSettingsOpen,\n      setSelectedComponent,\n      setGenerationMode, updateDiagram, activeConversationId,\n      recordUndo,\n      // App Controls\n      handleUndo, handleRedo, saveDiagram, loadDiagram\n    };\n\n    const result: ActionResult = {\n      action,\n      success: false,\n      timestamp: Date.now(),\n      auto,\n    }\n\n    try {\n      const handler = getHandler(action.type);\n      if (!handler) {\n        result.error = `Unknown action type: ${action.type}`;\n        auditService.log('error', 'action-handler', `Unknown action type: ${action.type}`);\n      } else {\n        const handlerResult = await handler(action.payload, context);\n        result.success = handlerResult.success;\n        result.error = handlerResult.error;\n        \n        if (!result.success) {\n          auditService.log('warn', 'action-handler', `Action failed: ${action.type}`, { error: result.error });\n        }\n      }\n    } catch (err) {\n      result.error = err instanceof Error ? err.message : 'Unknown error';\n      auditService.log('error', 'action-handler', `Action crashed: ${action.type}`, { error: result.error });\n    }\n\n    if (result.success) {\n      auditService.log('info', 'action-handler', `Action executed: ${action.type}`, { label: action.label, auto });\n      engineeringMetricsService.logEvent('action_execute', { type: action.type, label: action.label });\n      if (isRecording) {\n        addRecordedStep(action);\n      }\n      pushActionDelta({\n        type: action.type,\n        targetId: (action.payload['componentId'] || action.payload['nodeId'] || action.payload['id']) as string | undefined,\n        description: action.label\n      });\n    }\n\n    addToHistory(result);\n    return result;\n  }, [\n    canvasRef, inventory, diagram, setInventory,\n    setInventoryOpen, setSettingsOpen, setSelectedComponent,\n    setGenerationMode, updateDiagram, activeConversationId,\n    recordUndo, addToHistory, handleUndo, handleRedo, saveDiagram, loadDiagram, pushActionDelta\n  ]);\n\n  // Staged Actions (Predictions)\n  const acceptStagedAction = useCallback(async (id: string) => {\n    const prediction = stagedActions.find((a) => a.id === id);\n    if (prediction) {\n      setStagedActions((prev) => prev.filter((a) => a.id !== id));\n      return await executeAction(prediction.action, false);\n    }\n  }, [stagedActions, executeAction]);\n\n  const rejectStagedAction = useCallback((id: string) => {\n    setStagedActions((prev) => prev.filter((a) => a.id !== id));\n  }, [stagedActions]);\n\n  const clearStagedActions = useCallback(() => setStagedActions([]), []);\n  const stageActions = useCallback((actions: PredictiveAction[]) => setStagedActions(actions), []);\n\n  // Main execute - checks autonomy settings\n  const execute = useCallback(async (action: ActionIntent): Promise<ActionResult> => {\n    const safe = action.safe ?? isActionSafe(action.type);\n\n    if (safe && autonomySettings.autoExecuteSafeActions) {\n      return executeAction(action, true);\n    } else {\n      setPendingActions((prev) => [...prev, action]);\n      return {\n        action,\n        success: false,\n        timestamp: Date.now(),\n        auto: false,\n        error: 'Awaiting user confirmation',\n      };\n    }\n  }, [autonomySettings, isActionSafe, executeAction]);\n\n  const confirmAction = useCallback(async (action: ActionIntent): Promise<ActionResult> => {\n    setPendingActions((prev) => prev.filter((a) => a !== action));\n    return executeAction(action, false);\n  }, [executeAction]);\n\n  const rejectAction = useCallback((action: ActionIntent) => {\n    setPendingActions((prev) => prev.filter((a) => a !== action));\n  }, []);\n\n  const clearPendingActions = useCallback(() => setPendingActions([]), []);\n\n  // Convenience shortcuts (direct canvas calls)\n  const highlightComponent = useCallback((id: string, opts?: HighlightOptions) => {\n    canvasRef.current?.highlightComponent(id, opts);\n  }, [canvasRef]);\n\n  const centerOnComponent = useCallback((id: string) => {\n    canvasRef.current?.centerOnComponent(id);\n  }, [canvasRef]);\n\n  const zoomTo = useCallback((level: number) => {\n    canvasRef.current?.setZoom(level);\n  }, [canvasRef]);\n\n  const resetView = useCallback(() => {\n    canvasRef.current?.resetView();\n  }, [canvasRef]);\n\n  const openInventory = useCallback(() => setInventoryOpen(true), [setInventoryOpen]);\n  const closeInventory = useCallback(() => setInventoryOpen(false), [setInventoryOpen]);\n  const openSettings = useCallback(() => setSettingsOpen(true), [setSettingsOpen]);\n  const closeSettings = useCallback(() => setSettingsOpen(false), [setSettingsOpen]);\n\n  const openComponentEditor = useCallback((componentId: string) => {\n    const component = inventory.find((c) => c.id === componentId);\n    if (component) setSelectedComponent(component);\n  }, [inventory, setSelectedComponent]);\n\n  const switchGenerationMode = useCallback((mode: 'chat' | 'image' | 'video') => {\n    setGenerationMode(mode);\n  }, [setGenerationMode]);\n\n  return useMemo(() => ({\n    execute,\n    pendingActions,\n    confirmAction,\n    rejectAction,\n    clearPendingActions,\n    stagedActions,\n    acceptStagedAction,\n    rejectStagedAction,\n    clearStagedActions,\n    stageActions,\n    canUndo,\n    undo,\n    actionHistory,\n    highlightComponent,\n    centerOnComponent,\n    zoomTo,\n    resetView,\n    openInventory,\n    closeInventory,\n    openSettings,\n    closeSettings,\n    openComponentEditor,\n    switchGenerationMode,\n    autonomySettings,\n    updateAutonomySettings,\n  }), [\n    execute,\n    pendingActions,\n    confirmAction,\n    rejectAction,\n    clearPendingActions,\n    stagedActions,\n    acceptStagedAction,\n    rejectStagedAction,\n    clearStagedActions,\n    stageActions,\n    canUndo,\n    undo,\n    actionHistory,\n    highlightComponent,\n    centerOnComponent,\n    zoomTo,\n    resetView,\n    openInventory,\n    closeInventory,\n    openSettings,\n    closeSettings,\n    openComponentEditor,\n    switchGenerationMode,\n    autonomySettings,\n    updateAutonomySettings,\n  ]);\n}\n\n// Re-export for backwards compatibility\nexport { saveAutonomySettings } from './useAutonomySettings';","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useActionHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useAutonomySettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useClickOutside.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useConnectivity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useConversations.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5230,5233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5230,5233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'react';\nimport { Conversation, EnhancedChatMessage, WiringDiagram, GroundingSource } from '../types';\nimport {\n  saveConversation,\n  listConversations,\n  deleteConversation as deleteConversationFromDB,\n  getPrimaryConversation,\n  saveMessage,\n  loadMessages,\n} from '../services/storage';\n\n// Generate a unique ID\nconst generateId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n// Generate title from first message\nconst generateTitle = (content: string): string => {\n  const cleaned = content.replace(/\\n/g, ' ').trim();\n  if (cleaned.length <= 50) return cleaned;\n  return cleaned.substring(0, 47) + '...';\n};\n\nconst WELCOME_MESSAGE = 'System Online. I am CircuitMind AI.\\n\\nI can generate wiring diagrams, create concept art, analyze your circuit photos/videos, or answer complex questions.';\n\nexport interface UseConversationsReturn {\n  // State\n  conversations: Conversation[];\n  activeConversationId: string | null;\n  activeConversation: Conversation | null;\n  messages: EnhancedChatMessage[];\n  isLoading: boolean;\n\n  // Conversation CRUD\n  createConversation: (isPrimary?: boolean) => Promise<string>;\n  switchConversation: (id: string) => Promise<void>;\n  deleteConversation: (id: string) => Promise<void>;\n  renameConversation: (id: string, title: string) => Promise<void>;\n\n  // Message operations\n  addMessage: (\n    message: Omit<EnhancedChatMessage, 'id' | 'conversationId' | 'timestamp'>\n  ) => Promise<EnhancedChatMessage>;\n  updateMessage: (id: string, updates: Partial<EnhancedChatMessage>) => Promise<void>;\n\n  // Utility\n  getOrCreatePrimaryConversation: () => Promise<string>;\n  refreshConversations: () => Promise<void>;\n}\n\nexport function useConversations(): UseConversationsReturn {\n  const [conversations, setConversations] = useState<Conversation[]>([]);\n  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);\n  const [messages, setMessages] = useState<EnhancedChatMessage[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Track if we've initialized\n  const initialized = useRef(false);\n\n  // Get active conversation object\n  const activeConversation = conversations.find((c) => c.id === activeConversationId) || null;\n\n  // Load conversations on mount\n  useEffect(() => {\n    if (initialized.current) return;\n    initialized.current = true;\n\n    const init = async () => {\n      setIsLoading(true);\n      try {\n        // Load all conversations (most recent first)\n        const convs = await listConversations(50);\n        setConversations(convs);\n\n        // Try to find or create primary conversation\n        let primary = await getPrimaryConversation();\n        if (!primary && convs.length === 0) {\n          // Create first primary conversation\n          const id = generateId();\n          primary = {\n            id,\n            title: 'CircuitMind Session',\n            createdAt: Date.now(),\n            updatedAt: Date.now(),\n            messageCount: 0,\n            isPrimary: true,\n          };\n          await saveConversation(primary);\n          setConversations([primary]);\n        }\n\n        // Activate primary or most recent\n        const toActivate = primary || convs[0];\n        if (toActivate) {\n          setActiveConversationId(toActivate.id);\n          const msgs = await loadMessages(toActivate.id);\n          if (msgs.length === 0 && toActivate.isPrimary) {\n            const welcomeMessage: EnhancedChatMessage = {\n              id: generateId(),\n              conversationId: toActivate.id,\n              role: 'model',\n              content: WELCOME_MESSAGE,\n              timestamp: Date.now(),\n              linkedComponents: [],\n              suggestedActions: [],\n            };\n            await saveMessage(welcomeMessage);\n            setMessages([welcomeMessage]);\n\n            const updatedConversation: Conversation = {\n              ...toActivate,\n              messageCount: 1,\n              updatedAt: Date.now(),\n              lastMessagePreview: welcomeMessage.content.substring(0, 100),\n            };\n            await saveConversation(updatedConversation);\n            setConversations((prev) =>\n              prev.map((c) => (c.id === updatedConversation.id ? updatedConversation : c))\n            );\n          } else {\n            setMessages(msgs);\n          }\n        }\n      } catch (e) {\n        console.error('Failed to initialize conversations:', e);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    init();\n  }, []);\n\n  const createConversationInternal = useCallback(async (\n    isPrimary: boolean,\n    title?: string\n  ): Promise<Conversation> => {\n    const id = generateId();\n    const conversation: Conversation = {\n      id,\n      title: title || (isPrimary ? 'CircuitMind Session' : 'New Conversation'),\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      messageCount: 0,\n      isPrimary,\n    };\n\n    await saveConversation(conversation);\n    setConversations((prev) => [conversation, ...prev]);\n    setActiveConversationId(id);\n    setMessages([]);\n\n    return conversation;\n  }, []);\n\n  // Create a new conversation\n  const createConversation = useCallback(async (isPrimaryArg: any = false): Promise<string> => {\n    // If called as an event handler, the first arg is an event object.\n    // We want to ensure it's a strict boolean.\n    const isPrimary = typeof isPrimaryArg === 'boolean' ? isPrimaryArg : false;\n    const conversation = await createConversationInternal(isPrimary);\n    return conversation.id;\n  }, [createConversationInternal]);\n\n  // Switch to a different conversation\n  const switchConversation = useCallback(async (id: string): Promise<void> => {\n    if (id === activeConversationId) return;\n\n    setIsLoading(true);\n    try {\n      const msgs = await loadMessages(id);\n      setMessages(msgs);\n      setActiveConversationId(id);\n    } catch (e) {\n      console.error('Failed to switch conversation:', e);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [activeConversationId]);\n\n  // Delete a conversation\n  const deleteConversation = useCallback(async (id: string): Promise<void> => {\n    await deleteConversationFromDB(id);\n    setConversations((prev) => prev.filter((c) => c.id !== id));\n\n    // If we deleted the active conversation, switch to another\n    if (id === activeConversationId) {\n      const remaining = conversations.filter((c) => c.id !== id);\n      if (remaining.length > 0) {\n        await switchConversation(remaining[0].id);\n      } else {\n        // Create new primary\n        await createConversation(true);\n      }\n    }\n  }, [activeConversationId, conversations, switchConversation, createConversation]);\n\n  // Rename a conversation\n  const renameConversation = useCallback(async (id: string, title: string): Promise<void> => {\n    const conv = conversations.find((c) => c.id === id);\n    if (!conv) return;\n\n    const updated: Conversation = {\n      ...conv,\n      title,\n      updatedAt: Date.now(),\n    };\n\n    await saveConversation(updated);\n    setConversations((prev) => prev.map((c) => (c.id === id ? updated : c)));\n  }, [conversations]);\n\n  // Add a message to the active conversation\n  const addMessage = useCallback(\n    async (\n      messageData: Omit<EnhancedChatMessage, 'id' | 'conversationId' | 'timestamp'>\n    ): Promise<EnhancedChatMessage> => {\n      const createdConversation = !activeConversationId\n        ? await createConversationInternal(true, 'CircuitMind Session')\n        : null;\n\n      const conversationId = activeConversationId || createdConversation?.id;\n      if (!conversationId) {\n        throw new Error('No active conversation available');\n      }\n\n      const message: EnhancedChatMessage = {\n        ...messageData,\n        id: generateId(),\n        conversationId,\n        timestamp: Date.now(),\n        linkedComponents: messageData.linkedComponents || [],\n        suggestedActions: messageData.suggestedActions || [],\n      };\n\n      await saveMessage(message);\n\n      setMessages((prev) => {\n        if (activeConversationId && conversationId !== activeConversationId) {\n          return prev;\n        }\n        return [...prev, message];\n      });\n\n      const conv = conversations.find((c) => c.id === conversationId) || createdConversation;\n      if (conv) {\n        const isFirstMessage = conv.messageCount === 0 && messageData.role === 'user';\n        const updated: Conversation = {\n          ...conv,\n          messageCount: conv.messageCount + 1,\n          updatedAt: Date.now(),\n          lastMessagePreview: messageData.content.substring(0, 100),\n          title: isFirstMessage ? generateTitle(messageData.content) : conv.title,\n        };\n        await saveConversation(updated);\n        setConversations((prev) =>\n          prev.map((c) => (c.id === conversationId ? updated : c))\n        );\n      }\n\n      return message;\n    },\n    [activeConversationId, conversations, createConversationInternal]\n  );\n\n  // Update an existing message\n  const updateMessage = useCallback(\n    async (id: string, updates: Partial<EnhancedChatMessage>): Promise<void> => {\n      const message = messages.find((m) => m.id === id);\n      if (!message) return;\n\n      const updated: EnhancedChatMessage = {\n        ...message,\n        ...updates,\n      };\n\n      await saveMessage(updated);\n      setMessages((prev) => prev.map((m) => (m.id === id ? updated : m)));\n    },\n    [messages]\n  );\n\n  // Get or create primary conversation\n  const getOrCreatePrimaryConversation = useCallback(async (): Promise<string> => {\n    const primary = await getPrimaryConversation();\n    if (primary) {\n      return primary.id;\n    }\n    return createConversation(true);\n  }, [createConversation]);\n\n  // Refresh conversations list\n  const refreshConversations = useCallback(async (): Promise<void> => {\n    const convs = await listConversations(50);\n    setConversations(convs);\n  }, []);\n\n  return {\n    // State\n    conversations,\n    activeConversationId,\n    activeConversation,\n    messages,\n    isLoading,\n\n    // Conversation CRUD\n    createConversation,\n    switchConversation,\n    deleteConversation,\n    renameConversation,\n\n    // Message operations\n    addMessage,\n    updateMessage,\n\n    // Utility\n    getOrCreatePrimaryConversation,\n    refreshConversations,\n  };\n}\n\n// Helper to convert old ChatMessage to EnhancedChatMessage\nexport function migrateMessage(\n  old: {\n    id: string;\n    role: 'user' | 'model' | 'system';\n    content: string;\n    timestamp?: number;\n    diagramData?: WiringDiagram;\n    image?: string;\n    video?: string;\n    groundingSources?: GroundingSource[];\n    audioResponse?: string;\n  },\n  conversationId: string\n): EnhancedChatMessage {\n  return {\n    id: old.id,\n    conversationId,\n    role: old.role,\n    content: old.content,\n    timestamp: old.timestamp || Date.now(),\n    diagramData: old.diagramData,\n    image: old.image,\n    video: old.video,\n    groundingSources: old.groundingSources,\n    audioResponse: old.audioResponse,\n    linkedComponents: [],\n    suggestedActions: [],\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useHoverBehavior.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useInventorySync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useNeuralLink.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3169,3172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3169,3172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef, useCallback } from 'react';\nimport { gestureEngine, GestureResult } from '../services/gesture/GestureEngine';\nimport { useLayout } from '../contexts/LayoutContext';\n\nexport function useNeuralLink() {\n  const { lowPerformanceMode } = useLayout();\n  const [isActive, setIsActive] = useState(false);\n  const [isInitializing, setIsInitializing] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [result, setResult] = useState<GestureResult | null>(null);\n  \n  const videoRef = useRef<HTMLVideoElement | null>(null);\n  const rafRef = useRef<number | null>(null);\n  \n  // Use refs to avoid startTracking identity changes and infinite loops\n  const isActiveRef = useRef(false);\n  const isInitializingRef = useRef(false);\n\n  const stopTracking = useCallback(() => {\n    if (rafRef.current) cancelAnimationFrame(rafRef.current);\n    if (videoRef.current?.srcObject) {\n      (videoRef.current.srcObject as MediaStream).getTracks().forEach(t => t.stop());\n    }\n    setIsActive(false);\n    isActiveRef.current = false;\n    setIsInitializing(false);\n    isInitializingRef.current = false;\n  }, []);\n\n  const startTracking = useCallback(async () => {\n    if (isActiveRef.current || isInitializingRef.current) return;\n    \n    console.log('Neural Link: Initializing engine...');\n    setIsInitializing(true);\n    isInitializingRef.current = true;\n    try {\n      setError(null);\n      await gestureEngine.init();\n      console.log('Neural Link: Engine initialized. Requesting camera...');\n\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('Camera API not supported in this browser/context');\n      }\n\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          width: { ideal: 640 },\n          height: { ideal: 480 },\n          frameRate: { ideal: 30 }\n        },\n        audio: false\n      });\n\n      console.log('Neural Link: Camera stream obtained.');\n\n      if (!videoRef.current) {\n        videoRef.current = document.createElement('video');\n        videoRef.current.setAttribute('playsinline', '');\n      }\n      videoRef.current.srcObject = stream;\n      \n      await new Promise((resolve) => {\n        if (!videoRef.current) return resolve(null);\n        videoRef.current.onloadedmetadata = () => resolve(null);\n      });\n\n      await videoRef.current.play();\n      console.log('Neural Link: Video playing. Starting tracking loop...');\n\n      setIsActive(true);\n      isActiveRef.current = true;\n      setIsInitializing(false);\n      isInitializingRef.current = false;\n\n      const tick = async () => {\n        if (!videoRef.current || videoRef.current.paused) return;\n        \n        try {\n          await gestureEngine.processFrame(videoRef.current);\n        } catch (err) {\n          console.warn('Neural Link tracking tick failed:', err);\n        }\n\n        if (lowPerformanceMode) {\n          setTimeout(() => {\n            rafRef.current = requestAnimationFrame(tick);\n          }, 100);\n        } else {\n          rafRef.current = requestAnimationFrame(tick);\n        }\n      };\n\n      tick();\n    } catch (e: any) {\n      console.error('Neural Link: Failed to start:', e);\n      setError(e.message || 'Camera access denied');\n      setIsActive(false);\n      isActiveRef.current = false;\n      setIsInitializing(false);\n      isInitializingRef.current = false;\n    }\n  }, [lowPerformanceMode]);\n\n  useEffect(() => {\n    const unsub = gestureEngine.onLandmarks((res) => {\n      setResult(res);\n    });\n    return () => {\n      unsub();\n      stopTracking();\n    };\n  }, [stopTracking]);\n\n  const getSnapshotBlob = useCallback(async (): Promise<Blob | null> => {\n    if (!videoRef.current || videoRef.current.paused) return null;\n    const canvas = document.createElement('canvas');\n    canvas.width = videoRef.current.videoWidth;\n    canvas.height = videoRef.current.videoHeight;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return null;\n    ctx.drawImage(videoRef.current, 0, 0);\n    return new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.7));\n  }, []);\n\n  return {\n    isActive,\n    isInitializing,\n    startTracking,\n    stopTracking,\n    error,\n    result,\n    getSnapshotBlob,\n    // Engagement check: Hand landmarks must be present\n    isEngaged: result && result.landmarks.length > 0\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/usePermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useResizeHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useToast.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":104,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":104,"endColumn":28},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":115,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":115,"endColumn":26},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":124,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":124,"endColumn":25},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":227,"column":16,"nodeType":"Identifier","messageId":"namedExport","endLine":227,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Toast Notification System\n *\n * Lightweight toast notifications replacing browser alert() calls.\n * Matches the app's dark theme aesthetic.\n */\n\nimport React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\n\n// ============================================\n// Types\n// ============================================\n\nexport type ToastType = 'success' | 'error' | 'warning' | 'info';\n\nexport interface ToastAction {\n  label: string;\n  onClick: () => void;\n}\n\nexport interface Toast {\n  id: string;\n  type: ToastType;\n  message: string;\n  duration?: number;\n  action?: ToastAction;\n}\n\n// ============================================\n// Contexts\n// ============================================\n\nconst ToastStateContext = createContext<Toast[]>([]);\nconst ToastApiContext = createContext<{\n  addToast: (type: ToastType, message: string, duration?: number, action?: ToastAction, id?: string) => string;\n  removeToast: (id: string) => void;\n  success: (message: string, duration?: number, action?: ToastAction, id?: string) => string;\n  error: (message: string, duration?: number, action?: ToastAction, id?: string) => string;\n  warning: (message: string, duration?: number, action?: ToastAction, id?: string) => string;\n  info: (message: string, duration?: number, action?: ToastAction, id?: string) => string;\n} | null>(null);\n\n// ============================================\n// Provider\n// ============================================\n\ninterface ToastProviderProps {\n  children: ReactNode;\n}\n\nexport function ToastProvider({ children }: ToastProviderProps) {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n\n  const removeToast = useCallback((id: string) => {\n    setToasts(prev => prev.filter(t => t.id !== id));\n  }, []);\n\n  const addToast = useCallback(\n    (type: ToastType, message: string, duration = 4000, action?: ToastAction, manualId?: string) => {\n      const id = manualId || `toast-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n      const toast: Toast = { id, type, message, duration, action };\n\n      setToasts(prev => {\n        if (prev.some(t => t.id === id)) return prev;\n        return [...prev, toast];\n      });\n\n      if (duration > 0) {\n        setTimeout(() => removeToast(id), duration);\n      }\n\n      return id;\n    },\n    [removeToast]\n  );\n\n  const success = useCallback((msg: string, dur?: number, act?: ToastAction, id?: string) => addToast('success', msg, dur, act, id), [addToast]);\n  const error = useCallback((msg: string, dur?: number, act?: ToastAction, id?: string) => addToast('error', msg, dur ?? 6000, act, id), [addToast]);\n  const warning = useCallback((msg: string, dur?: number, act?: ToastAction, id?: string) => addToast('warning', msg, dur ?? 5000, act, id), [addToast]);\n  const info = useCallback((msg: string, dur?: number, act?: ToastAction, id?: string) => addToast('info', msg, dur, act, id), [addToast]);\n\n  const api = React.useMemo(() => ({\n    addToast, removeToast, success, error, warning, info\n  }), [addToast, removeToast, success, error, warning, info]);\n\n  return (\n    <ToastStateContext.Provider value={toasts}>\n      <ToastApiContext.Provider value={api}>\n        {children}\n        <ToastContainer toasts={toasts} onDismiss={removeToast} />\n      </ToastApiContext.Provider>\n    </ToastStateContext.Provider>\n  );\n}\n\n// ============================================\n// Hooks\n// ============================================\n\n/**\n * Hook for components that only need to trigger toasts.\n * Returns a stable API that won't trigger re-renders when toasts change.\n */\nexport function useToastApi() {\n  const api = useContext(ToastApiContext);\n  if (!api) {\n    throw new Error('useToastApi must be used within a ToastProvider');\n  }\n  return api;\n}\n\n/**\n * Hook for components that need to display the list of toasts.\n */\nexport function useToasts() {\n  return useContext(ToastStateContext);\n}\n\n/**\n * Legacy hook for backward compatibility. \n * NOTE: Using this in useEffect dependencies will cause infinite loops \n * if any toast is added/removed. Use useToastApi() instead.\n */\nexport function useToast() {\n  const toasts = useToasts();\n  const api = useToastApi();\n  \n  return React.useMemo(() => ({\n    toasts,\n    ...api\n  }), [toasts, api]);\n}\n\n// ============================================\n// Toast Container Component\n// ============================================\n\ninterface ToastContainerProps {\n  toasts: Toast[];\n  onDismiss: (id: string) => void;\n}\n\nfunction ToastContainer({ toasts, onDismiss }: ToastContainerProps) {\n  if (toasts.length === 0) return null;\n\n  return (\n    <div className=\"fixed bottom-4 right-4 z-[100] flex flex-col gap-2 max-w-sm\">\n      {toasts.map(toast => (\n        <ToastItem key={toast.id} toast={toast} onDismiss={onDismiss} />\n      ))}\n    </div>\n  );\n}\n\n// ============================================\n// Individual Toast Component\n// ============================================\n\ninterface ToastItemProps {\n  toast: Toast;\n  onDismiss: (id: string) => void;\n}\n\nconst TOAST_STYLES: Record<ToastType, { bg: string; border: string; icon: string }> = {\n  success: {\n    bg: 'bg-green-950/90',\n    border: 'border-green-700',\n    icon: 'âœ“',\n  },\n  error: {\n    bg: 'bg-red-950/90',\n    border: 'border-red-700',\n    icon: 'âœ•',\n  },\n  warning: {\n    bg: 'bg-yellow-950/90',\n    border: 'border-yellow-700',\n    icon: 'âš ',\n  },\n  info: {\n    bg: 'bg-blue-950/90',\n    border: 'border-blue-700',\n    icon: 'â„¹',\n  },\n};\n\nfunction ToastItem({ toast, onDismiss }: ToastItemProps) {\n  const style = TOAST_STYLES[toast.type];\n\n  return (\n    <div\n      className={`\n        ${style.bg} ${style.border}\n        border px-4 py-3 cut-corner-sm\n        shadow-lg backdrop-blur-sm\n        animate-slide-in-right\n        flex items-start gap-3\n        text-sm text-gray-100\n      `}\n      role=\"alert\"\n    >\n      <span className=\"text-lg leading-none mt-0.5\">{style.icon}</span>\n      <p className=\"flex-1 leading-snug\">{toast.message}</p>\n      {toast.action && (\n        <button\n          onClick={() => {\n            toast.action?.onClick();\n            onDismiss(toast.id);\n          }}\n          className=\"text-[10px] font-semibold uppercase tracking-[0.28em] text-neon-cyan hover:text-white transition-colors\"\n          aria-label={toast.action.label}\n        >\n          {toast.action.label}\n        </button>\n      )}\n      <button\n        onClick={() => onDismiss(toast.id)}\n        className=\"text-gray-400 hover:text-white transition-colors ml-2\"\n        aria-label=\"Dismiss\"\n      >\n        Ã—\n      </button>\n    </div>\n  );\n}\n\nexport default useToast;\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/aiMetricsService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/componentValidator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vi' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for componentValidator service\n * Ensures inventory-canvas consistency validation works correctly\n */\n\nimport { describe, it, expect, vi } from 'vitest';\nimport {\n  validateDiagramInventoryConsistency,\n  analyzeUsage,\n  determineOrphanAction,\n  syncComponentWithInventory,\n  syncDiagramWithInventory,\n  removeOrphanedComponents,\n} from '../componentValidator';\nimport type { ElectronicComponent, WiringDiagram } from '../../types';\n\n// ============================================\n// Test Data Factories\n// ============================================\n\nconst createComponent = (overrides: Partial<ElectronicComponent> = {}): ElectronicComponent => ({\n  id: 'test-component',\n  name: 'Test Component',\n  type: 'sensor',\n  description: 'A test component',\n  pins: ['VCC', 'GND', 'DATA'],\n  ...overrides,\n});\n\nconst createDiagram = (components: ElectronicComponent[] = [], connections: any[] = []): WiringDiagram => ({\n  title: 'Test Diagram',\n  components,\n  connections,\n  explanation: 'Test diagram',\n});\n\n// ============================================\n// validateDiagramInventoryConsistency Tests\n// ============================================\n\ndescribe('validateDiagramInventoryConsistency', () => {\n  it('should return valid for empty diagram', () => {\n    const diagram = createDiagram();\n    const inventory: ElectronicComponent[] = [];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(true);\n    expect(result.mismatches).toHaveLength(0);\n    expect(result.totalChecked).toBe(0);\n  });\n\n  it('should return valid when all components match', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'Arduino Uno' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Arduino Uno',\n      sourceInventoryId: '1',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(true);\n    expect(result.syncedCount).toBe(1);\n  });\n\n  it('should detect name mismatch', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'Arduino Uno R3' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Arduino Uno',\n      sourceInventoryId: '1',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(false);\n    expect(result.mismatches).toHaveLength(1);\n    expect(result.mismatches[0].field).toBe('name');\n    expect(result.mismatches[0].expected).toBe('Arduino Uno R3');\n    expect(result.mismatches[0].actual).toBe('Arduino Uno');\n  });\n\n  it('should detect type mismatch', () => {\n    const inventoryItem = createComponent({ id: '1', type: 'microcontroller' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      type: 'sensor',\n      sourceInventoryId: '1',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(false);\n    expect(result.mismatches.some(m => m.field === 'type')).toBe(true);\n  });\n\n  it('should detect pin mismatch', () => {\n    const inventoryItem = createComponent({ id: '1', pins: ['VCC', 'GND', 'D0', 'D1'] });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      pins: ['VCC', 'GND'],\n      sourceInventoryId: '1',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(false);\n    expect(result.mismatches.some(m => m.field === 'pins')).toBe(true);\n  });\n\n  it('should detect orphaned component (source deleted)', () => {\n    const diagramItem = createComponent({\n      id: '1-123456',\n      sourceInventoryId: 'deleted-id',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory: ElectronicComponent[] = [];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(false);\n    expect(result.orphanedCount).toBe(1);\n    expect(result.mismatches[0].field).toBe('missing');\n  });\n\n  it('should handle legacy components without sourceInventoryId', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'Arduino' });\n    const legacyDiagramItem = createComponent({\n      id: '1-123456',\n      name: 'Arduino',\n      // No sourceInventoryId - legacy component\n    });\n\n    const diagram = createDiagram([legacyDiagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    // Should find match by ID prefix\n    expect(result.isValid).toBe(true);\n    expect(result.syncedCount).toBe(1);\n  });\n});\n\n// ============================================\n// analyzeUsage Tests\n// ============================================\n\ndescribe('analyzeUsage', () => {\n  it('should return empty usage for unused component', () => {\n    const diagram = createDiagram();\n\n    const usage = analyzeUsage('unused-id', diagram);\n\n    expect(usage.inDiagramCount).toBe(0);\n    expect(usage.hasActiveConnections).toBe(false);\n    expect(usage.connectionCount).toBe(0);\n  });\n\n  it('should detect component in diagram without connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp]);\n\n    const usage = analyzeUsage('1', diagram);\n\n    expect(usage.inDiagramCount).toBe(1);\n    expect(usage.hasActiveConnections).toBe(false);\n    expect(usage.connectionCount).toBe(0);\n  });\n\n  it('should detect component with active connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp], [\n      { fromComponentId: '1-123456', fromPin: 'VCC', toComponentId: 'other', toPin: 'IN', description: 'test' },\n    ]);\n\n    const usage = analyzeUsage('1', diagram);\n\n    expect(usage.hasActiveConnections).toBe(true);\n    expect(usage.connectionCount).toBe(1);\n  });\n\n  it('should count multiple connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp], [\n      { fromComponentId: '1-123456', fromPin: 'VCC', toComponentId: 'other', toPin: 'IN', description: 'test1' },\n      { fromComponentId: 'other', fromPin: 'OUT', toComponentId: '1-123456', toPin: 'DATA', description: 'test2' },\n    ]);\n\n    const usage = analyzeUsage('1', diagram);\n\n    expect(usage.connectionCount).toBe(2);\n  });\n});\n\n// ============================================\n// determineOrphanAction Tests\n// ============================================\n\ndescribe('determineOrphanAction', () => {\n  it('should return cascade for unused component', () => {\n    const diagram = createDiagram();\n\n    const { action, reason } = determineOrphanAction('unused', diagram);\n\n    expect(action).toBe('cascade');\n    expect(reason).toContain('not used');\n  });\n\n  it('should return block for component with active connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp], [\n      { fromComponentId: '1-123456', fromPin: 'VCC', toComponentId: 'other', toPin: 'IN', description: 'test' },\n    ]);\n\n    const { action, reason } = determineOrphanAction('1', diagram);\n\n    expect(action).toBe('block');\n    expect(reason).toContain('Cannot delete');\n    expect(reason).toContain('wire');\n  });\n\n  it('should return cascade for component in diagram without connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp]);\n\n    const { action } = determineOrphanAction('1', diagram);\n\n    // No saved diagrams passed, so it's treated as draft only\n    expect(action).toBe('cascade');\n  });\n});\n\n// ============================================\n// syncComponentWithInventory Tests\n// ============================================\n\ndescribe('syncComponentWithInventory', () => {\n  it('should update component with inventory data', () => {\n    const inventoryItem = createComponent({\n      id: '1',\n      name: 'Updated Name',\n      type: 'microcontroller',\n      pins: ['A', 'B', 'C'],\n    });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Old Name',\n      type: 'sensor',\n      pins: ['X', 'Y'],\n      sourceInventoryId: '1',\n    });\n\n    const synced = syncComponentWithInventory(diagramItem, [inventoryItem]);\n\n    expect(synced.id).toBe('1-123456'); // ID preserved\n    expect(synced.name).toBe('Updated Name');\n    expect(synced.type).toBe('microcontroller');\n    expect(synced.pins).toEqual(['A', 'B', 'C']);\n    expect(synced.sourceInventoryId).toBe('1');\n  });\n\n  it('should return original if no source found', () => {\n    const diagramItem = createComponent({\n      id: '1-123456',\n      sourceInventoryId: 'missing',\n    });\n\n    const synced = syncComponentWithInventory(diagramItem, []);\n\n    expect(synced).toEqual(diagramItem);\n  });\n});\n\n// ============================================\n// syncDiagramWithInventory Tests\n// ============================================\n\ndescribe('syncDiagramWithInventory', () => {\n  it('should sync all components and count changes', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'New Name' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Old Name',\n      sourceInventoryId: '1',\n    });\n    const diagram = createDiagram([diagramItem]);\n\n    const { diagram: synced, changeCount } = syncDiagramWithInventory(diagram, [inventoryItem]);\n\n    expect(changeCount).toBe(1);\n    expect(synced.components[0].name).toBe('New Name');\n  });\n\n  it('should return 0 changes when already in sync', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'Same Name' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Same Name',\n      sourceInventoryId: '1',\n      type: inventoryItem.type,\n      description: inventoryItem.description,\n      pins: inventoryItem.pins,\n    });\n    const diagram = createDiagram([diagramItem]);\n\n    const { changeCount } = syncDiagramWithInventory(diagram, [inventoryItem]);\n\n    expect(changeCount).toBe(0);\n  });\n});\n\n// ============================================\n// removeOrphanedComponents Tests\n// ============================================\n\ndescribe('removeOrphanedComponents', () => {\n  it('should remove components with deleted inventory source', () => {\n    const orphanedComp = createComponent({\n      id: '1-123456',\n      sourceInventoryId: 'deleted',\n    });\n    const validComp = createComponent({\n      id: '2-123456',\n      sourceInventoryId: '2',\n    });\n    const diagram = createDiagram([orphanedComp, validComp]);\n    const inventory = [createComponent({ id: '2' })];\n\n    const { diagram: cleaned, removedIds } = removeOrphanedComponents(diagram, inventory);\n\n    expect(cleaned.components).toHaveLength(1);\n    expect(cleaned.components[0].id).toBe('2-123456');\n    expect(removedIds).toContain('1-123456');\n  });\n\n  it('should also remove connections to orphaned components', () => {\n    const orphanedComp = createComponent({ id: '1-123456', sourceInventoryId: 'deleted' });\n    const validComp = createComponent({ id: '2-123456', sourceInventoryId: '2' });\n    const diagram = createDiagram(\n      [orphanedComp, validComp],\n      [\n        { fromComponentId: '1-123456', fromPin: 'OUT', toComponentId: '2-123456', toPin: 'IN', description: '' },\n        { fromComponentId: '2-123456', fromPin: 'OUT', toComponentId: '3', toPin: 'IN', description: '' },\n      ]\n    );\n    const inventory = [createComponent({ id: '2' })];\n\n    const { diagram: cleaned } = removeOrphanedComponents(diagram, inventory);\n\n    // Connection to orphaned component should be removed\n    expect(cleaned.connections).toHaveLength(1);\n    expect(cleaned.connections[0].fromComponentId).toBe('2-123456');\n  });\n\n  it('should return empty removedIds when nothing to remove', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp]);\n    const inventory = [createComponent({ id: '1' })];\n\n    const { removedIds } = removeOrphanedComponents(diagram, inventory);\n\n    expect(removedIds).toHaveLength(0);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/geminiService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/securityAuditor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/storageSanitization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/userProfileService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/aiContextBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/aiMetricsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/analytics/projectAnalyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/api/apiDispatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/api/apiGateway.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/api/events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/api/tokenService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/apiKeyStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/authService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/bomService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/circuitAnalysisService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/collabService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/componentValidator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":506,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":506,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14012,14015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14012,14015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Component Validator Service\n * Ensures 100% consistency between inventory and diagram canvas\n *\n * Key principle: Inventory is the SINGLE SOURCE OF TRUTH\n * Diagram components must always match their inventory source\n */\n\nimport type { ElectronicComponent, WiringDiagram, WireConnection } from '../types';\n\n// ============================================\n// Types\n// ============================================\n\nexport interface ComponentMismatch {\n  diagramComponentId: string;\n  diagramComponentName: string;\n  inventoryId: string | undefined;\n  field: 'name' | 'type' | 'pins' | 'description' | 'missing' | 'orphaned';\n  expected: unknown;\n  actual: unknown;\n  severity: 'error' | 'warning';\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  mismatches: ComponentMismatch[];\n  orphanedCount: number;\n  syncedCount: number;\n  totalChecked: number;\n}\n\nexport interface ComponentUsage {\n  inventoryId: string;\n  inDiagramCount: number;\n  hasActiveConnections: boolean;\n  connectionCount: number;\n  inSavedDiagrams: boolean;\n  onlyInDrafts: boolean;\n  diagramIds: string[];\n}\n\nexport type OrphanAction = 'block' | 'warn' | 'cascade';\n\n// ============================================\n// Main Validation Functions\n// ============================================\n\n/**\n * Validate all diagram components against inventory\n * Returns detailed mismatches for debugging/fixing\n */\nexport function validateDiagramInventoryConsistency(\n  diagram: WiringDiagram,\n  inventory: ElectronicComponent[]\n): ValidationResult {\n  const mismatches: ComponentMismatch[] = [];\n  let orphanedCount = 0;\n  let syncedCount = 0;\n\n  const inventoryMap = new Map(inventory.map(i => [i.id, i]));\n\n  for (const comp of diagram.components) {\n    // Check if component has a source reference\n    if (!comp.sourceInventoryId) {\n      // Legacy component without reference - try to find by ID prefix\n      const baseId = comp.id.split('-')[0];\n      const source = inventoryMap.get(baseId);\n\n      if (!source) {\n        mismatches.push({\n          diagramComponentId: comp.id,\n          diagramComponentName: comp.name,\n          inventoryId: undefined,\n          field: 'orphaned',\n          expected: 'Component should have inventory source',\n          actual: 'No sourceInventoryId and no matching inventory item',\n          severity: 'warning',\n        });\n        orphanedCount++;\n        continue;\n      }\n      // Found by ID prefix - check consistency\n      const sourceMismatches = compareComponent(comp, source);\n      mismatches.push(...sourceMismatches);\n      if (sourceMismatches.length === 0) syncedCount++;\n      continue;\n    }\n\n    // Has sourceInventoryId - look it up\n    const source = inventoryMap.get(comp.sourceInventoryId);\n\n    if (!source) {\n      // Source was deleted from inventory\n      mismatches.push({\n        diagramComponentId: comp.id,\n        diagramComponentName: comp.name,\n        inventoryId: comp.sourceInventoryId,\n        field: 'missing',\n        expected: `Inventory item ${comp.sourceInventoryId}`,\n        actual: 'Inventory item no longer exists',\n        severity: 'error',\n      });\n      orphanedCount++;\n      continue;\n    }\n\n    // Compare all fields\n    const sourceMismatches = compareComponent(comp, source);\n    mismatches.push(...sourceMismatches);\n    if (sourceMismatches.length === 0) syncedCount++;\n  }\n\n  return {\n    isValid: mismatches.length === 0,\n    mismatches,\n    orphanedCount,\n    syncedCount,\n    totalChecked: diagram.components.length,\n  };\n}\n\n/**\n * Compare a diagram component against its inventory source\n */\nfunction compareComponent(\n  diagramComp: ElectronicComponent,\n  inventoryComp: ElectronicComponent\n): ComponentMismatch[] {\n  const mismatches: ComponentMismatch[] = [];\n  const inventoryId = diagramComp.sourceInventoryId || inventoryComp.id;\n\n  // Check name\n  if (diagramComp.name !== inventoryComp.name) {\n    mismatches.push({\n      diagramComponentId: diagramComp.id,\n      diagramComponentName: diagramComp.name,\n      inventoryId,\n      field: 'name',\n      expected: inventoryComp.name,\n      actual: diagramComp.name,\n      severity: 'error',\n    });\n  }\n\n  // Check type\n  if (diagramComp.type !== inventoryComp.type) {\n    mismatches.push({\n      diagramComponentId: diagramComp.id,\n      diagramComponentName: diagramComp.name,\n      inventoryId,\n      field: 'type',\n      expected: inventoryComp.type,\n      actual: diagramComp.type,\n      severity: 'error',\n    });\n  }\n\n  // Check pins (order-independent comparison)\n  const diagramPins = new Set(diagramComp.pins || []);\n  const inventoryPins = new Set(inventoryComp.pins || []);\n\n  if (!areSetsEqual(diagramPins, inventoryPins)) {\n    mismatches.push({\n      diagramComponentId: diagramComp.id,\n      diagramComponentName: diagramComp.name,\n      inventoryId,\n      field: 'pins',\n      expected: Array.from(inventoryPins),\n      actual: Array.from(diagramPins),\n      severity: 'error',\n    });\n  }\n\n  return mismatches;\n}\n\n/**\n * Check if two sets are equal\n */\nfunction areSetsEqual<T>(a: Set<T>, b: Set<T>): boolean {\n  if (a.size !== b.size) return false;\n  for (const item of a) {\n    if (!b.has(item)) return false;\n  }\n  return true;\n}\n\n// ============================================\n// Usage Analysis (for deletion rules)\n// ============================================\n\n/**\n * Analyze how an inventory item is used across all diagrams\n */\nexport function analyzeUsage(\n  inventoryId: string,\n  currentDiagram: WiringDiagram,\n  savedDiagrams: WiringDiagram[] = []\n): ComponentUsage {\n  const allDiagrams = [currentDiagram, ...savedDiagrams];\n  const diagramIds: string[] = [];\n  let totalConnections = 0;\n  let hasActiveConnections = false;\n  let inSavedDiagrams = false;\n\n  for (let i = 0; i < allDiagrams.length; i++) {\n    const diagram = allDiagrams[i];\n    const isSaved = i > 0; // First is current, rest are saved\n\n    // Find instances of this inventory item in the diagram\n    const instances = diagram.components.filter(c =>\n      c.sourceInventoryId === inventoryId ||\n      c.id === inventoryId ||\n      c.id.startsWith(`${inventoryId}-`)\n    );\n\n    if (instances.length > 0) {\n      diagramIds.push(diagram.title || `Diagram ${i}`);\n      if (isSaved) inSavedDiagrams = true;\n\n      // Check for connections to these instances\n      for (const instance of instances) {\n        const connections = countConnectionsToComponent(instance.id, diagram.connections);\n        totalConnections += connections;\n        if (connections > 0) hasActiveConnections = true;\n      }\n    }\n  }\n\n  return {\n    inventoryId,\n    inDiagramCount: diagramIds.length,\n    hasActiveConnections,\n    connectionCount: totalConnections,\n    inSavedDiagrams,\n    onlyInDrafts: diagramIds.length > 0 && !inSavedDiagrams,\n    diagramIds,\n  };\n}\n\n/**\n * Count connections to a specific component\n */\nfunction countConnectionsToComponent(\n  componentId: string,\n  connections: WireConnection[]\n): number {\n  return connections.filter(\n    c => c.fromComponentId === componentId || c.toComponentId === componentId\n  ).length;\n}\n\n// ============================================\n// Smart Orphan Handling\n// ============================================\n\n/**\n * Determine what action to take when deleting an inventory item\n * Based on context-aware rules\n */\nexport function determineOrphanAction(\n  inventoryId: string,\n  currentDiagram: WiringDiagram,\n  savedDiagrams: WiringDiagram[] = []\n): { action: OrphanAction; reason: string; usage: ComponentUsage } {\n  const usage = analyzeUsage(inventoryId, currentDiagram, savedDiagrams);\n\n  // BLOCK: Component has active wired connections\n  if (usage.hasActiveConnections) {\n    return {\n      action: 'block',\n      reason: `Cannot delete: component is used in ${usage.connectionCount} wire connection(s). Remove wires first.`,\n      usage,\n    };\n  }\n\n  // WARN: Component exists in SAVED diagrams\n  if (usage.inSavedDiagrams) {\n    return {\n      action: 'warn',\n      reason: `Component is used in ${usage.inDiagramCount} saved diagram(s): ${usage.diagramIds.join(', ')}. Remove from all?`,\n      usage,\n    };\n  }\n\n  // CASCADE: Component only in current/draft diagram with no connections\n  if (usage.onlyInDrafts) {\n    return {\n      action: 'cascade',\n      reason: `Component will be removed from current diagram (no saved references).`,\n      usage,\n    };\n  }\n\n  // Not used anywhere - safe to delete\n  return {\n    action: 'cascade',\n    reason: 'Component is not used in any diagrams.',\n    usage,\n  };\n}\n\n// ============================================\n// Sync Helpers\n// ============================================\n\n/**\n * Migration mapping for legacy component IDs\n */\nconst LEGACY_ID_MAP: Record<string, string> = {\n  'mcu': 'mcu-arduino-uno-r3',\n  'mcu1': 'mcu-arduino-uno-r3',\n  'pot': 'other-potentiometer',\n  'pot1': 'other-potentiometer',\n  'servo': 'actuator-servo',\n  'servo1': 'actuator-servo',\n  'sensor': 'sensor-hcsr04',\n  'hcsr04': 'sensor-hcsr04',\n  'dht11': 'sensor-dht11',\n  'lcd': 'display-lcd1602',\n};\n\n/**\n * Repairs a legacy diagram by mapping old IDs to new semantic inventory IDs\n */\nexport function migrateLegacyDiagram(\n  diagram: WiringDiagram,\n  inventory: ElectronicComponent[]\n): { diagram: WiringDiagram; repairedCount: number } {\n  let repairedCount = 0;\n  const inventoryIds = new Set(inventory.map(i => i.id));\n\n  const migratedComponents = diagram.components.map(comp => {\n    // Already has a valid reference?\n    if (comp.sourceInventoryId && inventoryIds.has(comp.sourceInventoryId)) {\n      return comp;\n    }\n\n    // Try to find mapping for legacy ID or prefix\n    const baseId = comp.sourceInventoryId || comp.id.split('-')[0];\n    const newSourceId = LEGACY_ID_MAP[baseId] || LEGACY_ID_MAP[comp.name.toLowerCase()] || undefined;\n\n    if (newSourceId && inventoryIds.has(newSourceId)) {\n      repairedCount++;\n      return {\n        ...comp,\n        sourceInventoryId: newSourceId\n      };\n    }\n\n    // Fallback: try finding by name exact match\n    const byName = inventory.find(i => i.name === comp.name);\n    if (byName) {\n      repairedCount++;\n      return {\n        ...comp,\n        sourceInventoryId: byName.id\n      };\n    }\n\n    return comp;\n  });\n\n  return {\n    diagram: {\n      ...diagram,\n      components: migratedComponents\n    },\n    repairedCount\n  };\n}\n\n/**\n * Sync a diagram component with its inventory source\n * Returns the updated component (or original if no source found)\n */\nexport function syncComponentWithInventory(\n  diagramComp: ElectronicComponent,\n  inventory: ElectronicComponent[]\n): ElectronicComponent {\n  const inventoryMap = new Map(inventory.map(i => [i.id, i]));\n\n  // Find source\n  const sourceId = diagramComp.sourceInventoryId || diagramComp.id.split('-')[0];\n  const source = inventoryMap.get(sourceId);\n\n  if (!source) {\n    // No source found - return as-is\n    return diagramComp;\n  }\n\n  // Sync fields from inventory (preserve diagram instance id)\n  return {\n    ...diagramComp,\n    sourceInventoryId: source.id,\n    name: source.name,\n    type: source.type,\n    description: source.description,\n    pins: source.pins ? [...source.pins] : undefined,\n    datasheetUrl: source.datasheetUrl,\n    imageUrl: source.imageUrl,\n  };\n}\n\n/**\n * Sync all diagram components with inventory\n * Returns new diagram with synced components\n */\nexport function syncDiagramWithInventory(\n  diagram: WiringDiagram,\n  inventory: ElectronicComponent[]\n): { diagram: WiringDiagram; changeCount: number } {\n  let changeCount = 0;\n\n  const syncedComponents = diagram.components.map(comp => {\n    const synced = syncComponentWithInventory(comp, inventory);\n\n    // Check if anything changed\n    if (JSON.stringify(comp) !== JSON.stringify(synced)) {\n      changeCount++;\n    }\n\n    return synced;\n  });\n\n  return {\n    diagram: {\n      ...diagram,\n      components: syncedComponents,\n    },\n    changeCount,\n  };\n}\n\n/**\n * Remove orphaned components from diagram\n * (components whose inventory source no longer exists)\n */\nexport function removeOrphanedComponents(\n  diagram: WiringDiagram,\n  inventory: ElectronicComponent[]\n): { diagram: WiringDiagram; removedIds: string[] } {\n  const inventoryIds = new Set(inventory.map(i => i.id));\n  const removedIds: string[] = [];\n\n  const filteredComponents = diagram.components.filter(comp => {\n    const sourceId = comp.sourceInventoryId || comp.id.split('-')[0];\n    const exists = inventoryIds.has(sourceId);\n\n    if (!exists) {\n      removedIds.push(comp.id);\n    }\n\n    return exists;\n  });\n\n  // Also remove connections to removed components\n  const removedIdSet = new Set(removedIds);\n  const filteredConnections = diagram.connections.filter(\n    c => !removedIdSet.has(c.fromComponentId) && !removedIdSet.has(c.toComponentId)\n  );\n\n  return {\n    diagram: {\n      ...diagram,\n      components: filteredComponents,\n      connections: filteredConnections,\n    },\n    removedIds,\n  };\n}\n\n// ============================================\n// Debug/Dev Utilities\n// ============================================\n\n/**\n * Log validation results to console (dev mode only)\n */\nexport function logValidationResult(result: ValidationResult, label = 'Validation'): void {\n  if (result.isValid) {\n    console.log(`âœ… ${label}: All ${result.totalChecked} components in sync`);\n    return;\n  }\n\n  console.group(`âŒ ${label}: ${result.mismatches.length} mismatch(es) found`);\n  console.log(`Synced: ${result.syncedCount}/${result.totalChecked}`);\n  console.log(`Orphaned: ${result.orphanedCount}`);\n\n  for (const m of result.mismatches) {\n    const icon = m.severity === 'error' ? 'ðŸ”´' : 'ðŸŸ¡';\n    console.log(`${icon} [${m.field}] ${m.diagramComponentName} (${m.diagramComponentId})`);\n    console.log(`   Expected: ${JSON.stringify(m.expected)}`);\n    console.log(`   Actual:   ${JSON.stringify(m.actual)}`);\n  }\n\n  console.groupEnd();\n}\n\n/**\n * Validates a 3D model's dimensions against expected standards.\n * Returns a score from 0-1 and any specific deviations.\n */\nexport function verifyModelDimensions(\n  model: any, // Three.js Object3D (as JSON or instance)\n  expected: { width: number, length: number, height: number }\n): { score: number; deviations: string[] } {\n  const deviations: string[] = [];\n  \n  // Calculate bounding box from JSON data if necessary\n  // For simplicity here, we assume we are checking the dimensions already extracted\n  // In reality, ThreeViewer will call this after loading.\n  \n  const widthDiff = Math.abs(model.width - expected.width);\n  const lengthDiff = Math.abs(model.length - expected.length);\n  const heightDiff = Math.abs(model.height - expected.height);\n\n  if (widthDiff > expected.width * 0.1) deviations.push(`Width mismatch: ${model.width}mm vs ${expected.width}mm`);\n  if (lengthDiff > expected.length * 0.1) deviations.push(`Length mismatch: ${model.length}mm vs ${expected.length}mm`);\n  if (heightDiff > expected.height * 0.2) deviations.push(`Height mismatch: ${model.height}mm vs ${expected.height}mm`);\n\n  const score = Math.max(0, 1 - (deviations.length * 0.3));\n  return { score, deviations };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/config/configManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[993,996],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[993,996],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import yaml from 'js-yaml';\n\nexport interface WorkspaceConfig {\n  version: string;\n  metadata: {\n    name: string;\n    environment: 'home' | 'work' | 'lab';\n  };\n  ui: Record<string, unknown>;\n  ai: Record<string, unknown>;\n  standards: Record<string, unknown>;\n}\n\nclass ConfigManager {\n  /**\n   * Serializes current app state to YAML string.\n   */\n  serialize(data: unknown): string {\n    const scrubbed = this.scrubSecrets(data);\n    return yaml.dump(scrubbed);\n  }\n\n  /**\n   * Parses and validates a configuration string.\n   */\n  deserialize(content: string): WorkspaceConfig | null {\n    try {\n      const parsed = yaml.load(content) as unknown;\n      if (this.validate(parsed)) return parsed;\n      return null;\n    } catch (e) {\n      console.error('Failed to parse config', e);\n      return null;\n    }\n  }\n\n  private scrubSecrets(data: unknown): unknown {\n    if (!data || typeof data !== 'object') return data;\n    \n    const copy = JSON.parse(JSON.stringify(data)) as Record<string, any>;\n    // Implementation to remove API keys, PINs etc.\n    if (copy.ai && typeof copy.ai === 'object' && copy.ai.apiKey) {\n      copy.ai.apiKey = '********';\n    }\n    return copy;\n  }\n\n  private validate(config: unknown): config is WorkspaceConfig {\n    if (!config || typeof config !== 'object') return false;\n    const c = config as Record<string, unknown>;\n    return typeof c.version === 'string';\n  }\n}\n\nexport const configManager = new ConfigManager();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/connectivityService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'response' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":35,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"type ConnectivityListener = (isOnline: boolean) => void;\n\nclass ConnectivityService {\n  private listeners: Set<ConnectivityListener> = new Set();\n  private isOnline: boolean = navigator.onLine;\n\n  constructor() {\n    window.addEventListener('online', () => this.handleStatusChange(true));\n    window.addEventListener('offline', () => this.handleStatusChange(false));\n  }\n\n  private handleStatusChange(status: boolean) {\n    this.isOnline = status;\n    this.listeners.forEach(l => l(status));\n  }\n\n  onStatusChange(listener: ConnectivityListener) {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  getIsOnline(): boolean {\n    return this.isOnline;\n  }\n\n  /**\n   * Performs an actual network request to verify if the Gemini API is reachable.\n   * Useful when ICMP (ping) is blocked by firewalls but HTTPS is allowed.\n   */\n  async checkApiReachability(): Promise<boolean> {\n    try {\n      // Use a HEAD request to minimize data usage\n      const response = await fetch('https://generativelanguage.googleapis.com/', {\n        method: 'HEAD',\n        mode: 'no-cors' // We just need to know if the server is there\n      });\n      return true; // If we get here, the server responded (even if it's a 404/403)\n    } catch (e) {\n      console.warn('API Reachability check failed:', e);\n      return false;\n    }\n  }\n}\n\nexport const connectivityService = new ConnectivityService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/datasetService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/datasheetProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[959,962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[959,962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nexport interface ScrapedPin {\n  number: number;\n  name: string;\n  function: string;\n}\n\nexport interface ScrapedSpecs {\n  voltageMin: number;\n  voltageMax: number;\n  currentLimit?: number;\n  logicLevel: '3.3V' | '5V' | 'Adjustable' | 'Other';\n}\n\nexport interface ScrapedMetadata {\n  pins: ScrapedPin[];\n  specs: ScrapedSpecs;\n  confidence: number;\n}\n\nclass DatasheetProcessor {\n  /**\n   * Converts a File to base64 string for API consumption.\n   */\n  async fileToBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => {\n        const base64 = reader.result as string;\n        // Remove the data:application/pdf;base64, prefix\n        resolve(base64.split(',')[1]);\n      };\n      reader.onerror = (error) => reject(error);\n    });\n  }\n\n  /**\n   * Utility to validate the structure of scraped data.\n   */\n  validateMetadata(data: any): data is ScrapedMetadata {\n    return (\n      data &&\n      Array.isArray(data.pins) &&\n      typeof data.specs === 'object' &&\n      typeof data.confidence === 'number'\n    );\n  }\n}\n\nexport const datasheetProcessor = new DatasheetProcessor();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/diagramDiff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/error/diagnosticsHub.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/feedback/correctionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/bom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/chat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/components.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7715,7718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7715,7718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":300,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":300,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":308,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11094,11097],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11094,11097],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":372,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":372,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13906,13909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13906,13909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ElectronicComponent } from \"../../../types\";\nimport { getAIClient, MODELS } from \"../client\";\nimport { PROMPTS } from \"../prompts\";\nimport { COMPONENT_SCHEMA, PART_FINDER_SCHEMA } from \"../types\";\nimport { aiMetricsService } from \"../../aiMetricsService\";\nimport { standardsService } from \"../../standardsService\";\n\nconst CACHE_KEY_PREFIX = 'cm_3d_code_';\n\nexport const explainComponent = async (componentName: string): Promise<string> => {\n  const startTime = Date.now();\n  const model = MODELS.CHAT;\n  const ai = getAIClient();\n\n  // Check if API key is configured\n  const apiKey = localStorage.getItem('cm_gemini_api_key') || process.env.API_KEY;\n  if (!apiKey) {\n    return `**API Key Required**\\n\\nTo get component explanations, please configure your Gemini API key in Settings.\\n\\n*Component: ${componentName}*`;\n  }\n\n  try {\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: PROMPTS.EXPLAIN_COMPONENT(componentName),\n    });\n\n    aiMetricsService.logMetric({\n        model,\n        operation: 'explainComponent',\n        latencyMs: Date.now() - startTime,\n        success: true\n      });\n\n    return response.text || \"Could not retrieve explanation.\";\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    console.error('[explainComponent] Error:', errorMessage);\n\n    aiMetricsService.logMetric({\n        model,\n        operation: 'explainComponent',\n        latencyMs: Date.now() - startTime,\n        success: false,\n        error: errorMessage\n      });\n\n    // Provide user-friendly error messages\n    if (errorMessage.includes('API_KEY') || errorMessage.includes('401') || errorMessage.includes('invalid')) {\n      return `**API Key Error**\\n\\nYour Gemini API key may be invalid or expired. Please check your API key in Settings.\\n\\n*Error: ${errorMessage}*`;\n    }\n    if (errorMessage.includes('429') || errorMessage.includes('quota') || errorMessage.includes('rate')) {\n      return `**Rate Limited**\\n\\nToo many requests. Please wait a moment and try again.\\n\\n*Component: ${componentName}*`;\n    }\n    if (errorMessage.includes('network') || errorMessage.includes('fetch') || errorMessage.includes('Failed to fetch')) {\n      return `**Connection Error**\\n\\nCouldn't connect to the AI service. Please check your internet connection.\\n\\n*Component: ${componentName}*`;\n    }\n\n    return `**Error Loading Details**\\n\\nCouldn't retrieve information for \"${componentName}\".\\n\\n*Error: ${errorMessage}*`;\n  }\n};\n\nexport const smartFillComponent = async (name: string, type?: string): Promise<Partial<ElectronicComponent>> => {\n  const startTime = Date.now();\n  const model = MODELS.SMART_FILL;\n  const ai = getAIClient();\n  \n  try {\n    const response = await ai.models.generateContent({\n      model: model, \n      contents: PROMPTS.SMART_FILL(name, type),\n      config: {\n        tools: [{ googleSearch: {} }],\n        // responseMimeType: \"application/json\" is unsupported when tools are used\n      }\n    });\n\n    if (response.text) {\n        aiMetricsService.logMetric({ model, operation: 'smartFillComponent', latencyMs: Date.now() - startTime, success: true });\n        return JSON.parse(response.text);\n    }\n    return {};\n  } catch (e) {\n      aiMetricsService.logMetric({ model, operation: 'smartFillComponent', latencyMs: Date.now() - startTime, success: false, error: String(e) });\n      console.error(\"Smart Fill Error\", e);\n      throw e;\n  }\n}\n\nexport const assistComponentEditor = async (\n  history: { role: string, text: string }[],\n  currentComponent: Partial<ElectronicComponent>,\n  userInstruction: string\n): Promise<{\n  reply: string, \n  updates: Partial<ElectronicComponent>,\n  foundImages: string[],\n  suggestedActions: string[]\n}> => {\n  const startTime = Date.now();\n  const model = MODELS.ASSIST_EDITOR;\n  const ai = getAIClient();\n  \n  try {\n    const contextPrompt = PROMPTS.ASSIST_EDITOR(JSON.stringify(currentComponent, null, 2), userInstruction);\n    const chatHistory = history.map(h => ({ role: h.role, parts: [{ text: h.text }] }));\n\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: [\n        ...chatHistory,\n        { role: 'user', parts: [{ text: contextPrompt }] }\n      ],\n      config: {\n        tools: [{ googleSearch: {} }],\n        // responseMimeType: \"application/json\" is unsupported when tools are used\n      }\n    });\n\n    if (response.text) {\n      aiMetricsService.logMetric({ model, operation: 'assistComponentEditor', latencyMs: Date.now() - startTime, success: true });\n      return JSON.parse(response.text);\n    }\n    throw new Error(\"No response from AI assistant\");\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'assistComponentEditor', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"Assistant Error\", error);\n    throw error;\n  }\n};\n\nexport const augmentComponentData = async (partialName: string): Promise<Partial<ElectronicComponent>> => {\n  const startTime = Date.now();\n  const model = MODELS.AUTO_ID;\n  const ai = getAIClient();\n  \n  try {\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: PROMPTS.AUGMENT_COMPONENT(partialName),\n      config: {\n        responseMimeType: \"application/json\",\n        responseSchema: COMPONENT_SCHEMA\n      }\n    });\n    if (response.text) {\n      aiMetricsService.logMetric({ model, operation: 'augmentComponentData', latencyMs: Date.now() - startTime, success: true });\n      return JSON.parse(response.text);\n    }\n    throw new Error(\"Failed to identify\");\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'augmentComponentData', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"Auto-ID Error\", error);\n    throw error;\n  }\n};\n\nexport const findComponentSpecs = async (query: string): Promise<Partial<ElectronicComponent>[]> => {\n  const startTime = Date.now();\n  const model = MODELS.PART_FINDER;\n  const ai = getAIClient();\n  \n  try {\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: PROMPTS.FIND_COMPONENT(query),\n      config: {\n        responseMimeType: \"application/json\",\n        responseSchema: PART_FINDER_SCHEMA\n      }\n    });\n    \n    if (response.text) {\n      aiMetricsService.logMetric({ model, operation: 'findComponentSpecs', latencyMs: Date.now() - startTime, success: true });\n      return JSON.parse(response.text);\n    }\n    return [];\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'findComponentSpecs', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"Part Finder Error\", error);\n    throw error;\n  }\n};\n\nexport const identifyComponentFromImage = async (imageBase64: string): Promise<Partial<ElectronicComponent>> => {\n  const ai = getAIClient();\n  try {\n    const cleanBase64 = imageBase64.replace(/^data:image\\/(png|jpeg|jpg|webp);base64,/, '');\n    const response = await ai.models.generateContent({\n      model: MODELS.IMAGE, // Ensure this maps to a valid model like gemini-2.0-flash\n      contents: {\n        parts: [\n          { inlineData: { mimeType: 'image/png', data: cleanBase64 } },\n          { text: PROMPTS.IDENTIFY_IMAGE }\n        ]\n      },\n    });\n    \n    if (response.text) {\n      const text = response.text.replace(/```json/g, '').replace(/```/g, '').trim();\n      return JSON.parse(text);\n    }\n    throw new Error(\"Failed to identify image\");\n  } catch (error) {\n    console.error(\"Image ID Error\", error);\n    throw error;\n  }\n};\n\nexport const performDeepSpecSearch = async (name: string, type: string): Promise<any> => {\n  const ai = getAIClient();\n  const isLikelyBoard = type.toLowerCase().includes('board') || \n                        type.toLowerCase().includes('module') || \n                        type.toLowerCase().includes('breakout') || \n                        name.toLowerCase().includes('shield') ||\n                        name.toLowerCase().includes('hat');\n\n  console.log(`[Deep Spec Search] Analyzing ${name} (${type}) - Mode: ${isLikelyBoard ? 'BOARD' : 'COMPONENT'}`);\n\n  const prompt = isLikelyBoard \n    ? `\n      Search for the mechanical specifications of the electronic board/module \"${name}\".\n      Prioritize finding:\n      1. PCB Dimensions (Width x Length in mm).\n      2. Mounting Hole spacing/coordinates.\n      3. Key Interface locations (USB port, Power jack, Pin headers).\n      \n      Return ONLY a JSON object:\n      {\n        \"category\": \"board\",\n        \"width\": number,\n        \"length\": number,\n        \"height\": number (approx 1.6 if pcb only, more if connectors),\n        \"mounting_holes\": [ { \"x\": number, \"z\": number, \"diameter\": number } ],\n        \"interfaces\": [\n           { \"type\": \"usb\"|\"header\"|\"jack\"|\"button\", \"edge\": \"left\"|\"right\"|\"top\"|\"bottom\", \"offset_mm\": number }\n        ]\n      }\n    `\n    : `\n      Search for the datasheet and physical dimensions of the electronic component \"${name}\".\n      Prioritize finding:\n      1. Package Type (e.g. SOIC-8, TO-220, QFN-32).\n      2. Exact Body Dimensions (Width x Length x Height).\n      3. Pin Pitch and Count.\n      \n      Return ONLY a JSON object:\n      { \n        \"category\": \"component\",\n        \"package\": string, \n        \"width\": number, \n        \"length\": number, \n        \"height\": number, \n        \"pitch\": number, \n        \"pins\": number,\n        \"datasheet_ref\": string \n      }\n    `;\n  \n  try {\n    const response = await ai.models.generateContent({\n      model: MODELS.SMART_FILL,\n      contents: prompt,\n      config: { tools: [{ googleSearch: {} }] }\n    });\n    \n    if (response.text) {\n        const cleaned = response.text.replace(/```json/g, '').replace(/```/g, '').trim();\n        const data = JSON.parse(cleaned);\n        console.log(`[Deep Spec Search] Success:`, data);\n        return data;\n    }\n  } catch (e) {\n    console.warn(\"Spec search failed\", e);\n  }\n  return null;\n};\n\nexport const generateComponent3DCode = async (\n  componentName: string, \n  componentType: string,\n  customInstructions?: string,\n  force: boolean = false,\n  imageUrl?: string\n): Promise<string> => {\n  const startTime = Date.now();\n  const model = MODELS.CODE_GEN;\n  const ai = getAIClient();\n  \n  // Cache Key: name + type + instructions + (hasImage)\n  const cacheKey = `${CACHE_KEY_PREFIX}${componentName}_${componentType}_${customInstructions || ''}_${imageUrl ? 'img' : ''}`.replace(/\\s+/g, '_').toLowerCase();\n  \n  // Try Cache (unless forced)\n  if (!force) {\n    try {\n      const cached = localStorage.getItem(cacheKey);\n      if (cached) {\n        console.log(`[Cache Hit] 3D Code for ${componentName}`);\n        return cached;\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n  }\n  \n  // 1. Spec Extraction Pass (Grounding)\n  const standard = standardsService.getPackage(componentName) || standardsService.getPackage(componentType);\n  const board = standardsService.getBoardMap(componentName) || standardsService.getBoardMap(componentType);\n  let deepSpec: any = null;\n\n  if (!standard && !board) {\n    console.log(`[Spec Extraction] Hunting dimensions for ${componentName}...`);\n    deepSpec = await performDeepSpecSearch(componentName, componentType);\n    \n    // If deep search found a component package that matches a standard, snap to it?\n    // For now, we trust the deep search if it returned data.\n  }\n\n  let dimensionHint = \"\";\n  if (board) {\n    dimensionHint = `\n      ASSEMBLY PLAN (INTERNAL STANDARD):\n      This is a known board (\"${board.name}\").\n      DO NOT guess. Use this exact placement for major components on the PCB:\n      - PCB: ${board.width}x${board.length}x1.6mm\n      - Sub-components:\n        ${board.components.map(c => `- ${c.name} (${c.type}): At x:${c.x}, z:${c.z}${c.rotation ? `, rot:${c.rotation}` : ''}${c.params ? `, params:${JSON.stringify(c.params)}` : ''}`).join('\\n        ')}\n      REQUIREMENT: You must instantiate every one of these sub-components using Primitives.\n    `;\n  } else if (deepSpec) {\n      if (deepSpec.category === 'board') {\n          dimensionHint = `\n            ASSEMBLY PLAN (FROM WEB DATASHEET):\n            Dimensions: ${deepSpec.width}mm x ${deepSpec.length}mm.\n            Mounting Holes: ${JSON.stringify(deepSpec.mounting_holes || [])}.\n            Interfaces: ${JSON.stringify(deepSpec.interfaces || [])}.\n            \n            USE 'Primitives.createLayout(${deepSpec.width}, ${deepSpec.length})'.\n            Place interfaces at their approximate edges.\n          `;\n      } else {\n          dimensionHint = `\n            GROUNDING DATA (FROM WEB DATASHEET):\n            Package: \"${deepSpec.package}\".\n            Dimensions: ${deepSpec.width}x${deepSpec.length}x${deepSpec.height}mm.\n            Pitch: ${deepSpec.pitch}mm.\n            Pins: ${deepSpec.pins}.\n            Ref: ${deepSpec.datasheet_ref || 'Web Search'}.\n          `;\n      }\n  } else if (standard) {\n    dimensionHint = `\n      GROUNDING DATA (IPC-7351 STANDARD):\n      This component matches package \"${standard.pin_count || 'N/A'}-pin ${standard.pin_type || 'N/A'}\".\n      Use these EXACT dimensions:\n      - body_width: ${standard.body_width}mm\n      - body_length: ${standard.body_length}mm\n      - height: ${standard.height}mm\n      - pitch: ${standard.pitch || 'N/A'}mm\n    `;\n  }\n\n  // 1.5. Visual Analysis Pass (Vision Grounding)\n  let visualAnalysis = \"\";\n  if (imageUrl && !board) { // Only needed if we don't have a hard-coded board map\n      try {\n          console.log(`[Visual Analysis] Looking at ${componentName}...`);\n          // Fetch the image to get base64/blob for Gemini\n          // Note: In a real app, might need a proxy or CORS handling. \n          // Assuming imageUrl is accessible or a data URI.\n          // For now, we'll try-catch this block aggressively.\n          \n          let imagePart: any = null;\n          if (imageUrl.startsWith('data:')) {\n             const mimeType = imageUrl.split(';')[0].split(':')[1];\n             const data = imageUrl.split(',')[1];\n             imagePart = { inlineData: { mimeType, data } };\n          } else {\n             // If it's a URL, we might skip or try to fetch.\n             // For safety in this CLI environment, let's assume if it's not data URI, we skip \n             // unless we add a fetch tool. But let's assume the UI passes data URIs mostly.\n          }\n\n          if (imagePart) {\n             const visionResponse = await ai.models.generateContent({\n                 model: MODELS.IMAGE, // Use a vision-capable model\n                 contents: [\n                     { text: PROMPTS.ANALYZE_COMPONENT_VISUALS },\n                     imagePart\n                 ]\n             });\n             visualAnalysis = visionResponse.text || \"\";\n          }\n      } catch (e) {\n          console.warn(\"Visual analysis failed\", e);\n      }\n  }\n\n  // 2. Assembly Pass (Code Generation)\n  try {\n    const prompt = PROMPTS.GENERATE_3D_CODE(componentName, componentType, customInstructions, dimensionHint, visualAnalysis);\n    \n    const response = await ai.models.generateContent({\n      model: model,\n      contents: prompt,\n      config: {\n         thinkingConfig: { thinkingBudget: 4096 },\n         tools: [{ googleSearch: {} }],\n         systemInstruction: \"You are a Master 3D Architect. Output only valid JavaScript. Use Primitives and Materials for everything. Be precise.\"\n      }\n    });\n\n    let code = response.text || \"\";\n    \n    // 2.5. Self-Correction Pass (Review & Refine)\n    console.log(`[Self-Correction] Reviewing 3D architecture for ${componentName}...`);\n    const correctionPrompt = `\n        Review the following 3D model code for an electronic component.\n        CHECK FOR:\n        1. Syntax errors or mismatched brackets.\n        2. \"Magic numbers\" (all positions should use layout.place()).\n        3. Missing return group; statement.\n        4. Floating components (everything must be added to 'group').\n        \n        CODE TO REVIEW:\n        ${code}\n        \n        If perfect, return the code as-is. \n        If flawed, output the FIXED valid JavaScript code ONLY.\n    `;\n    \n    const correctionResponse = await ai.models.generateContent({\n        model: MODELS.CHAT, // Use a faster model for review\n        contents: correctionPrompt,\n        config: {\n            systemInstruction: \"You are a Senior 3D Code Auditor. Output ONLY valid JS code.\"\n        }\n    });\n    \n    if (correctionResponse.text) {\n        code = correctionResponse.text;\n    }\n\n    // 1. Heavy Markdown/Prose Cleanup\n    code = code.replace(/```(?:javascript|js)?\\n?([\\s\\S]*?)```/g, '$1');\n    \n    // 2. Remove common AI \"Sure thing!\" prose at the start\n    // We only want to strip prose if it appears BEFORE the first valid code line.\n    // Valid code lines start with: const, let, var, import, function, class, or Primitives/THREE/group.\n    \n    // Find the index of the first line that looks like code\n    const lines = code.split('\\n');\n    let firstCodeLineIndex = -1;\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        // Check for comments\n        if (line.startsWith('//') || line.startsWith('/*')) {\n             if (firstCodeLineIndex === -1) firstCodeLineIndex = i; // Comments count as code start usually\n             continue;\n        }\n        // Check for code keywords\n        if (\n            line.startsWith('const ') || \n            line.startsWith('let ') || \n            line.startsWith('var ') || \n            line.startsWith('return ') ||\n            line.startsWith('group') ||\n            line.startsWith('THREE') || \n            line.startsWith('Primitives') ||\n            line.startsWith('layout')\n        ) {\n            firstCodeLineIndex = i;\n            break;\n        }\n    }\n    \n    if (firstCodeLineIndex !== -1) {\n        code = lines.slice(firstCodeLineIndex).join('\\n');\n    }\n\n    // 3. Handle the \"Arrow Function\" Hallucination\n    // If AI wrapped code in (THREE, Primitives, Materials) => { ... }\n    // we want just the ... part.\n    const arrowFuncPattern = /^\\s*\\(?THREE,\\s*Primitives,\\s*Materials\\)?\\s*=>\\s*\\{?([\\s\\S]*?)\\}?\\s*;?\\s*$/i;\n    const arrowMatch = code.match(arrowFuncPattern);\n    if (arrowMatch) {\n        code = arrowMatch[1];\n    }\n\n    // 4. Bracket/Paren Balancer (Crucial for \"Unexpected token ')'\")\n    // If the code ends with a return and then a trailing paren/brace, strip it.\n    const lastReturnIdx = code.lastIndexOf('return group;');\n    if (lastReturnIdx !== -1) {\n        const afterReturn = code.substring(lastReturnIdx + 13).trim();\n        // If there's garbage after return group; like ')', '}', or prose\n        if (afterReturn.length > 0) {\n            // Check if it's just semicolons or single closing marks\n            if (/^[;})\\s]+$/.test(afterReturn)) {\n                code = code.substring(0, lastReturnIdx + 13);\n            } else {\n                // If it's more complex prose, still cut at return group;\n                code = code.substring(0, lastReturnIdx + 13);\n            }\n        }\n    }\n\n    code = code.trim();\n    \n    // Final Syntax Sanity: if it starts with ( and ends with ), strip them\n    if (code.startsWith('(') && code.endsWith(')')) {\n        code = code.substring(1, code.length - 1).trim();\n    }\n    \n    if (code.length < 20) throw new Error(\"Generated code is too short or invalid\");\n\n    // Save to Cache\n    try {\n        localStorage.setItem(cacheKey, code); // Using localStorage for consistency with read\n    } catch (e) {\n        console.warn(\"Failed to cache 3D code\", e);\n    }\n\n    aiMetricsService.logMetric({ model, operation: 'generateComponent3DCode', latencyMs: Date.now() - startTime, success: true });\n    return code;\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'generateComponent3DCode', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"3D Generation Error:\", error);\n    throw error;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/datasheets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/hud.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/media.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3528,3531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3528,3531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getAIClient, getApiKey, MODELS, APIError } from \"../client\";\nimport { PROMPTS } from \"../prompts\";\nimport { aiMetricsService } from \"../../aiMetricsService\";\nimport { Modality } from \"@google/genai\";\nimport { GoogleGenAI } from \"@google/genai\"; // Needed for local instantiation in generateConceptImage\n\nexport const transcribeAudio = async (audioBase64: string): Promise<string> => {\n  const startTime = Date.now();\n  const model = MODELS.AUDIO_TRANSCRIPTION;\n  const ai = getAIClient();\n  try {\n    const cleanBase64 = audioBase64.split(',')[1] || audioBase64;\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: [\n        {\n          parts: [\n            { inlineData: { mimeType: 'audio/wav', data: cleanBase64 } },\n            { text: PROMPTS.TRANSCRIBE_AUDIO }\n          ]\n        }\n      ]\n    });\n    aiMetricsService.logMetric({ model, operation: 'transcribeAudio', latencyMs: Date.now() - startTime, success: true });\n    return response.text || \"\";\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'transcribeAudio', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"Transcription Error\", error);\n    throw error;\n  }\n}\n\nexport const generateSpeech = async (text: string): Promise<string> => {\n  const ai = getAIClient();\n  try {\n    const response = await ai.models.generateContent({\n      model: MODELS.TTS,\n      contents: [{ parts: [{ text: text }] }],\n      config: {\n        responseModalities: [Modality.AUDIO],\n        speechConfig: {\n            voiceConfig: {\n              prebuiltVoiceConfig: { voiceName: 'Kore' },\n            },\n        },\n      },\n    });\n\n    const base64Audio = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;\n    if (!base64Audio) throw new Error(\"No audio generated\");\n    \n    return base64Audio;\n  } catch (error) {\n    console.error(\"TTS Error\", error);\n    throw error;\n  }\n}\n\nexport const generateEditedImage = async (\n  imageBase64: string, \n  prompt: string\n): Promise<string> => {\n  const ai = getAIClient();\n  try {\n    const cleanBase64 = imageBase64.replace(/^data:image\\/(png|jpeg|jpg|webp);base64,/, '');\n\n    const response = await ai.models.generateContent({\n      model: MODELS.IMAGE_GEN,\n      contents: {\n        parts: [\n          {\n            inlineData: {\n              data: cleanBase64,\n              mimeType: 'image/png', \n            },\n          },\n          {\n            text: prompt,\n          },\n        ],\n      },\n    });\n\n    for (const part of response.candidates?.[0]?.content?.parts || []) {\n      if (part.inlineData && part.inlineData.data) {\n        return part.inlineData.data;\n      }\n    }\n    \n    throw new Error(\"No image generated\");\n  } catch (error) {\n    console.error(\"Image Generation Error:\", error);\n    throw error;\n  }\n};\n\nexport const generateConceptImage = async (\n  prompt: string,\n  size: '1K' | '2K' | '4K',\n  aspectRatio: string = '16:9',\n  enableSearch: boolean = false\n): Promise<string> => {\n  const startTime = Date.now();\n  const model = MODELS.IMAGE_GEN;\n  \n  if (window.aistudio && typeof window.aistudio.hasSelectedApiKey === 'function') {\n    const hasKey = await window.aistudio.hasSelectedApiKey();\n    if (!hasKey) {\n      await window.aistudio.openSelectKey();\n    }\n  }\n\n  // Helper to execute request with error handling/retry\n  const executeRequest = async () => {\n    const apiKey = getApiKey();\n    const aiClient = new GoogleGenAI({ apiKey });\n    \n    const config: any = {\n        imageConfig: {\n          imageSize: size,\n          aspectRatio: aspectRatio,\n        },\n    };\n    \n    if (enableSearch) {\n        config.tools = [{ googleSearch: {} }];\n    }\n\n    return await aiClient.models.generateContent({\n      model: model,\n      contents: {\n        parts: [{ text: prompt }],\n      },\n      config: config,\n    });\n  };\n\n  try {\n    const result = (await executeRequest()).candidates?.[0]?.content?.parts?.[0]?.inlineData?.data || \"\";\n    aiMetricsService.logMetric({ model, operation: 'generateConceptImage', latencyMs: Date.now() - startTime, success: true });\n    return result;\n  } catch (error: unknown) {\n     aiMetricsService.logMetric({ model, operation: 'generateConceptImage', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n     // Handle Permission Denied (403) or Not Found\n    const apiError = error as APIError;\n    if (apiError.status === 403 || (apiError.message && (apiError.message.includes('403') || apiError.message.includes('PERMISSION_DENIED') || apiError.message.includes('not found')))) {\n      if (window.aistudio && typeof window.aistudio.openSelectKey === 'function') {\n        await window.aistudio.openSelectKey();\n        const retryResponse = await executeRequest();\n        return retryResponse.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data || \"\";\n      }\n    }\n    throw error;\n  }\n}\n\n// Generates a small 1K square image for thumbnails\nexport const generateComponentThumbnail = async (componentName: string, customPrompt?: string): Promise<string> => {\n    const prompt = PROMPTS.GENERATE_THUMBNAIL(componentName);\n    return await generateConceptImage(\n        customPrompt || prompt, \n        '1K', \n        '1:1',\n        true\n    );\n};\n\nexport const generateCircuitVideo = async (\n  prompt: string,\n  aspectRatio: '16:9' | '9:16',\n  imageBase64?: string\n): Promise<string> => {\n  if (window.aistudio && typeof window.aistudio.hasSelectedApiKey === 'function') {\n    const hasKey = await window.aistudio.hasSelectedApiKey();\n    if (!hasKey) {\n      await window.aistudio.openSelectKey();\n    }\n  }\n\n  const executeVideoRequest = async () => {\n    const apiKey = getApiKey();\n    const aiClient = new GoogleGenAI({ apiKey });\n    let imageParam = undefined;\n    if (imageBase64) {\n      const cleanBase64 = imageBase64.replace(/^data:image\\/(png|jpeg|jpg|webp);base64,/, '');\n      imageParam = {\n        imageBytes: cleanBase64,\n        mimeType: 'image/png',\n      };\n    }\n\n    let operation = await aiClient.models.generateVideos({\n      model: MODELS.VIDEO,\n      prompt: PROMPTS.GENERATE_VIDEO(prompt),\n      image: imageParam,\n      config: {\n        numberOfVideos: 1,\n        resolution: '720p',\n        aspectRatio: aspectRatio\n      }\n    });\n\n    while (!operation.done) {\n      await new Promise(resolve => setTimeout(resolve, 5000));\n      operation = await aiClient.operations.getVideosOperation({operation: operation});\n    }\n\n    const videoUri = operation.response?.generatedVideos?.[0]?.video?.uri;\n    if (!videoUri) throw new Error(\"Video generation failed to return a URI\");\n\n    return `${videoUri}&key=${apiKey}`;\n  };\n  \n  try {\n    return await executeVideoRequest();\n  } catch (error: unknown) {\n    const apiError = error as APIError;\n    if (apiError.status === 403 || (apiError.message && (apiError.message.includes('403') || apiError.message.includes('PERMISSION_DENIED')))) {\n      if (window.aistudio && typeof window.aistudio.openSelectKey === 'function') {\n        await window.aistudio.openSelectKey();\n        return await executeVideoRequest();\n      }\n    }\n    throw error;\n  }\n};\n\nexport const embedText = async (text: string): Promise<number[]> => {\n  const model = MODELS.EMBEDDING;\n  const ai = getAIClient();\n  try {\n    const result = await ai.models.embedContent({\n      model: model,\n      contents: [{ parts: [{ text }] }],\n    });\n    \n    if (result.embeddings?.[0]?.values) {\n        return result.embeddings[0].values;\n    }\n    throw new Error(\"No embedding returned\");\n  } catch (error) {\n    console.error(\"Embedding Error\", error);\n    throw error;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/predictions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[944,947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[944,947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getAIClient, MODELS } from '../client';\nimport { PROMPTS } from '../prompts';\nimport { AIContext } from '../../../types';\nimport { PredictiveAction } from '../../predictionEngine';\n\n/**\n * Generates AI-powered design predictions based on full workspace context.\n */\nexport const generatePredictions = async (context: AIContext): Promise<PredictiveAction[]> => {\n  const genAI = getAIClient();\n  const contextStr = JSON.stringify(context);\n  const prompt = PROMPTS.GENERATE_PREDICTIONS(contextStr);\n\n  try {\n    const result = await genAI.models.generateContent({\n      model: MODELS.PART_FINDER,\n      contents: [{ role: 'user', parts: [{ text: prompt }] }],\n      config: {\n        temperature: 0.3,\n        responseMimeType: \"application/json\",\n      }\n    });\n    \n    const response = result.text || '[]';\n    const parsed = JSON.parse(response);\n    \n    // Transform payloadJson strings back to objects\n    return parsed.map((p: any) => ({\n      ...p,\n      action: {\n        ...p.action,\n        payload: JSON.parse(p.action.payloadJson)\n      }\n    }));\n  } catch (error) {\n    console.error('Prediction generation failed:', error);\n    return [];\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/simulation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/suggestions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/versioning.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/wiring.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/parsers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ParsedAIResponse' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ActionIntent, ActionType, ComponentReference } from \"../../types\";\nimport { ParsedAIResponse, AISuggestedAction, AIComponentMention } from \"./types\";\n\n/**\n * Normalizes proactive suggestions from AI response\n */\nexport const normalizeProactiveSuggestions = (input: unknown): string[] => {\n  if (!Array.isArray(input)) return [];\n\n  const normalized = input\n    .map((item) => {\n      if (typeof item === 'string') return item.trim();\n      if (item && typeof item === 'object' && 'label' in item) {\n        const label = (item as { label?: unknown }).label;\n        if (typeof label === 'string') return label.trim();\n      }\n      return null;\n    })\n    .filter((item): item is string => Boolean(item && item.length > 0));\n\n  return normalized.slice(0, 3);\n};\n\n/**\n * Parses raw JSON text from AI response, handling common formatting issues\n */\nexport const parseJSONResponse = <T>(text: string): T => {\n    try {\n        // Remove markdown code blocks if present\n        const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();\n        return JSON.parse(cleanText) as T;\n    } catch (error) {\n        // Basic fallback if strict JSON parse fails? \n        // For now, re-throw so the caller can handle or default\n        throw new Error(`Failed to parse AI JSON response: ${String(error)}`);\n    }\n};\n\n/**\n * Extracts component mentions from parsed AI response\n */\nexport const extractComponentMentions = (\n    parsedMentions: AIComponentMention[] | undefined,\n    messageText: string\n): ComponentReference[] => {\n    return (parsedMentions || []).map((m) => {\n        const name = m.componentName || '';\n        const lowerMessage = messageText.toLowerCase();\n        const lowerName = name.toLowerCase();\n        const idx = lowerName ? lowerMessage.indexOf(lowerName) : -1;\n        return {\n            componentId: m.componentId,\n            componentName: name,\n            mentionStart: idx >= 0 ? idx : 0,\n            mentionEnd: idx >= 0 ? idx + name.length : 0,\n        };\n    });\n};\n\n/**\n * Extracts and normalizes suggested actions from parsed AI response\n */\nexport const extractSuggestedActions = (\n    parsedActions: AISuggestedAction[] | undefined\n): ActionIntent[] => {\n    return (parsedActions || []).map((a) => {\n        let payload = {};\n        if (a.payloadJson) {\n            try {\n                // LLMs sometimes output escaped JSON or include extra quotes\n                const cleanJson = a.payloadJson.replace(/^`+|`+$/g, '').trim();\n                payload = JSON.parse(cleanJson);\n            } catch (_e) {\n                console.warn('Failed to parse payloadJson:', a.payloadJson);\n                // If it looks like a simple string, maybe it was meant to be a component ID?\n                if (typeof a.payloadJson === 'string' && a.payloadJson.length < 50 && !a.payloadJson.includes('{')) {\n                    payload = { componentId: a.payloadJson };\n                }\n            }\n        } else if (a.payload) {\n            // Fallback for legacy format\n            payload = a.payload;\n        }\n        return {\n            type: a.type as ActionType,\n            label: a.label,\n            payload,\n            safe: a.safe ?? false,\n        };\n    });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/prompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/geminiService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gesture/GestureEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[188,191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[188,191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface HandLandmark {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport interface GestureResult {\n  landmarks: HandLandmark[][];\n  worldLandmarks: HandLandmark[][];\n  handedness: any[][];\n  timestamp: number;\n}\n\ntype GestureListener = (result: GestureResult) => void;\n\nclass GestureEngine {\n  private worker: Worker | null = null;\n  private listeners: Set<GestureListener> = new Set();\n  private isInitialized = false;\n  private isProcessing = false;\n\n  async init(): Promise<void> {\n    if (this.isInitialized) return;\n    console.log('GestureEngine: Starting worker initialization...');\n\n    return new Promise((resolve, reject) => {\n      try {\n        // Load the worker as a classic script because MediaPipe bundles use importScripts internally\n        this.worker = new Worker('/assets/mediapipe/gestureWorker.js');\n        \n        const timeout = setTimeout(() => {\n          if (!this.isInitialized) {\n            console.error('GestureEngine: Initialization timed out');\n            reject(new Error('Gesture tracking initialization timed out.'));\n          }\n        }, 15000); // 15s timeout for model loading\n\n        this.worker.onmessage = (event) => {\n          const { type, payload } = event.data;\n\n          if (type === 'INIT_COMPLETE') {\n            console.log('GestureEngine: Worker initialized successfully');\n            this.isInitialized = true;\n            clearTimeout(timeout);\n            resolve();\n          } else if (type === 'LANDMARKS') {\n            this.listeners.forEach(l => l(payload));\n            this.isProcessing = false;\n          } else if (type === 'ERROR') {\n            console.error('Gesture Worker Error:', payload);\n            this.isProcessing = false;\n            if (!this.isInitialized) {\n              clearTimeout(timeout);\n              reject(new Error(payload));\n            }\n          }\n        };\n\n        this.worker.onerror = (e) => {\n          console.error('Gesture Worker Critical Error:', e);\n          clearTimeout(timeout);\n          reject(new Error('Gesture worker failed to load. Check console for details.'));\n        };\n\n        this.worker.postMessage({ type: 'INIT' });\n      } catch (err) {\n        console.error('GestureEngine: Failed to create worker', err);\n        reject(err);\n      }\n    });\n  }\n\n  onLandmarks(listener: GestureListener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  async processFrame(video: HTMLVideoElement) {\n    if (!this.isInitialized || !this.worker || this.isProcessing) return;\n\n    // Use OffscreenCanvas or ImageBitmap for efficiency\n    try {\n      const imageBitmap = await createImageBitmap(video);\n      this.isProcessing = true;\n      this.worker.postMessage({\n        type: 'PROCESS_FRAME',\n        payload: {\n          imageBitmap,\n          timestamp: performance.now()\n        }\n      }, [imageBitmap]); // Transfer the bitmap to the worker\n    } catch (e) {\n      console.warn('Frame capture failed', e);\n    }\n  }\n\n  dispose() {\n    this.worker?.terminate();\n    this.worker = null;\n    this.listeners.clear();\n    this.isInitialized = false;\n  }\n}\n\nexport const gestureEngine = new GestureEngine();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gesture/GestureMetricsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[228,231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[228,231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { storageService } from '../storage';\n\nexport interface GestureMetric {\n  id: string;\n  timestamp: number;\n  gestureType: string;\n  confidence: number;\n  success: boolean;\n  latencyMs: number;\n  metadata?: Record<string, any>;\n}\n\nclass GestureMetricsService {\n  private metrics: GestureMetric[] = [];\n  private readonly MAX_LOCAL_METRICS = 100;\n\n  async logMetric(metric: Omit<GestureMetric, 'id' | 'timestamp'>) {\n    const newMetric: GestureMetric = {\n      ...metric,\n      id: crypto.randomUUID(),\n      timestamp: Date.now()\n    };\n\n    this.metrics.push(newMetric);\n    \n    // Periodically save to storage\n    if (this.metrics.length >= 10) {\n      await this.flush();\n    }\n  }\n\n  async flush() {\n    if (this.metrics.length === 0) return;\n    \n    try {\n      const existing = await storageService.getItem('cm_gesture_metrics') || '[]';\n      const parsed = JSON.parse(existing);\n      const updated = [...parsed, ...this.metrics].slice(-this.MAX_LOCAL_METRICS);\n      \n      await storageService.setItem('cm_gesture_metrics', JSON.stringify(updated));\n      this.metrics = [];\n    } catch (e) {\n      console.error('Failed to flush gesture metrics', e);\n    }\n  }\n\n  async getSummary() {\n    try {\n      const data = await storageService.getItem('cm_gesture_metrics') || '[]';\n      const parsed: GestureMetric[] = JSON.parse(data);\n      \n      if (parsed.length === 0) return null;\n      \n      const successCount = parsed.filter(m => m.success).length;\n      const avgLatency = parsed.reduce((sum, m) => sum + m.latencyMs, 0) / parsed.length;\n      \n      return {\n        totalActions: parsed.length,\n        accuracy: (successCount / parsed.length) * 100,\n        averageLatency: avgLatency\n      };\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport const gestureMetricsService = new GestureMetricsService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gitService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/healthMonitor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[893,896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[893,896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface HealthMetrics {\n  fps: number;\n  memoryUsed: number; // MB\n  memoryLimit: number; // MB\n  aiLatency: number; // ms (last request)\n  status: 'healthy' | 'warning' | 'critical';\n}\n\nclass HealthMonitor {\n  private frameCount = 0;\n  private lastTime = performance.now();\n  private fps = 60;\n  private aiLatency = 0;\n\n  constructor() {\n    this.startFPSLoop();\n  }\n\n  private startFPSLoop() {\n    const loop = () => {\n      this.frameCount++;\n      const time = performance.now();\n      if (time >= this.lastTime + 1000) {\n        this.fps = Math.round((this.frameCount * 1000) / (time - this.lastTime));\n        this.frameCount = 0;\n        this.lastTime = time;\n      }\n      requestAnimationFrame(loop);\n    };\n    requestAnimationFrame(loop);\n  }\n\n  recordAiLatency(ms: number) {\n    this.aiLatency = ms;\n  }\n\n  getMetrics(): HealthMetrics {\n    const memory = (performance as any).memory;\n    const memoryUsed = memory ? Math.round(memory.usedJSHeapSize / 1048576) : 0;\n    const memoryLimit = memory ? Math.round(memory.jsHeapLimit / 1048576) : 0;\n\n    let status: HealthMetrics['status'] = 'healthy';\n    if (this.fps < 30 || (memoryLimit > 0 && memoryUsed / memoryLimit > 0.8)) {\n      status = 'warning';\n    }\n    if (this.fps < 15 || (memoryLimit > 0 && memoryUsed / memoryLimit > 0.95)) {\n      status = 'critical';\n    }\n\n    return {\n      fps: this.fps,\n      memoryUsed,\n      memoryLimit,\n      aiLatency: this.aiLatency,\n      status\n    };\n  }\n}\n\nexport const healthMonitor = new HealthMonitor();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/knowledgeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/liveAudio.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":216,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7680,7683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7680,7683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GoogleGenAI, LiveServerMessage, Modality, Part } from \"@google/genai\";\nimport { MODELS } from \"./gemini/client\";\n\n// Type for webkit prefixed AudioContext (Safari compatibility)\ntype WebkitAudioContext = typeof AudioContext;\ndeclare global {\n  interface Window {\n    webkitAudioContext?: WebkitAudioContext;\n  }\n}\n\n// Extended type for Gemini Live session to support media\ninterface ExtendedSession {\n  sendRealtimeInput: (input: { media: { data: string; mimeType: string } }) => void;\n  sendMedia?: (media: Part[]) => void; // Optional if SDK differs\n  close: () => void;\n}\n\n// Audio configuration constants\nconst INPUT_SAMPLE_RATE = 16000;\nconst OUTPUT_SAMPLE_RATE = 24000;\nconst MODEL_NAME = MODELS.AUDIO_REALTIME;\n\n// Helper for Base64 encoding/decoding\nfunction encode(bytes: Uint8Array) {\n  let binary = '';\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n\nfunction decode(base64: string) {\n  const binaryString = atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\n\n// Convert Float32 audio from microphone to PCM16 Base64 for the model\nfunction pcm16BlobFromFloat32(data: Float32Array): { data: string; mimeType: string } {\n  const l = data.length;\n  const int16 = new Int16Array(l);\n  for (let i = 0; i < l; i++) {\n    // Clamp values\n    const s = Math.max(-1, Math.min(1, data[i]));\n    int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n  }\n  return {\n    data: encode(new Uint8Array(int16.buffer)),\n    mimeType: 'audio/pcm;rate=16000',\n  };\n}\n\n// Decode Raw PCM16 Base64 from model to AudioBuffer for playback\nasync function audioBufferFromPcm16(\n  base64Data: string,\n  ctx: AudioContext\n): Promise<AudioBuffer> {\n  const bytes = decode(base64Data);\n  const dataInt16 = new Int16Array(bytes.buffer);\n  const frameCount = dataInt16.length;\n  const buffer = ctx.createBuffer(1, frameCount, OUTPUT_SAMPLE_RATE);\n  const channelData = buffer.getChannelData(0);\n\n  for (let i = 0; i < frameCount; i++) {\n    channelData[i] = dataInt16[i] / 32768.0;\n  }\n  return buffer;\n}\n\n// Convert Blob to Base64 string for sending image data\nasync function blobToBase64(blob: Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const result = reader.result as string;\n      // Remove the data URL prefix (e.g., \"data:image/png;base64,\")\n      resolve(result.split(',')[1]);\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\nexport class LiveSession {\n  private ai: GoogleGenAI;\n  private inputContext: AudioContext | null = null;\n  private outputContext: AudioContext | null = null;\n  private stream: MediaStream | null = null;\n  private processor: ScriptProcessorNode | null = null;\n  private source: MediaStreamAudioSourceNode | null = null;\n  private outputNode: GainNode | null = null;\n  private session: ExtendedSession | null = null;\n  private nextStartTime = 0;\n  private audioSources = new Set<AudioBufferSourceNode>();\n  private onStatusChange: (status: string) => void;\n  private visualContextInterval: NodeJS.Timeout | null = null;\n  private visualContextProviders: (() => Promise<Blob | null>)[] = [];\n\n  constructor(onStatusChange: (status: string) => void) {\n    this.ai = new GoogleGenAI({ apiKey: process.env.API_KEY });\n    this.onStatusChange = onStatusChange;\n  }\n\n  // Method to set the function that captures the canvas snapshot\n  setVisualContextProviders(providers: (() => Promise<Blob | null>)[]) {\n    this.visualContextProviders = providers;\n  }\n\n  async connect() {\n    try {\n      this.onStatusChange('connecting');\n\n      // Initialize Audio Contexts\n      const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n      if (!AudioContextClass) throw new Error('AudioContext not supported');\n      this.inputContext = new AudioContextClass({ sampleRate: INPUT_SAMPLE_RATE });\n      this.outputContext = new AudioContextClass({ sampleRate: OUTPUT_SAMPLE_RATE });\n\n      this.outputNode = this.outputContext.createGain();\n      this.outputNode.connect(this.outputContext.destination);\n\n      // Get User Media\n      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n      // Connect to Gemini Live\n      const sessionPromise = this.ai.live.connect({\n        model: MODEL_NAME,\n        config: {\n          // Include audio modality by default\n          responseModalities: [Modality.AUDIO],\n          speechConfig: {\n            voiceConfig: { prebuiltVoiceConfig: { voiceName: 'Kore' } },\n          },\n          // System instruction to guide the AI's persona and task\n          systemInstruction:\n            'You are CircuitMind, an advanced electronics AI assistant. Be concise, helpful, and technical. You are talking to a user building circuits. ALWAYS refer to the visual context provided. We may provide multiple images (e.g. digital diagram and physical camera feed). Use them to answer user questions about alignment, missing parts, or physical layout.',\n        },\n        callbacks: {\n          onopen: () => {\n            this.onStatusChange('active');\n            // Cast promise result to ExtendedSession\n            this.startAudioInput(sessionPromise as unknown as Promise<ExtendedSession>);\n            this.startVisualContextStream(sessionPromise as unknown as Promise<ExtendedSession>);\n          },\n          onmessage: async (message: LiveServerMessage) => {\n            this.handleServerMessage(message);\n          },\n          onclose: () => {\n            this.onStatusChange('disconnected');\n            this.cleanup();\n          },\n          onerror: (e) => {\n            console.error(e);\n            this.onStatusChange('error');\n            this.cleanup();\n          },\n        },\n      });\n\n      this.session = (await sessionPromise) as unknown as ExtendedSession;\n    } catch (error) {\n      console.error('Failed to connect live session', error);\n      this.onStatusChange('error');\n      this.cleanup();\n    }\n  }\n\n  private startAudioInput(sessionPromise: Promise<ExtendedSession>) {\n    if (!this.inputContext || !this.stream) return;\n\n    this.source = this.inputContext.createMediaStreamSource(this.stream);\n    // Use ScriptProcessor for raw audio access\n    this.processor = this.inputContext.createScriptProcessor(4096, 1, 1);\n\n    // Cache the resolved session to avoid .then() overhead in every chunk\n    let activeSession: ExtendedSession | null = null;\n    sessionPromise.then(s => activeSession = s);\n\n    this.processor.onaudioprocess = (e) => {\n      const inputData = e.inputBuffer.getChannelData(0);\n      const pcmBlob = pcm16BlobFromFloat32(inputData);\n\n      if (activeSession) {\n        activeSession.sendRealtimeInput({ media: pcmBlob });\n      }\n    };\n\n    this.source.connect(this.processor);\n    this.processor.connect(this.inputContext.destination);\n  }\n\n  private startVisualContextStream(sessionPromise: Promise<ExtendedSession>) {\n    if (this.visualContextProviders.length === 0) {\n      console.warn('No visual context providers set. Cannot stream visuals.');\n      return;\n    }\n\n    // Send visual context every 5 seconds\n    this.visualContextInterval = setInterval(async () => {\n      try {\n        const scheduleSnapshot = (callback: () => void) => {\n          if ('requestIdleCallback' in window) {\n            window.requestIdleCallback(callback);\n          } else {\n            setTimeout(callback, 100);\n          }\n        };\n\n        scheduleSnapshot(async () => {\n          const mediaParts: any[] = [];\n          \n          for (const provider of this.visualContextProviders) {\n            const blob = await provider();\n            if (blob) {\n              const base64Image = await blobToBase64(blob);\n              mediaParts.push({\n                inlineData: {\n                  mimeType: 'image/jpeg',\n                  data: base64Image\n                }\n              });\n            }\n          }\n\n          if (mediaParts.length > 0) {\n            sessionPromise.then((session) => {\n              if (typeof session.sendMedia === 'function') {\n                  session.sendMedia(mediaParts);\n              }\n            });\n          }\n        });\n      } catch (error) {\n        console.error('Failed to capture or send visual snapshots:', error);\n      }\n    }, 5000); \n  }\n\n  private async handleServerMessage(message: LiveServerMessage) {\n    const serverContent = message.serverContent;\n\n    if (serverContent?.interrupted) {\n      this.audioSources.forEach((source) => source.stop());\n      this.audioSources.clear();\n      this.nextStartTime = 0;\n      return;\n    }\n\n    const base64Audio = serverContent?.modelTurn?.parts?.[0]?.inlineData?.data;\n\n    if (base64Audio && this.outputContext && this.outputNode) {\n      const audioBuffer = await audioBufferFromPcm16(base64Audio, this.outputContext);\n\n      this.nextStartTime = Math.max(this.outputContext.currentTime, this.nextStartTime);\n\n      const source = this.outputContext.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(this.outputNode);\n      source.start(this.nextStartTime);\n\n      this.nextStartTime += audioBuffer.duration;\n\n      this.audioSources.add(source);\n      source.onended = () => {\n        this.audioSources.delete(source);\n      };\n    }\n  }\n\n  async disconnect() {\n    if (this.session) {\n      try {\n        if (typeof this.session.close === 'function') {\n          this.session.close();\n        }\n      } catch (_e) { /* ignore */ }\n    }\n    this.cleanup();\n    this.onStatusChange('disconnected');\n  }\n\n  private cleanup() {\n    this.stream?.getTracks().forEach((track) => track.stop());\n    this.processor?.disconnect();\n    this.source?.disconnect();\n    this.inputContext?.close();\n\n    if (this.visualContextInterval) {\n      clearInterval(this.visualContextInterval);\n      this.visualContextInterval = null;\n    }\n\n    this.audioSources.forEach((source) => source.stop());\n    this.audioSources.clear();\n    this.outputContext?.close();\n\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.inputContext = null;\n    this.outputContext = null;\n    this.session = null;\n    this.getCanvasSnapshot = null;\n    this.nextStartTime = 0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/localization/i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/localization/unitConverter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/logging/auditService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/macroEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[573,576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[573,576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ActionIntent } from '../types';\n\nexport interface WorkflowStep {\n  id: string;\n  action: ActionIntent;\n  description: string;\n  delay?: number; // ms\n}\n\nexport interface MacroWorkflow {\n  id: string;\n  name: string;\n  steps: WorkflowStep[];\n  author: 'user' | 'ai' | 'system';\n  created: number;\n}\n\nexport type ExecutionProgress = (stepIndex: number, total: number) => void;\n\nclass MacroEngine {\n  /**\n   * Executes a sequence of actions with optional delays.\n   */\n  async execute(\n    steps: WorkflowStep[], \n    executeAction: (action: ActionIntent) => Promise<any>,\n    onProgress?: ExecutionProgress\n  ): Promise<void> {\n    for (let i = 0; i < steps.length; i++) {\n      const step = steps[i];\n      \n      if (onProgress) onProgress(i, steps.length);\n      \n      await executeAction(step.action);\n      \n      if (step.delay) {\n        await new Promise(resolve => setTimeout(resolve, step.delay));\n      }\n    }\n  }\n}\n\nexport const macroEngine = new MacroEngine();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/peerDiscoveryService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":14,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1209,1212],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1209,1212],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":56,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PeerNode } from './syncService';\n\nclass PeerDiscoveryService {\n  private peers: PeerNode[] = [];\n\n  constructor() {\n    this.loadPeers();\n  }\n\n  private loadPeers() {\n    try {\n      const saved = localStorage.getItem('cm_peers');\n      if (saved) this.peers = JSON.parse(saved);\n    } catch (e) {\n      this.peers = [];\n    }\n  }\n\n  private savePeers() {\n    localStorage.setItem('cm_peers', JSON.stringify(this.peers));\n  }\n\n  getPeers(): PeerNode[] {\n    return this.peers;\n  }\n\n  addPeer(ip: string, name: string): PeerNode {\n    const newPeer: PeerNode = {\n      deviceId: `device-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      lastIp: ip,\n      pairingStatus: 'pending',\n      lastSyncHash: ''\n    };\n    \n    this.peers.push(newPeer);\n    this.savePeers();\n    return newPeer;\n  }\n\n  removePeer(deviceId: string) {\n    this.peers = this.peers.filter(p => p.deviceId !== deviceId);\n    this.savePeers();\n  }\n\n  /**\n   * Pings all known peers to see who is online.\n   */\n  async discover() {\n    const onlinePeers: PeerNode[] = [];\n    \n    for (const peer of this.peers) {\n      try {\n        const response = await fetch(`http://${peer.lastIp}:3000/ping`, { timeout: 2000 } as any);\n        if (response.ok) onlinePeers.push(peer);\n      } catch (e) {\n        // Peer offline\n      }\n    }\n    \n    return onlinePeers;\n  }\n}\n\nexport const peerDiscoveryService = new PeerDiscoveryService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/predictionEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/ragService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/responseParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/search/searchIndexer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/securityAuditor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ElectronicComponent' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WiringDiagram, ElectronicComponent } from '../types';\n\nexport type Severity = 'low' | 'medium' | 'high' | 'critical';\n\nexport interface SecurityViolation {\n  id: string;\n  type: 'code_injection' | 'electrical_safety' | 'privacy_risk' | 'api_exposure';\n  severity: Severity;\n  location: string;\n  message: string;\n  remedy: string;\n}\n\nclass SecurityAuditor {\n  private blockedTokens = [\n    'fetch', 'XMLHttpRequest', 'WebSocket', 'window.location', \n    'localStorage', 'sessionStorage', 'document.cookie', \n    'process.env', 'eval', 'Function', 'setTimeout', 'setInterval'\n  ];\n\n  /**\n   * Scans generated code for potential injection or privacy risks.\n   */\n  scanAIGeneratedCode(code: string): SecurityViolation[] {\n    const violations: SecurityViolation[] = [];\n    \n    this.blockedTokens.forEach(token => {\n      if (code.includes(token)) {\n        violations.push({\n          id: `sec-${crypto.randomUUID().substring(0, 8)}`,\n          type: 'code_injection',\n          severity: 'critical',\n          location: 'threeCode',\n          message: `Forbidden token detected: \"${token}\"`,\n          remedy: 'Remove external network or storage access from the 3D generation logic.'\n        });\n      }\n    });\n\n    return violations;\n  }\n\n  /**\n   * Audits a wiring diagram for physical safety risks.\n   */\n  auditCircuitSafety(diagram: WiringDiagram | null): SecurityViolation[] {\n    const violations: SecurityViolation[] = [];\n    if (!diagram) return violations;\n\n    // 1. Check for VCC-GND Short\n    diagram.connections.forEach((conn, idx) => {\n      const fromPin = conn.fromPin.toUpperCase();\n      const toPin = conn.toPin.toUpperCase();\n      \n      const isPower = (p: string) => p === 'VCC' || p === '5V' || p === '3.3V' || p === 'VIN';\n      const isGround = (p: string) => p === 'GND' || p === 'GROUND';\n\n      if ((isPower(fromPin) && isGround(toPin)) || (isGround(fromPin) && isPower(toPin))) {\n        violations.push({\n          id: `elec-${idx}`,\n          type: 'electrical_safety',\n          severity: 'high',\n          location: `Connection ${idx}`,\n          message: 'Direct Short Circuit detected between Power and Ground.',\n          remedy: 'Remove this connection immediately to prevent hardware damage.'\n        });\n      }\n    });\n\n    return violations;\n  }\n}\n\nexport const securityAuditor = new SecurityAuditor();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/serialService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readableStreamClosed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":74,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Serial Communication Service\n * \n * Handles Web Serial API interactions to read data from physical microcontrollers.\n */\n\nexport interface TelemetryPacket {\n  componentId: string;\n  pin?: string;\n  value: string | number | boolean;\n  unit?: string;\n  timestamp: number;\n}\n\nexport interface SerialOptions {\n  baudRate: number;\n}\n\ninterface SerialPort {\n  open: (options: SerialOptions) => Promise<void>;\n  close: () => Promise<void>;\n  readable: ReadableStream<Uint8Array>;\n  writable: WritableStream<Uint8Array>;\n}\n\nclass SerialService {\n  private port: SerialPort | null = null;\n  private reader: ReadableStreamDefaultReader<string> | null = null;\n  private onDataCallback: ((packet: TelemetryPacket) => void) | null = null;\n  private onRawDataCallback: ((data: string) => void) | null = null;\n  private isReading: boolean = false;\n\n  /**\n   * Request access to a serial port from the user.\n   */\n  async requestPort(): Promise<boolean> {\n    try {\n      if (!('serial' in navigator)) {\n        throw new Error('Web Serial API not supported in this browser.');\n      }\n      this.port = await (navigator as unknown as { serial: { requestPort: () => Promise<SerialPort> } }).serial.requestPort();\n      return true;\n    } catch (e) {\n      console.error('Serial port request failed:', e);\n      return false;\n    }\n  }\n\n  /**\n   * Open the requested port and start the read loop.\n   */\n  async openPort(options: SerialOptions = { baudRate: 115200 }): Promise<void> {\n    if (!this.port) {\n      const success = await this.requestPort();\n      if (!success) return;\n    }\n\n    try {\n      await this.port.open({ baudRate: options.baudRate });\n      this.isReading = true;\n      this.readLoop();\n    } catch (e) {\n      console.error('Failed to open serial port:', e);\n      throw e;\n    }\n  }\n\n  /**\n   * Background loop to read serial data.\n   */\n  private async readLoop() {\n    while (this.port?.readable && this.isReading) {\n      const textDecoder = new TextDecoderStream();\n      const readableStreamClosed = this.port.readable.pipeTo(textDecoder.writable);\n      this.reader = textDecoder.readable.getReader();\n\n      try {\n        let buffer = '';\n        while (true) {\n          const { value, done } = await this.reader.read();\n          if (done) break;\n          if (value) {\n            buffer += value;\n            // Process complete lines\n            if (buffer.includes('\\n')) {\n              const lines = buffer.split('\\n');\n              buffer = lines.pop() || ''; // Keep partial line in buffer\n              for (const line of lines) {\n                this.processLine(line.trim());\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Serial read error:', error);\n        break;\n      } finally {\n        this.reader.releaseLock();\n      }\n    }\n  }\n\n  /**\n   * Parse a single line of serial data into a telemetry packet.\n   */\n  private processLine(line: string) {\n    if (!line) return;\n    \n    if (this.onRawDataCallback) {\n      this.onRawDataCallback(line);\n    }\n\n    // Protocol Parser:\n    // Pattern 1: \"COMP_ID:PIN:VALUE\" (e.g. \"esp32:13:1\")\n    // Pattern 2: \"PIN:VALUE\" (e.g. \"13:HIGH\")\n    // Pattern 3: \"KEY=VALUE\" (e.g. \"TEMP=24.5\")\n    \n    let packet: TelemetryPacket | null = null;\n\n    if (line.includes(':')) {\n      const parts = line.split(':');\n      if (parts.length === 3) {\n        packet = {\n          componentId: parts[0],\n          pin: parts[1],\n          value: parts[2],\n          timestamp: Date.now()\n        };\n      } else if (parts.length === 2) {\n        packet = {\n          componentId: 'auto', // Context-aware mapping will handle this\n          pin: parts[0],\n          value: parts[1],\n          timestamp: Date.now()\n        };\n      }\n    } else if (line.includes('=')) {\n      const [key, val] = line.split('=');\n      packet = {\n        componentId: 'auto',\n        pin: key.trim(),\n        value: val.trim(),\n        timestamp: Date.now()\n      };\n    }\n\n    if (packet && this.onDataCallback) {\n      this.onDataCallback(packet);\n    }\n  }\n\n  /**\n   * Register callback for parsed telemetry packets.\n   */\n  onData(callback: (packet: TelemetryPacket) => void) {\n    this.onDataCallback = callback;\n  }\n\n  /**\n   * Register callback for raw serial strings (for terminal).\n   */\n  onRawData(callback: (data: string) => void) {\n    this.onRawDataCallback = callback;\n  }\n\n  /**\n   * Close the connection and stop the loop.\n   */\n  async close() {\n    this.isReading = false;\n    if (this.reader) {\n      await this.reader.cancel();\n    }\n    if (this.port) {\n      await this.port.close();\n    }\n  }\n}\n\nexport const serialService = new SerialService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/simulationEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ElectronicComponent' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WiringDiagram, WireConnection, ElectronicComponent } from '../types';\n\n/**\n * SimNodeState represents the electrical state of a single pin or net.\n */\nexport interface SimNodeState {\n  voltage: number;\n  current: number;\n  logicState: 'HIGH' | 'LOW' | 'FLOATING' | 'ERROR';\n}\n\n/**\n * SimulationResult contains the state of all pins in the diagram.\n */\nexport interface SimulationResult {\n  pinStates: Record<string, SimNodeState>; // Key: \"componentId:pin\"\n  isShortCircuit: boolean;\n  warnings: string[];\n}\n\n/**\n * SimulationEngine performs a lightweight DC nodal analysis and logic propagation.\n */\nclass SimulationEngine {\n  /**\n   * Run one tick of the simulation.\n   */\n  solve(diagram: WiringDiagram): SimulationResult {\n    const pinStates: Record<string, SimNodeState> = {};\n    const isShortCircuit = false;\n    const warnings: string[] = [];\n\n    // 1. Initialize all pins to FLOATING\n    diagram.components.forEach(comp => {\n      comp.pins?.forEach(pin => {\n        pinStates[`${comp.id}:${pin}`] = {\n          voltage: 0,\n          current: 0,\n          logicState: 'FLOATING'\n        };\n      });\n    });\n\n    // 2. Identify Nets (connected pins)\n    const nets = this.buildNets(diagram.connections);\n\n    // 3. Set Power Sources\n    diagram.components.forEach(comp => {\n      if (comp.type === 'power') {\n        const vccPin = comp.pins?.find(p => p.toUpperCase() === 'VCC' || p.toUpperCase() === 'VIN' || p === '5V' || p === '3V3');\n        const gndPin = comp.pins?.find(p => p.toUpperCase() === 'GND');\n\n        if (vccPin) {\n          const voltage = comp.name.includes('3.3V') ? 3.3 : 5.0;\n          this.propagateNet(vccPin, comp.id, voltage, 'HIGH', nets, pinStates);\n        }\n        if (gndPin) {\n          this.propagateNet(gndPin, comp.id, 0, 'LOW', nets, pinStates);\n        }\n      }\n    });\n\n    // 4. Check for Short Circuits (VCC connected directly to GND)\n    // This is simplified: check if any net has both 5V and 0V sources\n    // In a real solver, this would be a low resistance path.\n\n    return { pinStates, isShortCircuit, warnings };\n  }\n\n  private buildNets(connections: WireConnection[]): Map<string, string[]> {\n    const nets = new Map<string, string[]>();\n    \n    connections.forEach(conn => {\n      const p1 = `${conn.fromComponentId}:${conn.fromPin}`;\n      const p2 = `${conn.toComponentId}:${conn.toPin}`;\n      \n      if (!nets.has(p1)) nets.set(p1, []);\n      if (!nets.has(p2)) nets.set(p2, []);\n      \n      nets.get(p1)!.push(p2);\n      nets.get(p2)!.push(p1);\n    });\n\n    return nets;\n  }\n\n  private propagateNet(\n    startPin: string, \n    compId: string, \n    voltage: number, \n    logic: 'HIGH' | 'LOW',\n    nets: Map<string, string[]>,\n    states: Record<string, SimNodeState>\n  ) {\n    const visited = new Set<string>();\n    const stack = [`${compId}:${startPin}`];\n\n    while (stack.length > 0) {\n      const current = stack.pop()!;\n      if (visited.has(current)) continue;\n      visited.add(current);\n\n      if (states[current]) {\n        // If already set to a different voltage, we have a problem (simplified)\n        if (states[current].logicState !== 'FLOATING' && states[current].logicState !== logic) {\n          states[current].logicState = 'ERROR';\n        } else {\n          states[current].voltage = voltage;\n          states[current].logicState = logic;\n        }\n      }\n\n      const neighbors = nets.get(current) || [];\n      neighbors.forEach(n => stack.push(n));\n    }\n  }\n}\n\nexport const simulationEngine = new SimulationEngine();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/standardsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[455,458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[455,458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ipcData from '../assets/standards/ipc_dimensions.json';\n\nexport interface IPCPackage {\n  body_width: number;\n  body_length: number;\n  height: number;\n  pitch?: number;\n  pin_count: number;\n  pin_type: 'gullwing' | 'through-hole' | 'chip';\n}\n\nexport interface BoardComponentMap {\n  name: string;\n  width: number;\n  length: number;\n  components: {\n    type: string;\n    name: string;\n    x: number;\n    z: number;\n    rotation?: number;\n    params?: any;\n  }[];\n}\n\nconst BOARD_MAPS: Record<string, BoardComponentMap> = {\n  \"ARDUINO-UNO-R3\": {\n    name: \"Arduino Uno R3\",\n    width: 68.6,\n    length: 53.3,\n    components: [\n      { type: 'MCU', name: 'ATmega328P', x: 15, z: 0, params: { type: 'DIP-28' } },\n      { type: 'USB', name: 'USB-B', x: -28, z: 15, rotation: Math.PI / 2 },\n      { type: 'DC', name: 'Barrel Jack', x: -28, z: -15, rotation: Math.PI / 2 },\n      { type: 'HEADER', name: 'Digital', x: 10, z: 24, params: { count: 10, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Digital Low', x: -15, z: 24, params: { count: 8, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Analog', x: 15, z: -24, params: { count: 6, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Power', x: -10, z: -24, params: { count: 8, pitch: 2.54 } },\n      { type: 'OSCILLATOR', name: '16MHz', x: -5, z: 5 },\n      { type: 'BUTTON', name: 'Reset', x: -30, z: 22 },\n    ]\n  },\n  \"ESP32-WROOM-32\": {\n    name: \"ESP32 DevKit V1\",\n    width: 28.0,\n    length: 54.6,\n    components: [\n      { type: 'CHIP', name: 'ESP32-WROOM', x: 0, z: -15, params: { width: 18, length: 25.5, height: 3 } },\n      { type: 'USB', name: 'Micro-USB', x: 0, z: 25, rotation: 0 },\n      { type: 'HEADER', name: 'Left Pins', x: -12, z: 0, params: { count: 15, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Right Pins', x: 12, z: 0, params: { count: 15, pitch: 2.54 } },\n      { type: 'BUTTON', name: 'EN', x: -8, z: 20 },\n      { type: 'BUTTON', name: 'BOOT', x: 8, z: 20 },\n    ]\n  },\n  \"RASPBERRY-PI-PICO\": {\n    name: \"Raspberry Pi Pico\",\n    width: 21.0,\n    length: 51.0,\n    components: [\n      { type: 'CHIP', name: 'RP2040', x: 0, z: 0, params: { width: 7, length: 7, height: 1 } },\n      { type: 'USB', name: 'Micro-USB', x: 0, z: -24, rotation: Math.PI },\n      { type: 'HEADER', name: 'Left', x: -9, z: 0, params: { count: 20, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Right', x: 9, z: 0, params: { count: 20, pitch: 2.54 } },\n      { type: 'BUTTON', name: 'BOOTSEL', x: 0, z: -15 },\n    ]\n  }\n};\n\nexport const standardsService = {\n  getPackage: (name: string): IPCPackage | null => {\n    const packages = ipcData.packages as Record<string, IPCPackage>;\n    \n    // Exact match\n    if (packages[name]) return packages[name];\n    \n    // Fuzzy match (e.g. \"SOIC8\" -> \"SOIC-8\")\n    const normalized = name.toUpperCase().replace(/\\s+/g, '-');\n    if (packages[normalized]) return packages[normalized];\n    \n    // Check for substrings\n    for (const key of Object.keys(packages)) {\n      if (normalized.includes(key.toUpperCase())) return packages[key];\n    }\n    \n    return null;\n  },\n  getBoardMap: (name: string): BoardComponentMap | null => {\n    const normalized = name.toUpperCase().replace(/\\s+/g, '-');\n    if (BOARD_MAPS[normalized]) return BOARD_MAPS[normalized];\n    for (const key of Object.keys(BOARD_MAPS)) {\n      if (normalized.includes(key)) return BOARD_MAPS[key];\n    }\n    return null;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/storage.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3251,3254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3251,3254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ElectronicComponent, ActionRecord, Conversation, EnhancedChatMessage } from '../types';\n\n/**\n * Storage Service\n * \n * Provides a safe wrapper for localStorage with quota protection\n * AND IndexedDB persistence for heavy/structured data.\n */\n\n// ============================================================================\n// INDEXED DB CONFIG\n// ============================================================================\n\nconst DB_NAME = 'CircuitMindDB';\nconst DB_VERSION = 3;\nconst STORES = {\n  INVENTORY: 'inventory',\n  STATE: 'app_state',\n  ACTION_HISTORY: 'action_history',\n  CONVERSATIONS: 'conversations',\n  MESSAGES: 'messages'\n};\n\nconst openDB = (): Promise<IDBDatabase> => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n      \n      if (!db.objectStoreNames.contains(STORES.INVENTORY)) {\n        db.createObjectStore(STORES.INVENTORY, { keyPath: 'id' });\n      }\n      if (!db.objectStoreNames.contains(STORES.STATE)) {\n        db.createObjectStore(STORES.STATE, { keyPath: 'key' });\n      }\n      if (!db.objectStoreNames.contains(STORES.ACTION_HISTORY)) {\n        db.createObjectStore(STORES.ACTION_HISTORY, { keyPath: 'id' });\n      }\n      if (!db.objectStoreNames.contains(STORES.CONVERSATIONS)) {\n        db.createObjectStore(STORES.CONVERSATIONS, { keyPath: 'id' });\n      }\n      if (!db.objectStoreNames.contains(STORES.MESSAGES)) {\n        const messageStore = db.createObjectStore(STORES.MESSAGES, { keyPath: 'id' });\n        messageStore.createIndex('conversationId', 'conversationId', { unique: false });\n      }\n    };\n\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n};\n\n// ============================================================================\n// LOCAL STORAGE WRAPPER (With Quota Protection)\n// ============================================================================\n\nexport const storageService = {\n  setItem: (key: string, value: string): boolean => {\n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch (e: unknown) {\n      if (e instanceof DOMException && (\n        e.code === 22 || \n        e.code === 1014 || \n        e.name === 'QuotaExceededError' || \n        e.name === 'NS_ERROR_DOM_QUOTA_REACHED')\n      ) {\n        console.warn('LocalStorage quota exceeded. Attempting purge...');\n        return storageService.handleQuotaExceeded(key, value);\n      }\n      return false;\n    }\n  },\n\n  getItem: (key: string): string | null => {\n    return localStorage.getItem(key);\n  },\n\n  handleQuotaExceeded: (key: string, value: string): boolean => {\n    const keys = Object.keys(localStorage);\n    \n    // 1. Purge 3D code cache\n    const cacheKeys = keys.filter(k => k.startsWith('cm_3d_code_cache_'));\n    cacheKeys.forEach(k => localStorage.removeItem(k));\n    \n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch {\n      // 2. Prune inventory images if it's the inventory failing\n      if (key === 'cm_inventory') {\n        try {\n          const inv = JSON.parse(value);\n          const pruned = inv.map((item: any) => ({\n            ...item,\n            imageUrl: item.imageUrl?.length > 5000 ? null : item.imageUrl,\n            threeCode: null\n          }));\n          localStorage.setItem(key, JSON.stringify(pruned));\n          return true;\n        } catch { return false; }\n      }\n      return false;\n    }\n  }\n};\n\n// ============================================================================\n// INDEXED DB OPERATIONS (Action History)\n// ============================================================================\n\n/**\n * Sanitizes an object to ensure it's serializable for IndexedDB.\n * Removes non-cloneable objects like Events, Functions, etc.\n * Handles circular references gracefully.\n */\nconst sanitizeForDB = (obj: unknown): unknown => {\n  try {\n    // structuredClone is native and handles circular refs + many types better than JSON\n    return window.structuredClone(obj);\n  } catch (_e) {\n    // If it fails (e.g. contains functions or complex circular refs), \n    // use a robust custom stringifier that drops circularities.\n    try {\n      const cache = new Set();\n      const stringified = JSON.stringify(obj, (key, value) => {\n        if (typeof value === 'object' && value !== null) {\n          if (cache.has(value)) return '[Circular]';\n          cache.add(value);\n        }\n        return value;\n      });\n      return JSON.parse(stringified);\n    } catch (err) {\n      console.error('Failed to sanitize object for DB:', err, obj);\n      return null;\n    }\n  }\n};\n\nexport const recordAction = async (action: ActionRecord) => {\n  if (!action || !action.id) {\n    console.error('Cannot record action: Missing ID');\n    return;\n  }\n\n  const db = await openDB();\n  const sanitizedAction = sanitizeForDB(action);\n  if (!sanitizedAction) return;\n\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.ACTION_HISTORY, 'readwrite');\n    tx.objectStore(STORES.ACTION_HISTORY).put(sanitizedAction);\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const getRecentActions = async (limit: number = 10): Promise<ActionRecord[]> => {\n  const db = await openDB();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORES.ACTION_HISTORY, 'readonly');\n    const store = tx.objectStore(STORES.ACTION_HISTORY);\n    const request = store.getAll();\n    \n    request.onsuccess = () => {\n      const results = request.result as ActionRecord[];\n      resolve(results.sort((a, b) => b.timestamp - a.timestamp).slice(0, limit));\n    };\n    request.onerror = () => reject(request.error);\n  });\n};\n\nexport const deleteAction = async (id: string) => {\n  if (!id) return;\n  const db = await openDB();\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.ACTION_HISTORY, 'readwrite');\n    tx.objectStore(STORES.ACTION_HISTORY).delete(id);\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\n// ============================================================================\n// INDEXED DB OPERATIONS (Conversations & Messages)\n// ============================================================================\n\nexport const saveConversation = async (conv: Conversation) => {\n  if (!conv || !conv.id) {\n    console.error('Cannot save conversation: Missing ID');\n    return;\n  }\n\n  const db = await openDB();\n  const sanitizedConv = sanitizeForDB(conv);\n  if (!sanitizedConv) return;\n\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.CONVERSATIONS, 'readwrite');\n    tx.objectStore(STORES.CONVERSATIONS).put(sanitizedConv);\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const listConversations = async (limit: number = 50): Promise<Conversation[]> => {\n  const db = await openDB();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORES.CONVERSATIONS, 'readonly');\n    const request = tx.objectStore(STORES.CONVERSATIONS).getAll();\n    request.onsuccess = () => {\n      const results = request.result as Conversation[];\n      resolve(results.sort((a, b) => b.updatedAt - a.updatedAt).slice(0, limit));\n    };\n    request.onerror = () => reject(request.error);\n  });\n};\n\nexport const deleteConversation = async (id: string) => {\n  if (!id) return;\n  const db = await openDB();\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction([STORES.CONVERSATIONS, STORES.MESSAGES], 'readwrite');\n    tx.objectStore(STORES.CONVERSATIONS).delete(id);\n    \n    // Also delete all messages for this conversation\n    const msgStore = tx.objectStore(STORES.MESSAGES);\n    const index = msgStore.index('conversationId');\n    const request = index.openKeyCursor(IDBKeyRange.only(id));\n    request.onsuccess = () => {\n      const cursor = request.result;\n      if (cursor) {\n        msgStore.delete(cursor.primaryKey);\n        cursor.continue();\n      }\n    };\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const getPrimaryConversation = async (): Promise<Conversation | null> => {\n  const convs = await listConversations(100);\n  return convs.find(c => c.isPrimary) || null;\n};\n\nexport const saveMessage = async (msg: EnhancedChatMessage) => {\n  if (!msg || !msg.id) {\n    console.error('Cannot save message: Missing ID');\n    return;\n  }\n\n  const db = await openDB();\n  const sanitizedMsg = sanitizeForDB(msg);\n  if (!sanitizedMsg) return;\n\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.MESSAGES, 'readwrite');\n    tx.objectStore(STORES.MESSAGES).put(sanitizedMsg);\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const loadMessages = async (conversationId: string): Promise<EnhancedChatMessage[]> => {\n  if (!conversationId) {\n    console.warn('loadMessages called without conversationId');\n    return [];\n  }\n\n  const db = await openDB();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORES.MESSAGES, 'readonly');\n    const index = tx.objectStore(STORES.MESSAGES).index('conversationId');\n    const request = index.getAll(IDBKeyRange.only(conversationId));\n    request.onsuccess = () => {\n      const results = request.result as EnhancedChatMessage[];\n      resolve(results.sort((a, b) => a.timestamp - b.timestamp));\n    };\n    request.onerror = () => reject(request.error);\n  });\n};\n\n// ============================================================================\n// INDEXED DB OPERATIONS (Inventory)\n// ============================================================================\n\nexport const saveInventoryToDB = async (items: ElectronicComponent[]) => {\n  if (!Array.isArray(items)) return;\n\n  const db = await openDB();\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.INVENTORY, 'readwrite');\n    const store = tx.objectStore(STORES.INVENTORY);\n    \n    store.clear().onsuccess = () => {\n      items.forEach(item => {\n        const sanitized = sanitizeForDB(item);\n        if (sanitized && sanitized.id) {\n          store.put(sanitized);\n        }\n      });\n    };\n\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const loadInventoryFromDB = async (): Promise<ElectronicComponent[]> => {\n  const db = await openDB();\n  const tx = db.transaction(STORES.INVENTORY, 'readonly');\n  const request = tx.objectStore(STORES.INVENTORY).getAll();\n  return new Promise((resolve) => {\n    request.onsuccess = () => resolve(request.result || []);\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/syncService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threeCodeRunner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[119,122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[119,122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ThreeCodeWorker from './threeCodeRunner.worker?worker';\n\nexport const executeInWorker = (code: string): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    const worker = new ThreeCodeWorker();\n    \n    // 5s execution timeout to prevent infinite loops freezing the app\n    const timeout = setTimeout(() => {\n        worker.terminate();\n        reject(new Error('Execution timed out (5s limit). Infinite loop detected?'));\n    }, 5000);\n\n    worker.onmessage = (e) => {\n        clearTimeout(timeout);\n        if (e.data.success) {\n            resolve(e.data.json);\n        } else {\n            reject(new Error(e.data.error || 'Worker execution failed'));\n        }\n        worker.terminate();\n    };\n\n    worker.onerror = (err) => {\n        clearTimeout(timeout);\n        reject(new Error('Worker error: ' + err.message));\n        worker.terminate();\n    };\n\n    worker.postMessage({ code });\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threeCodeRunner.worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threePrimitives.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threeWorkerPolyfill.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/tutorialValidator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/userProfileService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/visionAnalysisService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/viz/vizEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/webRTCService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1809,1812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1809,1812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"class WebRTCService {\n  private peerConnection: RTCPeerConnection | null = null;\n  private dataChannel: RTCDataChannel | null = null;\n\n  async createOffer() {\n    this.peerConnection = new RTCPeerConnection({\n      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]\n    });\n\n    this.dataChannel = this.peerConnection.createDataChannel('git-sync');\n    this.setupDataChannel();\n\n    const offer = await this.peerConnection.createOffer();\n    await this.peerConnection.setLocalDescription(offer);\n\n    return JSON.stringify(offer);\n  }\n\n  async acceptOffer(offerStr: string) {\n    const offer = JSON.parse(offerStr);\n    this.peerConnection = new RTCPeerConnection({\n      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]\n    });\n\n    this.peerConnection.ondatachannel = (event) => {\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    await this.peerConnection.setRemoteDescription(offer);\n    const answer = await this.peerConnection.createAnswer();\n    await this.peerConnection.setLocalDescription(answer);\n\n    return JSON.stringify(answer);\n  }\n\n  async acceptAnswer(answerStr: string) {\n    if (!this.peerConnection) return;\n    const answer = JSON.parse(answerStr);\n    await this.peerConnection.setRemoteDescription(answer);\n  }\n\n  private setupDataChannel() {\n    if (!this.dataChannel) return;\n\n    this.dataChannel.onopen = () => console.log('Data channel open');\n    this.dataChannel.onclose = () => console.log('Data channel closed');\n    this.dataChannel.onmessage = (event) => {\n      console.log('Received message:', event.data);\n      // Handle Git packfile or JSON data\n    };\n  }\n\n  send(data: string | ArrayBuffer | Blob | ArrayBufferView) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(data as any); // RTCDataChannel.send accepts these types, but TS definitions vary.\n    }\n  }\n}\n\nexport const webRTCService = new WebRTCService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/styles/colors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/tests/setup.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[267,270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[267,270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[465,468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[465,468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1440,1443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1440,1443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1820,1823],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1820,1823],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1939,1942],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1939,1942],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import '@testing-library/jest-dom';\nimport { cleanup } from '@testing-library/react';\nimport { afterEach, vi } from 'vitest';\n\n// Manual mock for IndexedDB\nif (!global.indexedDB) {\n  const mockIDB = {\n    open: vi.fn().mockImplementation(() => {\n      const request: any = {\n        result: {\n          objectStoreNames: { contains: () => true },\n          createObjectStore: vi.fn(),\n          transaction: vi.fn().mockImplementation(() => {\n            const tx: any = {\n              objectStore: vi.fn().mockReturnValue({\n                get: vi.fn().mockReturnValue({ onsuccess: null }),\n                put: vi.fn().mockReturnValue({ onsuccess: null }),\n                delete: vi.fn().mockReturnValue({ onsuccess: null }),\n                getAll: vi.fn().mockReturnValue({ onsuccess: null }),\n                openCursor: vi.fn().mockReturnValue({ onsuccess: null }),\n                createIndex: vi.fn(),\n              }),\n              oncomplete: null,\n              onerror: null,\n            };\n            setTimeout(() => {\n              if (tx.oncomplete) tx.oncomplete();\n            }, 0);\n            return tx;\n          }),\n        },\n        onupgradeneeded: null,\n        onsuccess: null,\n        onerror: null,\n      };\n      setTimeout(() => {\n        if (request.onsuccess) {\n          request.onsuccess({ target: request });\n        }\n      }, 0);\n      return request;\n    }),\n  };\n  global.indexedDB = mockIDB as any;\n}\n\n// Mock scrollIntoView\nwindow.HTMLElement.prototype.scrollIntoView = vi.fn();\n\n// Mock scrollTo\nwindow.HTMLElement.prototype.scrollTo = vi.fn();\n\n// Mock ResizeObserver\nglobal.ResizeObserver = class ResizeObserver {\n  observe = vi.fn();\n  unobserve = vi.fn();\n  disconnect = vi.fn();\n};\n\n// Mock virtua\nvi.mock('virtua', () => ({\n  VList: ({ children, className, style }: any) => (\n    <div className={className} style={style}>{children}</div>\n  ),\n  VGrid: ({ children, className, style }: any) => (\n    <div className={className} style={style}>{children}</div>\n  ),\n}));\n\nafterEach(() => {\n  cleanup();\n  vi.clearAllMocks();\n  localStorage.clear();\n  sessionStorage.clear();\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/tests/test-utils.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"This rule can't verify that `export *` only exports components.","line":73,"column":1,"nodeType":"ExportAllDeclaration","messageId":"exportAll","endLine":73,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { ReactNode } from 'react';\nimport { render, RenderOptions } from '@testing-library/react';\nimport { InventoryProvider } from '../contexts/InventoryContext';\nimport { DiagramProvider } from '../contexts/DiagramContext';\nimport { LayoutProvider } from '../contexts/LayoutContext';\nimport { VoiceAssistantProvider } from '../contexts/VoiceAssistantContext';\nimport { ConversationProvider } from '../contexts/ConversationContext';\nimport { AssistantStateProvider } from '../contexts/AssistantStateContext';\nimport { HUDProvider } from '../contexts/HUDContext';\nimport { TelemetryProvider } from '../contexts/TelemetryContext';\nimport { SimulationProvider } from '../contexts/SimulationContext';\nimport { TutorialProvider } from '../contexts/TutorialContext';\nimport { HealthProvider } from '../contexts/HealthContext';\nimport { MacroProvider } from '../contexts/MacroContext';\nimport { DashboardProvider } from '../contexts/DashboardContext';\nimport { AuthProvider } from '../contexts/AuthContext';\nimport { UserProvider } from '../contexts/UserContext';\nimport { SelectionProvider } from '../contexts/SelectionContext';\nimport { NotificationProvider } from '../contexts/NotificationContext';\nimport { ToastProvider } from '../hooks/useToast';\nimport { ElectronicComponent } from '../types';\n\ninterface CustomRenderOptions extends RenderOptions {\n  inventory?: ElectronicComponent[];\n}\n\nconst customRender = (ui: React.ReactElement, options?: CustomRenderOptions) => {\n  const AllTheProviders = ({ children }: { children: ReactNode }) => {\n    return (\n      <LayoutProvider>\n        <AssistantStateProvider>\n          <HealthProvider>\n            <AuthProvider>\n              <UserProvider>\n                <ToastProvider>\n                  <NotificationProvider>\n                    <DashboardProvider>\n                      <MacroProvider>\n                        <InventoryProvider initialData={options?.inventory}>\n                          <ConversationProvider>\n                            <DiagramProvider>\n                              <SelectionProvider>\n                                <TelemetryProvider>\n                                  <HUDProvider>\n                                    <SimulationProvider>\n                                      <VoiceAssistantProvider>\n                                        <TutorialProvider>\n                                          {children}\n                                        </TutorialProvider>\n                                      </VoiceAssistantProvider>\n                                    </SimulationProvider>\n                                  </HUDProvider>\n                                </TelemetryProvider>\n                              </SelectionProvider>\n                            </DiagramProvider>\n                          </ConversationProvider>\n                        </InventoryProvider>\n                      </MacroProvider>\n                    </DashboardProvider>\n                  </NotificationProvider>\n                </ToastProvider>\n              </UserProvider>\n            </AuthProvider>\n          </HealthProvider>\n        </AssistantStateProvider>\n      </LayoutProvider>\n    );\n  };\n\n  return render(ui, { wrapper: AllTheProviders, ...options });\n};\n\nexport * from '@testing-library/react';\nexport { customRender as render };","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
