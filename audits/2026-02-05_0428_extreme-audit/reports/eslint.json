[{"filePath":"/home/wtyler/circuitmind-ai/components/AssistantSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ChatMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ChatPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ComponentEditorModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ConversationSwitcher.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/DiagramCanvas.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/IconButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/Inventory.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateSearchQuery' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":68,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/SettingsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/ThreeViewer.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'settings.ambientColor', 'settings.ambientIntensity', 'settings.dirColor', and 'settings.dirIntensity'. Either include them or remove the dependency array.","line":271,"column":6,"nodeType":"ArrayExpression","endLine":271,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [handleResize, settings.ambientColor, settings.ambientIntensity, settings.dirColor, settings.dirIntensity]","fix":{"range":[11301,11315],"text":"[handleResize, settings.ambientColor, settings.ambientIntensity, settings.dirColor, settings.dirIntensity]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/AssistantSidebar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/ChatMessage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/ChatPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/ComponentEditorModal.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/DiagramCanvas.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dropZone' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":226,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":226,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { render, screen, fireEvent, act } from '../../tests/test-utils';\nimport { createRef } from 'react';\nimport DiagramCanvas, { DiagramCanvasRef } from '../DiagramCanvas';\nimport { WiringDiagram, ElectronicComponent } from '../../types';\n\n// Mock component data\nconst mockComponent: ElectronicComponent = {\n  id: 'comp-1',\n  name: 'Arduino Uno',\n  type: 'microcontroller',\n  pins: ['5V', 'GND', 'D2', 'D3'],\n  description: 'Main controller',\n  quantity: 1,\n};\n\nconst mockComponent2: ElectronicComponent = {\n  id: 'comp-2',\n  name: 'LED',\n  type: 'actuator',\n  pins: ['Anode', 'Cathode'],\n  description: 'Status indicator',\n  quantity: 1,\n};\n\nconst emptyDiagram: WiringDiagram = {\n  title: 'Empty Diagram',\n  components: [],\n  connections: [],\n  explanation: '',\n};\n\nconst diagramWithComponents: WiringDiagram = {\n  title: 'Test Circuit',\n  components: [mockComponent, mockComponent2],\n  connections: [],\n  explanation: 'Test explanation',\n};\n\nconst diagramWithConnection: WiringDiagram = {\n  title: 'Connected Circuit',\n  components: [mockComponent, mockComponent2],\n  connections: [\n    {\n      fromComponentId: 'comp-1',\n      toComponentId: 'comp-2',\n      fromPin: 'D2',\n      toPin: 'Anode',\n      description: 'Signal wire',\n      color: '#00ff00',\n    },\n  ],\n  explanation: 'LED connected to Arduino',\n};\n\ndescribe('DiagramCanvas', () => {\n  const defaultProps = {\n    onComponentSelect: vi.fn(),\n    onComponentContextMenu: vi.fn(),\n    onComponentDoubleClick: vi.fn(),\n    onDiagramUpdate: vi.fn(),\n    onComponentDrop: vi.fn(),\n  };\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('Empty State', () => {\n    it('shows an empty state when the diagram has no components', () => {\n      render(<DiagramCanvas diagram={emptyDiagram} {...defaultProps} />);\n\n      expect(screen.getByText('Drop parts to start wiring.')).toBeInTheDocument();\n      expect(\n        screen.getByText(/Build manually or let chat generate a full diagram/i)\n      ).toBeInTheDocument();\n    });\n\n    it('shows empty state when diagram is null', () => {\n      render(<DiagramCanvas diagram={null} {...defaultProps} />);\n\n      // Null diagram shows different message than empty diagram\n      expect(screen.getByText('No diagram yet.')).toBeInTheDocument();\n    });\n  });\n\n  // ... (Component Rendering, Wire Rendering, Zoom Controls, Search Functionality tests remain similar)\n\n  describe('Component Interaction', () => {\n    it('calls onComponentSelect when a component is clicked (Left Click)', () => {\n      render(<DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />);\n\n      const componentName = screen.getByText('Arduino Uno');\n      const componentGroup = componentName.closest('g');\n\n      if (componentGroup) {\n        fireEvent.click(componentGroup);\n        expect(defaultProps.onComponentSelect).toHaveBeenCalledWith('comp-1');\n      }\n    });\n\n    it('calls onComponentContextMenu when right-clicked', () => {\n      render(<DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />);\n\n      const componentName = screen.getByText('Arduino Uno');\n      const componentGroup = componentName.closest('g');\n\n      if (componentGroup) {\n        fireEvent.contextMenu(componentGroup);\n        expect(defaultProps.onComponentContextMenu).toHaveBeenCalledWith('comp-1', expect.any(Number), expect.any(Number));\n      }\n    });\n\n    it('calls onComponentDoubleClick when double-clicked', () => {\n      render(<DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />);\n\n      const componentName = screen.getByText('Arduino Uno');\n      const componentGroup = componentName.closest('g');\n\n      if (componentGroup) {\n        fireEvent.doubleClick(componentGroup);\n        expect(defaultProps.onComponentDoubleClick).toHaveBeenCalledWith(\n          expect.objectContaining({ id: 'comp-1' })\n        );\n      }\n    });\n  });\n\n  // ... (Rest of tests)\n\n  describe('Imperative API (Ref)', () => {\n    it('exposes setZoom and getZoom methods', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      expect(ref.current).not.toBeNull();\n      expect(ref.current?.getZoom()).toBe(1);\n\n      act(() => {\n        ref.current?.setZoom(2);\n      });\n\n      expect(ref.current?.getZoom()).toBe(2);\n    });\n\n    it('exposes setPan and getPan methods', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      expect(ref.current?.getPan()).toEqual({ x: 0, y: 0 });\n\n      act(() => {\n        ref.current?.setPan(100, 50);\n      });\n\n      expect(ref.current?.getPan()).toEqual({ x: 100, y: 50 });\n    });\n\n    it('exposes resetView method', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      act(() => {\n        ref.current?.setZoom(2);\n        ref.current?.setPan(100, 100);\n      });\n\n      act(() => {\n        ref.current?.resetView();\n      });\n\n      expect(ref.current?.getZoom()).toBe(1);\n      expect(ref.current?.getPan()).toEqual({ x: 0, y: 0 });\n    });\n\n    it('exposes highlightComponent and clearHighlight methods', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      // Should not throw\n      act(() => {\n        ref.current?.highlightComponent('comp-1', { color: '#ff0000', pulse: true });\n      });\n\n      act(() => {\n        ref.current?.clearHighlight('comp-1');\n      });\n    });\n\n    it('exposes getComponentPosition method', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      // Positions are auto-assigned, so should exist\n      const pos = ref.current?.getComponentPosition('comp-1');\n      expect(pos).toBeDefined();\n      expect(pos).toHaveProperty('x');\n      expect(pos).toHaveProperty('y');\n    });\n\n    it('exposes getAllComponentPositions method', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      const positions = ref.current?.getAllComponentPositions();\n      expect(positions).toBeInstanceOf(Map);\n      expect(positions?.size).toBe(2);\n    });\n\n    it('exposes centerOnComponent method', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithComponents} {...defaultProps} />);\n\n      // Should not throw\n      act(() => {\n        ref.current?.centerOnComponent('comp-1', 1.5);\n      });\n    });\n  });\n\n  describe('Drag and Drop', () => {\n    it('shows drop indicator during drag over', () => {\n      const { container } = render(\n        <DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />\n      );\n\n      const dropZone = container.querySelector('.drop-zone, [data-testid=\"canvas-drop-zone\"]');\n      // The actual drop zone is the container div\n\n      fireEvent.dragOver(container.firstChild as Element, {\n        dataTransfer: { types: ['application/json'] },\n      });\n\n      // Visual feedback is applied via CSS class\n    });\n\n    it('handles component drop', () => {\n      const { container } = render(\n        <DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />\n      );\n\n      const dropData = JSON.stringify({\n        id: 'new-comp',\n        name: 'New Component',\n        type: 'Test',\n        pins: ['A', 'B'],\n      });\n\n      fireEvent.drop(container.firstChild as Element, {\n        dataTransfer: {\n          getData: () => dropData,\n        },\n        clientX: 200,\n        clientY: 150,\n      });\n\n      // onComponentDrop should be called with parsed component\n      expect(defaultProps.onComponentDrop).toHaveBeenCalled();\n    });\n  });\n\n  describe('Wire Highlighting', () => {\n    it('exposes highlightWire and clearWireHighlight methods', () => {\n      const ref = createRef<DiagramCanvasRef>();\n      render(<DiagramCanvas ref={ref} diagram={diagramWithConnection} {...defaultProps} />);\n\n      // Should not throw\n      act(() => {\n        ref.current?.highlightWire(0, { color: '#00ff00', pulse: true });\n      });\n\n      act(() => {\n        ref.current?.clearWireHighlight(0);\n      });\n    });\n  });\n\n  describe('SVG Arrow Markers', () => {\n    it('defines arrow markers in SVG defs', () => {\n      const { container } = render(\n        <DiagramCanvas diagram={diagramWithConnection} {...defaultProps} />\n      );\n\n      const defs = container.querySelector('defs');\n      expect(defs).toBeInTheDocument();\n\n      const markers = container.querySelectorAll('marker');\n      expect(markers.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Title Display', () => {\n    it('displays diagram title in header', () => {\n      const { container } = render(\n        <DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />\n      );\n\n      // Title is rendered in the header section\n      const header = container.querySelector('[class*=\"absolute\"][class*=\"top\"]');\n      expect(header).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('has accessible zoom controls', () => {\n      render(<DiagramCanvas diagram={diagramWithComponents} {...defaultProps} />);\n\n      const zoomIn = screen.getByLabelText(/zoom in/i);\n      const zoomOut = screen.getByLabelText(/zoom out/i);\n      const resetView = screen.getByLabelText(/reset view/i);\n\n      expect(zoomIn).toHaveAttribute('type', 'button');\n      expect(zoomOut).toHaveAttribute('type', 'button');\n      expect(resetView).toHaveAttribute('type', 'button');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/Inventory.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'thumbnail' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":31,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { render, fireEvent, screen, waitFor } from '../../tests/test-utils';\nimport userEvent from '@testing-library/user-event';\nimport { vi } from 'vitest';\nimport Inventory from '../Inventory';\nimport { ElectronicComponent } from '../../types';\n\n// Mock clipboard\nObject.assign(navigator, {\n  clipboard: {\n    writeText: vi.fn(),\n  },\n});\n\ndescribe('Inventory', () => {\n  it('inventory_thumbnailError_showsFallbackIcon', async () => {\n    const items: ElectronicComponent[] = [\n      {\n        id: 'item-1',\n        name: 'Test Board',\n        type: 'microcontroller',\n        description: 'Test item',\n        pins: [],\n        quantity: 1,\n        imageUrl: 'http://example.com/broken.jpg',\n      },\n    ];\n\n    render(<Inventory onSelect={vi.fn()} />, { inventory: items });\n\n    const img = screen.getByAltText('Test Board');\n    const thumbnail = img.parentElement as HTMLElement;\n    \n    fireEvent.error(img);\n\n    await waitFor(() => {\n      expect(screen.queryByAltText('Test Board')).toBeNull();\n      // \"M\" check disabled - JSDOM image error simulation is flaky with this DOM manipulation approach\n      // expect(within(thumbnail).getByText('M', { exact: true })).toBeInTheDocument();\n    });\n  });\n\n  it('inventory_bulkSelection_showsActionBar', async () => {\n    const user = userEvent.setup();\n    const items: ElectronicComponent[] = [\n      {\n        id: 'item-1',\n        name: 'Test Board',\n        type: 'microcontroller',\n        description: 'Test item',\n        pins: [],\n        quantity: 1,\n      },\n    ];\n\n    render(<Inventory onSelect={vi.fn()} />, { inventory: items });\n\n    expect(screen.getByText('Test Board')).toBeInTheDocument();\n\n    const checkboxes = screen.getAllByRole('checkbox');\n    const checkbox = checkboxes[0];\n    \n    await user.click(checkbox);\n\n    await waitFor(() => expect(screen.getByText('1 SELECTED')).toBeInTheDocument());\n    \n    expect(screen.getByText('Delete')).toBeInTheDocument();\n    expect(screen.getByText('Clear')).toBeInTheDocument();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/SettingsPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/__tests__/ThreeViewer.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/auth/Gatekeeper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/auth/PermissionGuard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/AnalogGauge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/DashboardView.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[325,328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[325,328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport * as RGL from 'react-grid-layout';\nimport { useDashboard, DashboardWidget } from '../../contexts/DashboardContext';\nimport { WidgetWrapper } from './WidgetWrapper';\n\n// Multi-fallback resolver for react-grid-layout\nconst lib = ((RGL as unknown as Record<string, unknown>).default || RGL) as any;\nconst Responsive = lib.Responsive || lib;\nconst WidthProvider = lib.WidthProvider;\nconst ResponsiveGridLayout = WidthProvider ? WidthProvider(Responsive) : Responsive;\n\n// Import widget components\nimport { SystemVitals } from '../layout/SystemVitals';\nimport { HardwareTerminal } from '../layout/HardwareTerminal';\nimport { ProjectTimeline } from '../layout/ProjectTimeline';\nimport { OscilloscopeWidget } from './OscilloscopeWidget';\nimport { LogicAnalyzerWidget } from './LogicAnalyzerWidget';\nimport { AnalogGauge } from './AnalogGauge';\nimport { HeatmapWidget } from './HeatmapWidget';\n\nconst WidgetRenderer: React.FC<{ widget: DashboardWidget }> = ({ widget }) => {\n  switch (widget.type) {\n    case 'vitals':\n      return <SystemVitals />;\n    case 'terminal':\n      return <HardwareTerminal />;\n    case 'timeline':\n      return <ProjectTimeline />;\n    case 'oscilloscope':\n      return <OscilloscopeWidget streamId=\"main-osc\" />;\n    case 'logic':\n      return <LogicAnalyzerWidget streamId=\"d0-logic\" label=\"PIN_D0\" />;\n    case 'gauge':\n      return <AnalogGauge value={Math.random() * 100} label=\"LOAD\" />;\n    case 'heatmap':\n      return <HeatmapWidget points={[]} />;\n    default:\n      return <div className=\"p-4 text-slate-500 text-[10px]\">Unknown Widget: {widget.type}</div>;\n  }\n};\n\nexport const DashboardView: React.FC = () => {\n  const { widgets, updateLayout, isEditMode } = useDashboard();\n\n  const layouts = {\n    lg: widgets.map(w => w.layout)\n  };\n\n  return (\n    <div className=\"w-full h-full bg-cyber-black overflow-y-auto custom-scrollbar p-4\">\n      <ResponsiveGridLayout\n        className=\"layout\"\n        layouts={layouts}\n        breakpoints={{ lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }}\n        cols={{ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }}\n        rowHeight={100}\n        isDraggable={isEditMode}\n        isResizable={isEditMode}\n        onLayoutChange={(currentLayout) => updateLayout(currentLayout)}\n        draggableHandle=\".cursor-grab\"\n      >\n        {widgets.map(widget => (\n          <div key={widget.id}>\n            <WidgetWrapper id={widget.id} title={widget.type.toUpperCase()}>\n              <WidgetRenderer widget={widget} />\n            </WidgetWrapper>\n          </div>\n        ))}\n      </ResponsiveGridLayout>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/HeatmapWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/LogicAnalyzerWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/OscilloscopeWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/Sparkline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/WidgetLibrary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/dashboard/WidgetWrapper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/ConflictResolver.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/Diagram3DView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/DiagramNode.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'component.pins'. Either exclude it or remove the dependency array.","line":751,"column":5,"nodeType":"ArrayExpression","endLine":751,"endColumn":39,"suggestions":[{"desc":"Update the dependencies array to be: [shape, component]","fix":{"range":[31479,31513],"text":"[shape, component]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { memo, useCallback, useMemo } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { ElectronicComponent } from '../../types';\nimport { getComponentShape, calculatePinPositions, COLORS, type ComponentShape } from './componentShapes';\nimport { useTelemetry } from '../../contexts/TelemetryContext';\nimport { useSimulation } from '../../contexts/SimulationContext';\nimport { BreadboardVisual } from './parts/Breadboard';\nimport { FzpzVisual } from './parts/FzpzVisual';\n\n// Default dimensions (used for layout calculations)\nconst COMPONENT_WIDTH = 180;\nconst COMPONENT_HEIGHT = 100;\n\nexport interface NodeHighlightState {\n  color: string;\n  pulse: boolean;\n}\n\ninterface DiagramNodeProps {\n  component: ElectronicComponent;\n  position: { x: number; y: number };\n  isHovered: boolean;\n  isSelected?: boolean;\n  highlight?: NodeHighlightState;\n  onPointerDown: (e: React.PointerEvent, nodeId: string) => void;\n  onSelect?: (componentId: string) => void;\n  onContextMenu?: (componentId: string, x: number, y: number) => void;\n  onDoubleClick?: (component: ElectronicComponent) => void;\n  onPinPointerDown: (e: React.PointerEvent, nodeId: string, pin: string, isRightSide: boolean) => void;\n  onPinPointerUp: (e: React.PointerEvent, nodeId: string, pin: string) => void;\n  onMouseEnter?: (e: React.MouseEvent, component: ElectronicComponent) => void;\n  onMouseLeave?: (e: React.MouseEvent, component: ElectronicComponent) => void;\n  onPinEnter?: (e: React.MouseEvent, componentId: string, pin: string) => void;\n  onPinLeave?: (e: React.MouseEvent, componentId: string, pin: string) => void;\n}\n\n/**\n * Smart pin color coding based on pin function\n */\nconst getPinColor = (pinName: string): { fill: string; stroke: string; textColor: string } => {\n  const name = pinName.toUpperCase();\n\n  // Power pins - RED\n  if (name === 'VCC' || name === 'VIN' || name === '5V' || name === '3V3' ||\n      name === '3.3V' || name === '+5V' || name === '+3.3V' || name.includes('PWR') ||\n      name === 'V+' || name === 'RAW') {\n    return { fill: '#DC2626', stroke: '#991B1B', textColor: '#FECACA' };\n  }\n\n  // Ground pins - BLACK\n  if (name === 'GND' || name === 'GROUND' || name === 'VSS' || name === 'V-' || name === '0V') {\n    return { fill: '#1F2937', stroke: '#111827', textColor: '#9CA3AF' };\n  }\n\n  // I2C pins - BLUE\n  if (name === 'SDA' || name === 'SCL' || name.includes('I2C')) {\n    return { fill: '#2563EB', stroke: '#1D4ED8', textColor: '#BFDBFE' };\n  }\n\n  // SPI pins - PURPLE\n  if (name === 'MOSI' || name === 'MISO' || name === 'SCK' || name === 'SS' ||\n      name === 'CS' || name.includes('SPI')) {\n    return { fill: '#7C3AED', stroke: '#5B21B6', textColor: '#DDD6FE' };\n  }\n\n  // Serial pins - GREEN/ORANGE\n  if (name === 'TX' || name === 'TXD' || name === 'TX0' || name === 'TX1') {\n    return { fill: '#059669', stroke: '#047857', textColor: '#A7F3D0' };\n  }\n  if (name === 'RX' || name === 'RXD' || name === 'RX0' || name === 'RX1') {\n    return { fill: '#D97706', stroke: '#B45309', textColor: '#FDE68A' };\n  }\n\n  // Analog pins - TEAL\n  if (name.startsWith('A') && /^A\\d+$/.test(name)) {\n    return { fill: '#0891B2', stroke: '#0E7490', textColor: '#A5F3FC' };\n  }\n\n  // Digital pins - Default copper with gold tint\n  return { fill: 'url(#gradient-copper)', stroke: '#7A7152', textColor: '#FDE68A' };\n};\n\n/**\n * TelemetryOverlay component - floating data bubble for real-time pin values.\n */\nconst TelemetryOverlay: React.FC<{ \n  pin: string; \n  componentId: string; \n  x: number; \n  y: number; \n  isRightSide: boolean \n}> = ({ pin, componentId, x, y, isRightSide }) => {\n  const { liveData } = useTelemetry();\n  // Check for exact match or auto-mapped pin\n  const packet = liveData[`${componentId}:${pin}`] || liveData[`auto:${pin}`];\n\n  if (!packet) return null;\n\n  return (\n    <g transform={`translate(${isRightSide ? x + 12 : x - 12}, ${y})`} pointerEvents=\"none\">\n      <AnimatePresence mode=\"wait\">\n        <motion.g\n          key={`${packet.timestamp}-${packet.value}`}\n          initial={{ opacity: 0, x: isRightSide ? -5 : 5 }}\n          animate={{ opacity: 1, x: 0 }}\n          exit={{ opacity: 0, scale: 0.8 }}\n          transition={{ duration: 0.2 }}\n        >\n          {/* Bubble background */}\n          <rect\n            x={isRightSide ? 0 : -36}\n            y={-7}\n            width=\"36\"\n            height=\"14\"\n            rx=\"2\"\n            fill={packet.value === 'HIGH' || packet.value === '1' ? '#00ff9d' : '#00f3ff'}\n            className=\"shadow-lg\"\n          />\n          {/* Value text */}\n          <text\n            x={isRightSide ? 18 : -18}\n            y={3}\n            textAnchor=\"middle\"\n            fill=\"#000\"\n            fontSize=\"8\"\n            fontWeight=\"bold\"\n            fontFamily=\"monospace\"\n          >\n            {packet.value}\n          </text>\n          {/* Pulsing indicator */}\n          <circle\n            cx={isRightSide ? 0 : 0}\n            cy=\"0\"\n            r=\"2\"\n            fill=\"#fff\"\n            className=\"animate-ping\"\n          />\n        </motion.g>\n      </AnimatePresence>\n    </g>\n  );\n};\n\n/**\n * PinStatusDot component - tiny indicator for logical pin state.\n */\nconst PinStatusDot: React.FC<{ pin: string; componentId: string; x: number; y: number }> = ({ pin, componentId, x, y }) => {\n  const { result } = useSimulation();\n  const state = result?.pinStates[`${componentId}:${pin}`];\n\n  if (!state || state.logicState === 'FLOATING') return null;\n\n  const color = \n    state.logicState === 'HIGH' ? '#00ff9d' : \n    state.logicState === 'LOW' ? '#1e293b' : \n    state.logicState === 'ERROR' ? '#ef4444' : 'transparent';\n\n  return (\n    <circle \n      cx={x} \n      cy={y} \n      r=\"2.5\" \n      fill={color} \n      stroke=\"#000\" \n      strokeWidth=\"0.5\" \n      pointerEvents=\"none\" \n      className=\"transition-colors duration-200\"\n    />\n  );\n};\n\n/**\n * Pin component - Fritzing-style copper contacts with smart color coding.\n */\ninterface PinProps {\n  pin: string;\n  x: number;\n  y: number;\n  nodeId: string;\n  isRightSide: boolean;\n  shape: ComponentShape;\n  onPointerDown: (e: React.PointerEvent, nodeId: string, pin: string, isRightSide: boolean) => void;\n  onPointerUp: (e: React.PointerEvent, nodeId: string, pin: string) => void;\n  onMouseEnter?: (e: React.MouseEvent, nodeId: string, pin: string) => void;\n  onMouseLeave?: (e: React.MouseEvent, nodeId: string, pin: string) => void;\n}\n\nconst Pin = memo<PinProps>(function Pin({\n  pin,\n  x,\n  y,\n  nodeId,\n  isRightSide,\n  shape,\n  onPointerDown,\n  onPointerUp,\n  onMouseEnter,\n  onMouseLeave,\n}) {\n  const handlePointerDown = useCallback(\n    (e: React.PointerEvent) => onPointerDown(e, nodeId, pin, isRightSide),\n    [onPointerDown, nodeId, pin, isRightSide]\n  );\n\n  const handlePointerUp = useCallback(\n    (e: React.PointerEvent) => onPointerUp(e, nodeId, pin),\n    [onPointerUp, nodeId, pin]\n  );\n\n  const handleMouseEnter = useCallback(\n    (e: React.MouseEvent) => onMouseEnter?.(e, nodeId, pin),\n    [onMouseEnter, nodeId, pin]\n  );\n\n  const handleMouseLeave = useCallback(\n    (e: React.MouseEvent) => onMouseLeave?.(e, nodeId, pin),\n    [onMouseLeave, nodeId, pin]\n  );\n\n  // Get smart pin color based on pin name/function\n  const pinColors = useMemo(() => getPinColor(pin), [pin]);\n  const defaultFill = shape.pinFill || COLORS.copper;\n\n  // Use smart color if pin has special function, otherwise use component default\n  const isSpecialPin = !pinColors.fill.includes('gradient');\n  const pinFill = isSpecialPin ? pinColors.fill : defaultFill;\n  const pinStroke = isSpecialPin ? pinColors.stroke : (shape.pinStroke || '#7A7152');\n  const labelColor = isSpecialPin ? pinColors.textColor : COLORS.text;\n\n  // Pin dimensions - slightly larger for visibility\n  const pinWidth = 8;\n  const pinHeight = 10;\n  const pinRadius = 1;\n\n  return (\n    <g className=\"pin-group\">\n      {/* Pin glow effect for special pins */}\n      {isSpecialPin && (\n        <rect\n          x={x - pinWidth / 2 - 1}\n          y={y - pinHeight / 2 - 1}\n          width={pinWidth + 2}\n          height={pinHeight + 2}\n          rx={pinRadius + 1}\n          fill={pinFill}\n          opacity=\"0.3\"\n          filter=\"url(#filter-glow)\"\n        />\n      )}\n      {/* Pin pad - rounded rectangle with color coding */}\n      <rect\n        x={x - pinWidth / 2}\n        y={y - pinHeight / 2}\n        width={pinWidth}\n        height={pinHeight}\n        rx={pinRadius}\n        fill={pinFill}\n        stroke={pinStroke}\n        strokeWidth=\"1.5\"\n        onPointerDown={handlePointerDown}\n        onPointerUp={handlePointerUp}\n        onMouseEnter={handleMouseEnter}\n        onMouseLeave={handleMouseLeave}\n        className=\"cursor-crosshair hover:brightness-125 transition-all\"\n        style={{ filter: isSpecialPin ? 'brightness(1.1)' : undefined }}\n      />\n      {/* Metallic highlight on pin */}\n      <rect\n        x={x - pinWidth / 2 + 1}\n        y={y - pinHeight / 2 + 1}\n        width={pinWidth - 2}\n        height={3}\n        rx={0.5}\n        fill=\"rgba(255,255,255,0.2)\"\n        pointerEvents=\"none\"\n      />\n      {/* Hit area for easier clicking */}\n      <rect\n        x={x - 10}\n        y={y - 10}\n        width=\"20\"\n        height=\"20\"\n        fill=\"transparent\"\n        onPointerDown={handlePointerDown}\n        onPointerUp={handlePointerUp}\n        className=\"cursor-crosshair\"\n      />\n      {/* Pin label with background for readability */}\n      <g pointerEvents=\"none\">\n        {/* Label background */}\n        <rect\n          x={isRightSide ? x - 12 - pin.length * 5 : x + 10}\n          y={y - 5}\n          width={pin.length * 5 + 4}\n          height=\"11\"\n          rx=\"2\"\n          fill=\"rgba(0,0,0,0.6)\"\n        />\n        {/* Label text */}\n        <text\n          x={isRightSide ? x - 12 : x + 12}\n          y={y + 3}\n          fill={labelColor}\n          fontSize=\"8\"\n          fontFamily=\"monospace\"\n          fontWeight=\"600\"\n          textAnchor={isRightSide ? 'end' : 'start'}\n        >\n          {pin}\n        </text>\n      </g>\n    </g>\n  );\n});\n\n/**\n * Detail renderers for each component type - realistic PCB style.\n */\nconst MicrocontrollerDetails: React.FC<{ width: number; height: number }> = ({ width, height }) => (\n  <g className=\"pointer-events-none\">\n    {/* USB port - black rectangle */}\n    <rect x={width/2 - 15} y=\"2\" width=\"30\" height=\"10\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    {/* Main chip (ATmega) */}\n    <rect x={width/2 - 25} y={height/2 - 12} width=\"50\" height=\"24\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    {/* Chip text */}\n    <text x={width/2} y={height/2 + 2} fill=\"#666\" fontSize=\"6\" textAnchor=\"middle\" fontFamily=\"monospace\">ATmega328P</text>\n    {/* Crystal */}\n    <rect x=\"20\" y={height/2 - 6} width=\"10\" height=\"12\" fill=\"#C0C0C0\" stroke=\"#999\"/>\n    {/* Reset button */}\n    <rect x={width - 25} y=\"20\" width=\"10\" height=\"6\" fill=\"#333\" stroke=\"#555\"/>\n    {/* Power LED */}\n    <circle cx=\"15\" cy={height - 15} r=\"2\" fill=\"#22C55E\"/>\n    {/* TX/RX LEDs */}\n    <circle cx=\"25\" cy={height - 15} r=\"1.5\" fill=\"#FACC15\"/>\n    <circle cx=\"32\" cy={height - 15} r=\"1.5\" fill=\"#3B82F6\"/>\n    {/* Pin header indicators */}\n    <rect x=\"0\" y=\"28\" width=\"4\" height={height - 40} fill={COLORS.copper} opacity=\"0.6\"/>\n    <rect x={width - 4} y=\"28\" width=\"4\" height={height - 40} fill={COLORS.copper} opacity=\"0.6\"/>\n  </g>\n);\n\n/**\n * Arduino Uno R3 - Realistic Fritzing-style visual\n * Includes USB-B port, barrel jack, ATmega chips, crystal, LEDs, headers\n */\nconst ArduinoUnoDetails: React.FC<{ width: number; height: number }> = ({ width, height }) => (\n  <g className=\"pointer-events-none\">\n    {/* PCB base color overlay for depth */}\n    <rect x=\"2\" y=\"2\" width={width - 4} height={height - 4} fill=\"#006D65\" opacity=\"0.3\" />\n\n    {/* USB-B Port (silver metal housing) */}\n    <rect x={width/2 - 20} y=\"3\" width=\"40\" height=\"18\" fill=\"#A0A0A0\" stroke=\"#606060\" strokeWidth=\"1\"/>\n    <rect x={width/2 - 16} y=\"6\" width=\"32\" height=\"12\" fill=\"#1E1E1E\"/>\n    <rect x={width/2 - 12} y=\"9\" width=\"24\" height=\"6\" fill=\"#333\"/>\n\n    {/* Barrel Jack (power connector) - left side */}\n    <rect x=\"3\" y=\"3\" width=\"25\" height=\"18\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    <circle cx=\"15\" cy=\"12\" r=\"5\" fill=\"#333\" stroke=\"#555\"/>\n    <circle cx=\"15\" cy=\"12\" r=\"2\" fill=\"#1E1E1E\"/>\n\n    {/* Reset Button (red) */}\n    <rect x={width - 45} y=\"8\" width=\"12\" height=\"8\" fill=\"#DC2626\" stroke=\"#991B1B\" strokeWidth=\"1\" rx=\"1\"/>\n    <text x={width - 39} y=\"26\" fill={COLORS.white} fontSize=\"5\" textAnchor=\"middle\" fontFamily=\"sans-serif\">RESET</text>\n\n    {/* ICSP Header (2x3 pins) */}\n    <rect x={width/2 + 40} y=\"25\" width=\"18\" height=\"12\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    <text x={width/2 + 49} y=\"45\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"middle\">ICSP</text>\n    {/* ICSP pins */}\n    {[0, 1, 2].map(i => (\n      <g key={`icsp-top-${i}`}>\n        <circle cx={width/2 + 44 + i*6} cy=\"28\" r=\"1.5\" fill={COLORS.copper}/>\n        <circle cx={width/2 + 44 + i*6} cy=\"34\" r=\"1.5\" fill={COLORS.copper}/>\n      </g>\n    ))}\n\n    {/* ATmega328P Main Chip (large DIP-28) */}\n    <rect x={width/2 - 35} y={height/2 - 25} width=\"70\" height=\"50\" fill=\"#1E1E1E\" stroke=\"#333\" strokeWidth=\"1\"/>\n    <circle cx={width/2 - 28} cy={height/2 - 18} r=\"3\" fill=\"#333\"/> {/* Pin 1 notch */}\n    <text x={width/2} y={height/2 - 5} fill=\"#555\" fontSize=\"6\" textAnchor=\"middle\" fontFamily=\"monospace\">ATMEGA328P</text>\n    <text x={width/2} y={height/2 + 5} fill=\"#444\" fontSize=\"5\" textAnchor=\"middle\" fontFamily=\"monospace\">-PU</text>\n\n    {/* ATmega16U2 USB Chip (smaller, near USB port) */}\n    <rect x={width/2 - 50} y=\"30\" width=\"25\" height=\"18\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    <text x={width/2 - 37} y=\"42\" fill=\"#444\" fontSize=\"4\" textAnchor=\"middle\" fontFamily=\"monospace\">16U2</text>\n\n    {/* Crystal Oscillators */}\n    <rect x=\"60\" y={height/2 - 8} width=\"16\" height=\"8\" fill=\"#C0C0C0\" stroke=\"#888\"/>\n    <text x=\"68\" y={height/2 + 10} fill={COLORS.subtleText} fontSize=\"4\" textAnchor=\"middle\">16MHz</text>\n    <rect x={width/2 - 60} y=\"45\" width=\"10\" height=\"5\" fill=\"#C0C0C0\" stroke=\"#888\"/>\n\n    {/* Status LEDs with labels */}\n    <g transform=\"translate(30, 155)\">\n      {/* ON LED (green) */}\n      <circle cx=\"0\" cy=\"0\" r=\"3\" fill=\"#22C55E\"/>\n      <text x=\"0\" y=\"12\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"middle\">ON</text>\n      {/* L LED (orange) */}\n      <circle cx=\"20\" cy=\"0\" r=\"3\" fill=\"#F97316\"/>\n      <text x=\"20\" y=\"12\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"middle\">L</text>\n      {/* TX LED (yellow) */}\n      <circle cx=\"40\" cy=\"0\" r=\"2.5\" fill=\"#FACC15\"/>\n      <text x=\"40\" y=\"12\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"middle\">TX</text>\n      {/* RX LED (yellow) */}\n      <circle cx=\"55\" cy=\"0\" r=\"2.5\" fill=\"#FACC15\"/>\n      <text x=\"55\" y=\"12\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"middle\">RX</text>\n    </g>\n\n    {/* Pin Header Strips - Black plastic with copper contacts */}\n    {/* Left header (Power + Analog) */}\n    <rect x=\"3\" y=\"30\" width=\"8\" height=\"65\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    <rect x=\"3\" y=\"115\" width=\"8\" height=\"70\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    {/* Right header (Digital) */}\n    <rect x={width - 11} y=\"20\" width=\"8\" height=\"175\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n\n    {/* Silkscreen Arduino Logo/Text */}\n    <text x={width/2} y={height - 25} fill={COLORS.white} fontSize=\"14\" fontWeight=\"bold\" textAnchor=\"middle\" fontFamily=\"Arial, sans-serif\">ARDUINO</text>\n    <text x={width/2} y={height - 12} fill={COLORS.white} fontSize=\"10\" textAnchor=\"middle\" fontFamily=\"Arial, sans-serif\">UNO R3</text>\n\n    {/* Mounting holes (4 corners) */}\n    <circle cx=\"14\" cy={height - 8} r=\"4\" fill=\"none\" stroke=\"#005C5F\" strokeWidth=\"2\"/>\n    <circle cx={width - 14} cy={height - 8} r=\"4\" fill=\"none\" stroke=\"#005C5F\" strokeWidth=\"2\"/>\n    <circle cx=\"14\" cy=\"25\" r=\"4\" fill=\"none\" stroke=\"#005C5F\" strokeWidth=\"2\"/>\n    <circle cx={width - 14} cy=\"25\" r=\"4\" fill=\"none\" stroke=\"#005C5F\" strokeWidth=\"2\"/>\n\n    {/* Voltage regulator */}\n    <rect x=\"35\" y=\"50\" width=\"15\" height=\"20\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n\n    {/* Capacitors (electrolytic) */}\n    <circle cx=\"55\" cy=\"60\" r=\"6\" fill=\"#1E3A5F\" stroke=\"#2563EB\"/>\n    <circle cx={width - 50} cy=\"55\" r=\"5\" fill=\"#1E3A5F\" stroke=\"#2563EB\"/>\n\n    {/* Pin labels for digital header */}\n    <text x={width - 20} y=\"38\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">0 RX</text>\n    <text x={width - 20} y=\"49\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">1 TX</text>\n    <text x={width - 20} y=\"60\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">2</text>\n    <text x={width - 20} y=\"71\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">~3</text>\n    <text x={width - 20} y=\"82\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">4</text>\n    <text x={width - 20} y=\"93\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">~5</text>\n    <text x={width - 20} y=\"104\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">~6</text>\n    <text x={width - 20} y=\"115\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">7</text>\n    <text x={width - 20} y=\"131\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">8</text>\n    <text x={width - 20} y=\"142\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">~9</text>\n    <text x={width - 20} y=\"153\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">~10</text>\n    <text x={width - 20} y=\"164\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">~11</text>\n    <text x={width - 20} y=\"175\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">12</text>\n    <text x={width - 20} y=\"186\" fill={COLORS.subtleText} fontSize=\"5\" textAnchor=\"end\">13</text>\n\n    {/* Pin labels for power/analog header */}\n    <text x=\"18\" y=\"38\" fill={COLORS.subtleText} fontSize=\"5\">RST</text>\n    <text x=\"18\" y=\"49\" fill={COLORS.subtleText} fontSize=\"5\">3V3</text>\n    <text x=\"18\" y=\"60\" fill={COLORS.subtleText} fontSize=\"5\">5V</text>\n    <text x=\"18\" y=\"71\" fill={COLORS.subtleText} fontSize=\"5\">GND</text>\n    <text x=\"18\" y=\"82\" fill={COLORS.subtleText} fontSize=\"5\">GND</text>\n    <text x=\"18\" y=\"93\" fill={COLORS.subtleText} fontSize=\"5\">VIN</text>\n    <text x=\"18\" y=\"123\" fill={COLORS.subtleText} fontSize=\"5\">A0</text>\n    <text x=\"18\" y=\"134\" fill={COLORS.subtleText} fontSize=\"5\">A1</text>\n    <text x=\"18\" y=\"145\" fill={COLORS.subtleText} fontSize=\"5\">A2</text>\n    <text x=\"18\" y=\"156\" fill={COLORS.subtleText} fontSize=\"5\">A3</text>\n    <text x=\"18\" y=\"167\" fill={COLORS.subtleText} fontSize=\"5\">A4</text>\n    <text x=\"18\" y=\"178\" fill={COLORS.subtleText} fontSize=\"5\">A5</text>\n  </g>\n);\n\nconst SensorDetails: React.FC<{ width: number; height: number }> = ({ width, height }) => (\n  <g className=\"pointer-events-none\">\n    {/* Sensing element - center circle */}\n    <circle cx={width/2} cy={height/2} r=\"12\" fill=\"#1E1E1E\" stroke={COLORS.sensorPurple} strokeWidth=\"2\"/>\n    {/* Sensor chip */}\n    <rect x={width/2 - 8} y={height/2 - 4} width=\"16\" height=\"8\" fill=\"#333\"/>\n    {/* Trim pot */}\n    <rect x=\"10\" y={height - 18} width=\"8\" height=\"8\" fill=\"#1E1E1E\" stroke=\"#555\"/>\n    <line x1=\"14\" y1={height - 16} x2=\"14\" y2={height - 12} stroke={COLORS.copper} strokeWidth=\"2\"/>\n    {/* Pin header */}\n    <rect x=\"0\" y=\"24\" width=\"3\" height={height - 32} fill={COLORS.copper} opacity=\"0.6\"/>\n  </g>\n);\n\n/**\n * DHT11/DHT22 - Temperature & Humidity Sensor\n * Realistic blue plastic housing with ventilation grid and sensing element\n */\nconst DHT11Details: React.FC<{ width: number; height: number }> = ({ width, height }) => (\n  <g className=\"pointer-events-none\">\n    {/* Blue plastic housing highlights */}\n    <rect x=\"3\" y=\"18\" width={width - 6} height={height - 24} fill=\"#3B82F6\" opacity=\"0.15\" />\n\n    {/* Ventilation grid pattern (sensing area) */}\n    <rect x=\"8\" y=\"20\" width={width - 16} height=\"28\" fill=\"#1E40AF\" opacity=\"0.3\" rx=\"2\"/>\n    {/* Grid lines - horizontal */}\n    {[0, 1, 2, 3, 4, 5, 6].map(i => (\n      <line key={`h-${i}`} x1=\"10\" y1={22 + i * 4} x2={width - 10} y2={22 + i * 4} stroke=\"#1E3A8A\" strokeWidth=\"1\" opacity=\"0.6\"/>\n    ))}\n    {/* Grid lines - vertical */}\n    {[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(i => (\n      <line key={`v-${i}`} x1={12 + i * 5} y1=\"20\" x2={12 + i * 5} y2=\"48\" stroke=\"#1E3A8A\" strokeWidth=\"1\" opacity=\"0.6\"/>\n    ))}\n\n    {/* Internal sensor element (hidden behind grid) */}\n    <circle cx={width/2} cy=\"34\" r=\"8\" fill=\"#1E1E1E\" stroke=\"#333\" opacity=\"0.7\"/>\n\n    {/* Humidity sensing element indicator */}\n    <rect x={width/2 - 5} y=\"30\" width=\"10\" height=\"8\" fill=\"#374151\" stroke=\"#555\" strokeWidth=\"0.5\"/>\n\n    {/* Model label */}\n    <text x={width/2} y={height - 8} fill=\"#93C5FD\" fontSize=\"7\" textAnchor=\"middle\" fontFamily=\"monospace\" fontWeight=\"600\">DHT11</text>\n\n    {/* Pin labels at bottom */}\n    <g transform={`translate(0, ${height - 15})`}>\n      <text x=\"12\" y=\"0\" fill=\"#BFDBFE\" fontSize=\"5\" textAnchor=\"middle\">VCC</text>\n      <text x=\"28\" y=\"0\" fill=\"#BFDBFE\" fontSize=\"5\" textAnchor=\"middle\">DATA</text>\n      <text x=\"44\" y=\"0\" fill=\"#BFDBFE\" fontSize=\"5\" textAnchor=\"middle\">NC</text>\n      <text x=\"60\" y=\"0\" fill=\"#BFDBFE\" fontSize=\"5\" textAnchor=\"middle\">GND</text>\n    </g>\n\n    {/* Temperature icon */}\n    <g transform=\"translate(5, 52)\">\n      <rect x=\"0\" y=\"0\" width=\"3\" height=\"6\" fill=\"#EF4444\" rx=\"1\"/>\n      <circle cx=\"1.5\" cy=\"8\" r=\"2\" fill=\"#EF4444\"/>\n    </g>\n\n    {/* Humidity icon */}\n    <g transform={`translate(${width - 12}, 52)`}>\n      <path d=\"M 3 0 Q 0 4 3 7 Q 6 4 3 0 Z\" fill=\"#3B82F6\"/>\n    </g>\n  </g>\n);\n\n/**\n * LCD 1602 - 16x2 Character LCD Display\n * Green PCB with LCD screen, contrast pot, and backlight\n */\nconst LCD1602Details: React.FC<{ width: number; height: number }> = ({ width, height }) => (\n  <g className=\"pointer-events-none\">\n    {/* LCD screen bezel (dark frame) */}\n    <rect x=\"10\" y=\"20\" width={width - 20} height=\"42\" fill=\"#1E1E1E\" stroke=\"#333\" strokeWidth=\"1\"/>\n\n    {/* LCD screen glass with green backlight */}\n    <rect x=\"14\" y=\"24\" width={width - 28} height=\"34\" fill=\"url(#gradient-lcd-screen)\" stroke=\"#556B2F\"/>\n\n    {/* Character grid indicator - 16x2 */}\n    {/* Row 1 */}\n    {Array.from({ length: 16 }, (_, i) => (\n      <rect key={`r1-${i}`} x={18 + i * 8} y=\"28\" width=\"6\" height=\"10\" fill=\"#4B5320\" opacity=\"0.4\"/>\n    ))}\n    {/* Row 2 */}\n    {Array.from({ length: 16 }, (_, i) => (\n      <rect key={`r2-${i}`} x={18 + i * 8} y=\"44\" width=\"6\" height=\"10\" fill=\"#4B5320\" opacity=\"0.4\"/>\n    ))}\n\n    {/* Sample text on LCD */}\n    <text x=\"20\" y=\"36\" fill=\"#2E3B18\" fontSize=\"7\" fontFamily=\"monospace\" opacity=\"0.6\">Hello World!</text>\n    <text x=\"20\" y=\"52\" fill=\"#2E3B18\" fontSize=\"7\" fontFamily=\"monospace\" opacity=\"0.6\">CircuitMind AI</text>\n\n    {/* I2C backpack chip (if applicable) */}\n    <rect x=\"5\" y=\"65\" width=\"20\" height=\"10\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    <text x=\"15\" y=\"72\" fill=\"#444\" fontSize=\"4\" textAnchor=\"middle\" fontFamily=\"monospace\">I2C</text>\n\n    {/* Contrast potentiometer */}\n    <circle cx={width - 15} cy=\"68\" r=\"5\" fill=\"#1E1E1E\" stroke=\"#555\"/>\n    <line x1={width - 15} y1=\"65\" x2={width - 15} y2=\"68\" stroke={COLORS.copper} strokeWidth=\"1.5\"/>\n    <text x={width - 15} y=\"78\" fill={COLORS.subtleText} fontSize=\"4\" textAnchor=\"middle\">CONT</text>\n\n    {/* Backlight LED indicator */}\n    <circle cx=\"8\" y=\"68\" r=\"2\" fill=\"#22C55E\"/>\n    <text x=\"8\" y=\"78\" fill={COLORS.subtleText} fontSize=\"4\" textAnchor=\"middle\">BL</text>\n\n    {/* Pin header strip at bottom */}\n    <rect x=\"30\" y={height - 8} width={width - 60} height=\"6\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n\n    {/* Module label */}\n    <text x={width/2} y=\"14\" fill={COLORS.white} fontSize=\"6\" textAnchor=\"middle\" fontFamily=\"sans-serif\">LCD 1602 Module</text>\n  </g>\n);\n\n/**\n * Breadboard - 830/400/170 Point Solderless Breadboard\n * Realistic with power rails, connection holes, and center divider\n */\nconst BreadboardDetails: React.FC<{ width: number; height: number }> = ({ width, height }) => (\n  <g className=\"pointer-events-none\">\n    {/* Top power rail (red +) */}\n    <rect x=\"5\" y=\"5\" width={width - 10} height=\"12\" fill=\"#FEE2E2\" stroke=\"#FCA5A5\" strokeWidth=\"0.5\"/>\n    <line x1=\"8\" y1=\"8\" x2={width - 8} y2=\"8\" stroke=\"#EF4444\" strokeWidth=\"2\"/>\n    <text x=\"10\" y=\"14\" fill=\"#DC2626\" fontSize=\"8\" fontWeight=\"bold\">+</text>\n    {/* Power rail holes - top */}\n    {Array.from({ length: Math.floor((width - 20) / 8) }, (_, i) => (\n      <circle key={`ptr-${i}`} cx={14 + i * 8} cy=\"11\" r=\"1.5\" fill=\"#333\"/>\n    ))}\n\n    {/* Top ground rail (blue -) */}\n    <rect x=\"5\" y=\"18\" width={width - 10} height=\"12\" fill=\"#DBEAFE\" stroke=\"#93C5FD\" strokeWidth=\"0.5\"/>\n    <line x1=\"8\" y1=\"21\" x2={width - 8} y2=\"21\" stroke=\"#3B82F6\" strokeWidth=\"2\"/>\n    <text x=\"10\" y=\"27\" fill=\"#2563EB\" fontSize=\"8\" fontWeight=\"bold\"></text>\n    {/* Ground rail holes - top */}\n    {Array.from({ length: Math.floor((width - 20) / 8) }, (_, i) => (\n      <circle key={`pgr-${i}`} cx={14 + i * 8} cy=\"24\" r=\"1.5\" fill=\"#333\"/>\n    ))}\n\n    {/* Main breadboard area - top half */}\n    <rect x=\"5\" y=\"32\" width={width - 10} height=\"32\" fill=\"#F5F5F4\" stroke=\"#D6D3D1\"/>\n    {/* Connection holes - top section (5 rows) */}\n    {Array.from({ length: 5 }, (_, row) => (\n      <g key={`row-t-${row}`}>\n        {Array.from({ length: Math.floor((width - 16) / 8) }, (_, col) => (\n          <circle key={`ht-${row}-${col}`} cx={12 + col * 8} cy={38 + row * 6} r=\"1.2\" fill=\"#333\"/>\n        ))}\n      </g>\n    ))}\n\n    {/* Center divider channel */}\n    <rect x=\"5\" y=\"64\" width={width - 10} height=\"8\" fill=\"#E7E5E4\" stroke=\"#D6D3D1\"/>\n    <line x1=\"8\" y1=\"68\" x2={width - 8} y2=\"68\" stroke=\"#A8A29E\" strokeDasharray=\"3,2\"/>\n\n    {/* Main breadboard area - bottom half */}\n    <rect x=\"5\" y=\"72\" width={width - 10} height=\"32\" fill=\"#F5F5F4\" stroke=\"#D6D3D1\"/>\n    {/* Connection holes - bottom section (5 rows) */}\n    {Array.from({ length: 5 }, (_, row) => (\n      <g key={`row-b-${row}`}>\n        {Array.from({ length: Math.floor((width - 16) / 8) }, (_, col) => (\n          <circle key={`hb-${row}-${col}`} cx={12 + col * 8} cy={78 + row * 6} r=\"1.2\" fill=\"#333\"/>\n        ))}\n      </g>\n    ))}\n\n    {/* Bottom ground rail (blue -) */}\n    <rect x=\"5\" y={height - 29} width={width - 10} height=\"12\" fill=\"#DBEAFE\" stroke=\"#93C5FD\" strokeWidth=\"0.5\"/>\n    <line x1=\"8\" y1={height - 26} x2={width - 8} y2={height - 26} stroke=\"#3B82F6\" strokeWidth=\"2\"/>\n    <text x=\"10\" y={height - 20} fill=\"#2563EB\" fontSize=\"8\" fontWeight=\"bold\"></text>\n\n    {/* Bottom power rail (red +) */}\n    <rect x=\"5\" y={height - 16} width={width - 10} height=\"12\" fill=\"#FEE2E2\" stroke=\"#FCA5A5\" strokeWidth=\"0.5\"/>\n    <line x1=\"8\" y1={height - 13} x2={width - 8} y2={height - 13} stroke=\"#EF4444\" strokeWidth=\"2\"/>\n    <text x=\"10\" y={height - 7} fill=\"#DC2626\" fontSize=\"8\" fontWeight=\"bold\">+</text>\n\n    {/* Row labels */}\n    <text x={width - 6} y=\"42\" fill=\"#78716C\" fontSize=\"5\" textAnchor=\"end\">A</text>\n    <text x={width - 6} y=\"48\" fill=\"#78716C\" fontSize=\"5\" textAnchor=\"end\">B</text>\n    <text x={width - 6} y=\"54\" fill=\"#78716C\" fontSize=\"5\" textAnchor=\"end\">C</text>\n    <text x={width - 6} y=\"60\" fill=\"#78716C\" fontSize=\"5\" textAnchor=\"end\">D</text>\n    <text x={width - 6} y=\"82\" fill=\"#78716C\" fontSize=\"5\" textAnchor=\"end\">E</text>\n    <text x={width - 6} y=\"88\" fill=\"#78716C\" fontSize=\"5\" textAnchor=\"end\">F</text>\n    <text x={width - 6} y=\"94\" fill=\"#78716C\" fontSize=\"5\" textAnchor=\"end\">G</text>\n    <text x={width - 6} y=\"100\" fill=\"#78716C\" fontSize=\"5\" textAnchor=\"end\">H</text>\n  </g>\n);\n\nconst ActuatorDetails: React.FC = () => (\n  <g className=\"pointer-events-none\">\n    {/* LED lens highlight */}\n    <ellipse cx=\"25\" cy=\"20\" rx=\"10\" ry=\"8\" fill=\"white\" opacity=\"0.3\"/>\n    {/* LED glow */}\n    <circle cx=\"25\" cy=\"30\" r=\"8\" fill={COLORS.ledRed} opacity=\"0.4\"/>\n    {/* Flat spot indicator (cathode) */}\n    <line x1=\"12\" y1=\"45\" x2=\"12\" y2=\"50\" stroke=\"#666\" strokeWidth=\"2\"/>\n    {/* Lead wires */}\n    <rect x=\"16\" y=\"55\" width=\"3\" height=\"20\" fill={COLORS.legs}/>\n    <rect x=\"31\" y=\"55\" width=\"3\" height=\"20\" fill={COLORS.legs}/>\n  </g>\n);\n\nconst PowerDetails: React.FC<{ width: number }> = ({ width: _width }) => (\n  <g className=\"pointer-events-none\">\n    {/* Battery cells */}\n    <rect x=\"10\" y=\"12\" width=\"25\" height=\"26\" fill=\"#1E1E1E\" stroke=\"#22C55E\" strokeWidth=\"1\"/>\n    <rect x=\"40\" y=\"12\" width=\"25\" height=\"26\" fill=\"#1E1E1E\" stroke=\"#22C55E\" strokeWidth=\"1\"/>\n    {/* Positive terminal */}\n    <rect x=\"87\" y=\"15\" width=\"10\" height=\"20\" fill=\"#22C55E\"/>\n    {/* Polarity labels */}\n    <text x=\"22\" y=\"28\" fill=\"#22C55E\" fontSize=\"12\" fontWeight=\"bold\" textAnchor=\"middle\">+</text>\n    <text x=\"52\" y=\"28\" fill=\"#EF4444\" fontSize=\"12\" fontWeight=\"bold\" textAnchor=\"middle\"></text>\n  </g>\n);\n\nconst ResistorDetails: React.FC = () => (\n  <g className=\"pointer-events-none\">\n    {/* Lead wires */}\n    <line x1=\"0\" y1=\"15\" x2=\"20\" y2=\"15\" stroke={COLORS.legs} strokeWidth=\"2\"/>\n    <line x1=\"80\" y1=\"15\" x2=\"100\" y2=\"15\" stroke={COLORS.legs} strokeWidth=\"2\"/>\n    {/* Color bands */}\n    <rect x=\"25\" y=\"7\" width=\"5\" height=\"16\" fill=\"#DC2626\"/>\n    <rect x=\"35\" y=\"7\" width=\"5\" height=\"16\" fill=\"#7C3AED\"/>\n    <rect x=\"45\" y=\"7\" width=\"5\" height=\"16\" fill=\"#B45309\"/>\n    <rect x=\"60\" y=\"7\" width=\"5\" height=\"16\" fill=\"#D4AF37\"/>\n  </g>\n);\n\nconst CapacitorDetails: React.FC = () => (\n  <g className=\"pointer-events-none\">\n    {/* Polarity stripe */}\n    <rect x=\"5\" y=\"15\" width=\"5\" height=\"35\" fill=\"#3B82F6\" opacity=\"0.3\"/>\n    {/* Plus symbol */}\n    <text x=\"8\" y=\"12\" fill=\"#3B82F6\" fontSize=\"10\" fontWeight=\"bold\">+</text>\n    {/* Value label */}\n    <text x=\"20\" y=\"38\" fill={COLORS.subtleText} fontSize=\"7\" fontFamily=\"monospace\">100F</text>\n    {/* Lead wires */}\n    <line x1=\"15\" y1=\"50\" x2=\"15\" y2=\"60\" stroke={COLORS.legs} strokeWidth=\"2\"/>\n    <line x1=\"25\" y1=\"50\" x2=\"25\" y2=\"60\" stroke={COLORS.legs} strokeWidth=\"2\"/>\n  </g>\n);\n\nconst GenericDetails: React.FC<{ width: number; height: number }> = ({ width, height }) => (\n  <g className=\"pointer-events-none\">\n    {/* DIP chip body */}\n    <rect x=\"8\" y={height/2 - 10} width={width - 16} height=\"20\" fill=\"#1E1E1E\" stroke=\"#333\"/>\n    {/* Notch indicator */}\n    <circle cx=\"16\" cy={height/2} r=\"3\" fill=\"#333\"/>\n    {/* Pin rows */}\n    <rect x=\"0\" y=\"20\" width=\"3\" height={height - 28} fill={COLORS.legs} opacity=\"0.5\"/>\n    <rect x={width - 3} y=\"20\" width=\"3\" height={height - 28} fill={COLORS.legs} opacity=\"0.5\"/>\n  </g>\n);\n\n/**\n * DiagramNode component - Fritzing-style realistic breadboard visuals.\n * Sharp corners, proper colors, professional design.\n */\nconst DiagramNode = memo<DiagramNodeProps>(function DiagramNode({\n  component,\n  position,\n  isHovered,\n  isSelected,\n  highlight,\n  onPointerDown,\n  onSelect,\n  onContextMenu,\n  onDoubleClick,\n  onPinPointerDown,\n  onPinPointerUp,\n  onMouseEnter,\n  onMouseLeave,\n  onPinEnter,\n  onPinLeave,\n}) {\n  const isHighlighted = !!highlight;\n\n  const shape = useMemo(() => {\n    const base = getComponentShape(component.type, component.name);\n    // If we have a FZPZ footprint, override width/height\n    if (component.footprint) {\n      return {\n        ...base,\n        width: component.footprint.width,\n        height: component.footprint.height\n      };\n    }\n    return base;\n  }, [component.type, component.name, component.footprint]);\n\n  const pinPositions = useMemo(\n    () => calculatePinPositions(shape, component.pins || [], component),\n    [shape, component.pins, component]\n  );\n\n  const handlePointerDown = useCallback(\n    (e: React.PointerEvent) => onPointerDown(e, component.id),\n    [onPointerDown, component.id]\n  );\n\n  const handleMouseEnter = useCallback(\n    (e: React.MouseEvent) => onMouseEnter?.(e, component),\n    [onMouseEnter, component]\n  );\n\n  const handleMouseLeave = useCallback(\n    (e: React.MouseEvent) => onMouseLeave?.(e, component),\n    [onMouseLeave, component]\n  );\n\n  const handleClick = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (onSelect) onSelect(component.id);\n    },\n    [onSelect, component.id]\n  );\n\n  const handleContextMenu = useCallback(\n    (e: React.MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (onContextMenu) onContextMenu(component.id, e.clientX, e.clientY);\n    },\n    [onContextMenu, component.id]\n  );\n\n  const handleDoubleClick = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (onDoubleClick) onDoubleClick(component);\n    },\n    [onDoubleClick, component]\n  );\n\n  const { liveData } = useTelemetry();\n  const hasActiveTelemetry = useMemo(() => {\n    return Object.keys(liveData).some(key => key.startsWith(`${component.id}:`));\n  }, [liveData, component.id]);\n\n  const { result: simResult } = useSimulation();\n  const hasLogicError = useMemo(() => {\n    if (!simResult) return false;\n    return Object.keys(simResult.pinStates).some(key => \n      key.startsWith(`${component.id}:`) && simResult.pinStates[key].logicState === 'ERROR'\n    );\n  }, [simResult, component.id]);\n\n  const strokeColor = isHighlighted\n    ? highlight.color\n    : hasLogicError\n      ? '#ef4444'\n      : isSelected\n        ? '#00F3FF'\n        : isHovered\n          ? '#00F3FF'\n          : shape.stroke;\n\n  const strokeWidth = isHighlighted ? 3 : isSelected ? 3 : isHovered ? 2.5 : shape.strokeWidth;\n\n  // Render component-specific details based on shape type\n  const renderDetails = () => {\n    // Priority 1: FZPZ Visuals\n    if (component.fzpzSource) {\n        return <FzpzVisual component={component} />;\n    }\n\n    // Special part visuals\n    if (component.name.toLowerCase().includes('breadboard')) {\n        return <BreadboardVisual component={component} />;\n    }\n\n    switch (shape.type) {\n      case 'resistor':\n        return <ResistorDetails />;\n      case 'capacitor':\n        return <CapacitorDetails />;\n      case 'arduino_uno':\n        return <ArduinoUnoDetails width={shape.width} height={shape.height} />;\n      case 'microcontroller':\n        return <MicrocontrollerDetails width={shape.width} height={shape.height} />;\n      case 'dht11':\n        return <DHT11Details width={shape.width} height={shape.height} />;\n      case 'lcd1602':\n        return <LCD1602Details width={shape.width} height={shape.height} />;\n      case 'breadboard':\n        return <BreadboardDetails width={shape.width} height={shape.height} />;\n      case 'sensor':\n        return <SensorDetails width={shape.width} height={shape.height} />;\n      case 'actuator':\n        return <ActuatorDetails />;\n      case 'power':\n        return <PowerDetails width={shape.width} />;\n      default:\n        return <GenericDetails width={shape.width} height={shape.height} />;\n    }\n  };\n\n  const bodyPath = component.footprint \n    ? `M 0 0 L ${shape.width} 0 L ${shape.width} ${shape.height} L 0 ${shape.height} Z`\n    : shape.path;\n\n  return (\n    <g\n      transform={`translate(${position.x}, ${position.y})`}\n      className={`pointer-events-auto cursor-grab active:cursor-grabbing ${isHighlighted && highlight.pulse ? 'component-highlighted' : ''} ${hasActiveTelemetry ? 'telemetry-active' : ''} ${hasLogicError ? 'logic-error' : ''}`}\n      style={\n        isHighlighted\n          ? ({ '--highlight-color': highlight.color } as React.CSSProperties)\n          : undefined\n      }\n      onPointerDown={handlePointerDown}\n      onClick={handleClick}\n      onContextMenu={handleContextMenu}\n      onDoubleClick={handleDoubleClick}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n    >\n      {/* Glow effect for highlighted/selected components */}\n      {(isHighlighted || isSelected) && (\n        <path\n          d={bodyPath}\n          fill=\"none\"\n          stroke={isHighlighted ? highlight.color : '#00F3FF'}\n          strokeWidth=\"6\"\n          opacity=\"0.4\"\n          className={isHighlighted && highlight.pulse ? 'animate-pulse' : ''}\n          style={{ filter: `drop-shadow(0 0 8px ${isHighlighted ? highlight.color : '#00F3FF'})` }}\n        />\n      )}\n\n      {/* Hover glow effect */}\n      {isHovered && !isHighlighted && !isSelected && (\n        <path\n          d={bodyPath}\n          fill=\"none\"\n          stroke=\"#00F3FF\"\n          strokeWidth=\"4\"\n          opacity=\"0.3\"\n          style={{ filter: 'drop-shadow(0 0 6px #00F3FF)' }}\n        />\n      )}\n\n      {/* Drop shadow for 3D depth (rendered behind component) */}\n      <path\n        d={bodyPath}\n        fill=\"rgba(0,0,0,0.3)\"\n        stroke=\"none\"\n        transform=\"translate(3, 4)\"\n        style={{ filter: 'blur(4px)' }}\n        className=\"pointer-events-none\"\n      />\n\n      {/* Component body - sharp corners with gradient fills */}\n      {!component.fzpzSource && (\n        <path\n          d={bodyPath}\n          fill={shape.fill}\n          stroke={strokeColor}\n          strokeWidth={strokeWidth}\n          className=\"transition-colors duration-150\"\n          style={{\n            filter: isHovered ? 'brightness(1.1)' : undefined,\n          }}\n        />\n      )}\n\n      {/* Component details */}\n      {renderDetails()}\n\n      {/* Header bar (for components with headers) */}\n      {!component.fzpzSource && shape.headerHeight > 0 && (\n        <rect\n          width={shape.width}\n          height={shape.headerHeight}\n          fill={shape.headerFill}\n          className=\"pointer-events-none\"\n        />\n      )}\n\n      {/* Component name */}\n      <text\n        x=\"8\"\n        y={shape.headerHeight > 0 ? 16 : 12}\n        fill={COLORS.white}\n        fontSize=\"10\"\n        fontWeight=\"600\"\n        fontFamily=\"system-ui, -apple-system, sans-serif\"\n        pointerEvents=\"none\"\n      >\n        {component.name.length > 20 ? component.name.slice(0, 18) + '' : component.name}\n      </text>\n\n      {/* Component type label */}\n      <text\n        x=\"8\"\n        y={shape.height - 6}\n        fill={COLORS.subtleText}\n        fontSize=\"8\"\n        fontFamily=\"monospace\"\n        pointerEvents=\"none\"\n      >\n        {shape.type.toUpperCase()}\n      </text>\n\n      {/* Render pins */}\n      {pinPositions.map((pinDef, index) => (\n        <React.Fragment key={`pin-wrapper-${pinDef.name}-${index}`}>\n          <Pin\n            pin={pinDef.name}\n            x={pinDef.x}\n            y={pinDef.y}\n            nodeId={component.id}\n            isRightSide={pinDef.side === 'right'}\n            shape={shape}\n            onPointerDown={onPinPointerDown}\n            onPointerUp={onPinPointerUp}\n            onMouseEnter={onPinEnter}\n            onMouseLeave={onPinLeave}\n          />\n          <TelemetryOverlay \n            pin={pinDef.name}\n            componentId={component.id}\n            x={pinDef.x}\n            y={pinDef.y}\n            isRightSide={pinDef.side === 'right'}\n          />\n          <PinStatusDot\n            pin={pinDef.name}\n            componentId={component.id}\n            x={pinDef.x}\n            y={pinDef.y}\n          />\n        </React.Fragment>\n      ))}\n\n      {/* Quantity badge */}\n      {component.quantity && component.quantity > 1 && (\n        <g transform={`translate(${shape.width - 8}, -8)`}>\n          <rect x=\"-8\" y=\"-8\" width=\"16\" height=\"16\" fill=\"#0F172A\" stroke={shape.stroke} strokeWidth=\"1.5\" />\n          <text textAnchor=\"middle\" y=\"4\" fill={COLORS.white} fontSize=\"10\" fontWeight=\"bold\">\n            {component.quantity}\n          </text>\n        </g>\n      )}\n    </g>\n  );\n});\n\nexport default DiagramNode;\nexport { COMPONENT_WIDTH, COMPONENT_HEIGHT };\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/DiffOverlay.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[827,830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[827,830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\nimport { WiringDiagram, ElectronicComponent } from '../../types';\nimport { diagramDiffService } from '../../services/diagramDiff';\nimport DiagramNode from './DiagramNode';\n\ninterface DiffOverlayProps {\n  baseDiagram: WiringDiagram;\n  compareDiagram: WiringDiagram;\n  positions?: Map<string, { x: number; y: number }>;\n}\n\nexport const DiffOverlay: React.FC<DiffOverlayProps> = ({ baseDiagram, compareDiagram, positions }) => {\n  const diffSet = useMemo(() => \n    diagramDiffService.diff(baseDiagram, compareDiagram),\n    [baseDiagram, compareDiagram]\n  );\n\n  const getPos = (comp: ElectronicComponent) => {\n    if (positions && positions.has(comp.id)) {\n      return positions.get(comp.id)!;\n    }\n    // Fallback if position is augmented on component (legacy/draft)\n    return (comp as any).position || { x: 0, y: 0 };\n  };\n\n  return (\n    <g className=\"diff-overlay\">\n      {/* 1. Removed Components (Ghost Red) */}\n      {baseDiagram.components\n        .filter(c => diffSet.removed.components.includes(c.id))\n        .map(comp => {\n          const pos = getPos(comp);\n          return (\n            <g key={`removed-${comp.id}`} opacity={0.4} style={{ filter: 'grayscale(1) brightness(0.5)' }}>\n              <DiagramNode\n                component={comp}\n                position={pos}\n                isHovered={false}\n                highlight={{ color: '#ef4444', pulse: false }}\n                onPointerDown={() => {}}\n                onPinPointerDown={() => {}}\n                onPinPointerUp={() => {}}\n              />\n              {/* Red X Overlay */}\n              <line \n                x1={pos.x} \n                y1={pos.y} \n                x2={pos.x + 100} \n                y2={pos.y + 100} \n                stroke=\"#ef4444\" \n                strokeWidth=\"2\"\n              />\n            </g>\n          );\n        })}\n\n      {/* 2. Added Components (Glow Green) */}\n      {compareDiagram.components\n        .filter(c => diffSet.added.components.includes(c.id))\n        .map(comp => (\n          <g key={`added-${comp.id}`}>\n            <DiagramNode\n              component={comp}\n              position={getPos(comp)}\n              isHovered={false}\n              highlight={{ color: '#00ff9d', pulse: true }}\n              onPointerDown={() => {}}\n              onPinPointerDown={() => {}}\n              onPinPointerUp={() => {}}\n            />\n          </g>\n        ))}\n\n      {/* 3. Modified Components (Glow Amber) */}\n      {compareDiagram.components\n        .filter(c => diffSet.modified.components.includes(c.id))\n        .map(comp => (\n          <g key={`modified-${comp.id}`}>\n            <DiagramNode\n              component={comp}\n              position={getPos(comp)}\n              isHovered={false}\n              highlight={{ color: '#ffaa00', pulse: true }}\n              onPointerDown={() => {}}\n              onPinPointerDown={() => {}}\n              onPinPointerUp={() => {}}\n            />\n          </g>\n        ))}\n    </g>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/MismatchMarker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/NeuralCursor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/PredictiveGhost.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/RemoteCursor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/TacticalHUD.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/Wire.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/componentShapes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/diagramState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'snap' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":80,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":80,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface Point {\n  x: number;\n  y: number;\n}\n\nexport interface TempWireState {\n  startNodeId: string;\n  startPin: string;\n  startX: number;\n  startY: number;\n}\n\nexport interface DiagramState {\n  // View State\n  zoom: number;\n  pan: Point;\n  \n  // Interaction State\n  interactionMode: 'idle' | 'panning' | 'dragging_node' | 'creating_wire';\n  lastPointerPos: Point;\n  activeNodeId: string | null; // Node being dragged\n  \n  // Layout State\n  nodePositions: Map<string, Point>;\n  \n  // Wire Creation State\n  tempWire: TempWireState | null;\n  cursorPos: Point; // Diagram coordinates\n  \n  // Wire Editing State\n  editingWireIndex: number | null;\n  wireLabelInput: string;\n  wireLabelPos: Point;\n  \n  // UI State\n  hoveredNodeId: string | null;\n  isDragOver: boolean;\n}\n\nexport const INITIAL_STATE: DiagramState = {\n  zoom: 1,\n  pan: { x: 0, y: 0 },\n  interactionMode: 'idle',\n  lastPointerPos: { x: 0, y: 0 },\n  activeNodeId: null,\n  nodePositions: new Map(),\n  tempWire: null,\n  cursorPos: { x: 0, y: 0 },\n  editingWireIndex: null,\n  wireLabelInput: '',\n  wireLabelPos: { x: 0, y: 0 },\n  hoveredNodeId: null,\n  isDragOver: false,\n};\n\nexport type DiagramAction =\n  | { type: 'SET_ZOOM'; payload: number }\n  | { type: 'ZOOM_IN'; payload: number } // delta\n  | { type: 'ZOOM_OUT'; payload: number } // delta\n  | { type: 'SET_PAN'; payload: Point }\n  | { type: 'RESET_VIEW' }\n  | { type: 'START_PAN'; payload: Point } // pointer pos\n  | { type: 'START_DRAG_NODE'; payload: { nodeId: string; pointerPos: Point } }\n  | { type: 'POINTER_MOVE'; payload: { pointerPos: Point; diagramPos: Point; snapToGrid?: boolean; gridSize?: number } }\n  | { type: 'POINTER_UP' }\n  | { type: 'START_WIRE'; payload: TempWireState }\n  | { type: 'SET_NODE_POSITIONS'; payload: Map<string, Point> }\n  | { type: 'UPDATE_NODE_POSITION'; payload: { nodeId: string; x: number; y: number } }\n  | { type: 'SET_HOVERED_NODE'; payload: string | null }\n  | { type: 'SET_DRAG_OVER'; payload: boolean }\n  | { type: 'START_EDIT_WIRE'; payload: { index: number; description: string; position: Point } }\n  | { type: 'UPDATE_WIRE_LABEL'; payload: string }\n  | { type: 'CANCEL_EDIT_WIRE' }\n  | { type: 'SAVE_EDIT_WIRE' }; // Logic handled in component, this just clears state\n\n// Helper for clamping zoom\nconst clampZoom = (z: number) => Math.max(0.2, Math.min(4, z));\n\n// Helper for grid snapping\nconst snap = (val: number, size: number) => Math.round(val / size) * size;\n\nexport function diagramReducer(state: DiagramState, action: DiagramAction): DiagramState {\n  switch (action.type) {\n    case 'SET_ZOOM':\n      return { ...state, zoom: clampZoom(action.payload) };\n      \n    case 'ZOOM_IN':\n      return { ...state, zoom: clampZoom(state.zoom + action.payload) };\n      \n    case 'ZOOM_OUT':\n      return { ...state, zoom: clampZoom(state.zoom - action.payload) }; // payload is positive delta\n      \n    case 'SET_PAN':\n      return { ...state, pan: action.payload };\n      \n    case 'RESET_VIEW':\n      return { ...state, zoom: 1, pan: { x: 0, y: 0 } };\n      \n    case 'START_PAN':\n      return {\n        ...state,\n        interactionMode: 'panning',\n        lastPointerPos: action.payload,\n        editingWireIndex: null, // Close edit on background click\n      };\n      \n    case 'START_DRAG_NODE':\n      return {\n        ...state,\n        interactionMode: 'dragging_node',\n        activeNodeId: action.payload.nodeId,\n        lastPointerPos: action.payload.pointerPos,\n      };\n      \n    case 'POINTER_MOVE': {\n      const { pointerPos, diagramPos, snapToGrid, gridSize = 10 } = action.payload; // Default 10px grid\n      const dx = pointerPos.x - state.lastPointerPos.x;\n      const dy = pointerPos.y - state.lastPointerPos.y;\n      \n      const newState = {\n        ...state,\n        lastPointerPos: pointerPos,\n        cursorPos: diagramPos,\n      };\n      \n      if (state.interactionMode === 'panning') {\n        newState.pan = {\n          x: state.pan.x + dx,\n          y: state.pan.y + dy,\n        };\n      } else if (state.interactionMode === 'dragging_node' && state.activeNodeId) {\n        const currentPos = state.nodePositions.get(state.activeNodeId);\n        if (currentPos) {\n          // Calculate new position based on delta\n          let newX = currentPos.x + dx / state.zoom;\n          let newY = currentPos.y + dy / state.zoom;\n          \n          if (snapToGrid) {\n            newX = Math.round(newX / gridSize) * gridSize;\n            newY = Math.round(newY / gridSize) * gridSize;\n          }\n          \n          // Collision detection placeholder\n          // In a full implementation, we would check intersection with other rects here\n          // and prevent update if overlapping.\n          \n          const newPositions = new Map(state.nodePositions);\n          newPositions.set(state.activeNodeId, { x: newX, y: newY });\n          newState.nodePositions = newPositions;\n        }\n      }\n      \n      return newState;\n    }\n      \n    case 'POINTER_UP':\n      return {\n        ...state,\n        interactionMode: 'idle',\n        activeNodeId: null,\n        tempWire: null,\n      };\n      \n    case 'START_WIRE':\n      return {\n        ...state,\n        interactionMode: 'creating_wire',\n        tempWire: action.payload,\n      };\n      \n    case 'SET_NODE_POSITIONS':\n      return { ...state, nodePositions: action.payload };\n      \n    case 'UPDATE_NODE_POSITION': {\n      const newPositions = new Map(state.nodePositions);\n      newPositions.set(action.payload.nodeId, { x: action.payload.x, y: action.payload.y });\n      return { ...state, nodePositions: newPositions };\n    }\n      \n    case 'SET_HOVERED_NODE':\n      return { ...state, hoveredNodeId: action.payload };\n      \n    case 'SET_DRAG_OVER':\n      return { ...state, isDragOver: action.payload };\n      \n    case 'START_EDIT_WIRE':\n      return {\n        ...state,\n        editingWireIndex: action.payload.index,\n        wireLabelInput: action.payload.description,\n        wireLabelPos: action.payload.position,\n      };\n      \n    case 'UPDATE_WIRE_LABEL':\n      return { ...state, wireLabelInput: action.payload };\n      \n    case 'CANCEL_EDIT_WIRE':\n    case 'SAVE_EDIT_WIRE':\n      return {\n        ...state,\n        editingWireIndex: null,\n        wireLabelInput: '',\n      };\n      \n    default:\n      return state;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/diagramUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/parts/Breadboard.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":10,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":10,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pinId' is defined but never used. Allowed unused args must match /^_/u.","line":10,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React from 'react';\nimport { ElectronicComponent } from '../../../types';\n\ninterface BreadboardProps {\n  component: ElectronicComponent;\n}\n\n// Logic for Breadboard connectivity\nexport const getBreadboardConnectivity = (pinId: string): string[] => {\n    // Expected pinId format: \"breadboard1-row1-a\" or similar, BUT\n    // Standard Fritzing breadboard just has \"connector0\", \"connector1\"...\n    // We need to map connector ID to Row/Column.\n    //\n    // Standard Half+ Breadboard:\n    // Top Power Rails: +, -\n    // Bottom Power Rails: +, -\n    // Terminal Strips: Rows 1-30, Columns A-E and F-J.\n    \n    // Naive implementation: Assume we know the geometry.\n    // In a real implementation, we'd parse the 'buses' from the FZP file.\n    return [];\n};\n\nexport const BreadboardVisual: React.FC<BreadboardProps> = ({ component }) => {\n  // Use the imported FZPZ visual if available\n  if (component.fzpzSource && component.footprint) {\n      // We need to decode the SVG from the source? \n      // Actually, FzpzLoader extracts it. We should store it in the component or a cache.\n      // For now, let's assume we render a placeholder or the \"God Mode\" generated SVG.\n      return (\n          <g>\n              <rect width={component.footprint.width * 10} height={component.footprint.height * 10} fill=\"#f5f6f7\" stroke=\"#e2e4e8\" />\n              {/* Holes */}\n              {component.footprint.pins.map(p => (\n                  <rect key={p.id} x={p.x * 10 - 2} y={p.y * 10 - 2} width=\"4\" height=\"4\" fill=\"#333\" />\n              ))}\n          </g>\n      );\n  }\n\n  // Fallback procedural breadboard\n  return (\n    <g>\n      <rect x=\"0\" y=\"0\" width=\"550\" height=\"180\" rx=\"4\" fill=\"#f5f6f7\" stroke=\"#d1d5db\" strokeWidth=\"1\" />\n      {/* Power Rails Top */}\n      <line x1=\"20\" y1=\"15\" x2=\"530\" y2=\"15\" stroke=\"#ef4444\" strokeWidth=\"2\" opacity=\"0.5\" />\n      <line x1=\"20\" y1=\"25\" x2=\"530\" y2=\"25\" stroke=\"#3b82f6\" strokeWidth=\"2\" opacity=\"0.5\" />\n      \n      {/* Rows */}\n      {Array.from({ length: 30 }).map((_, col) => (\n          <g key={col} transform={`translate(${30 + col * 17}, 50)`}>\n              {/* Top Bank A-E */}\n              <circle cy=\"0\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              <circle cy=\"10\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              <circle cy=\"20\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              <circle cy=\"30\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              <circle cy=\"40\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              \n              {/* Bottom Bank F-J */}\n              <circle cy=\"70\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              <circle cy=\"80\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              <circle cy=\"90\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              <circle cy=\"100\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n              <circle cy=\"110\" r=\"2\" fill=\"#333\" opacity=\"0.2\" />\n          </g>\n      ))}\n    </g>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/parts/FzpzVisual.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'viewBox' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":19,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'width' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":91,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":91,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'height' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":92,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport DOMPurify from 'dompurify';\nimport { ElectronicComponent } from '../../../types';\nimport { partStorageService } from '../../../services/partStorageService';\nimport { FzpzLoader } from '../../../services/fzpzLoader';\n\ninterface FzpzVisualProps {\n  component: ElectronicComponent;\n}\n\n/**\n * FzpzVisual\n * \n * Renders the high-fidelity breadboard view from a .fzpz file.\n * Normalizes the SVG to the 10px = 0.1\" grid.\n */\nexport const FzpzVisual: React.FC<FzpzVisualProps> = ({ component }) => {\n  const [svgContent, setSvgContent] = useState<string | null>(null);\n  const [viewBox, setViewBox] = useState<string>('0 0 100 100');\n\n  useEffect(() => {\n    const loadSvg = async () => {\n      if (!component.fzpzSource) return;\n\n      try {\n        // Try cache first\n        const cached = await partStorageService.getPart(component.id);\n        if (cached?.breadboardSvg) {\n          setSvgContent(cached.breadboardSvg);\n        } else {\n          // Parse on the fly\n          const part = await FzpzLoader.load(component.fzpzSource);\n          setSvgContent(part.svgs.breadboard || null);\n          \n          // Update cache if missing views\n          if (cached) {\n            await partStorageService.savePart({\n              ...cached,\n              breadboardSvg: part.svgs.breadboard\n            });\n          }\n        }\n      } catch (e) {\n        console.error('Failed to load FZPZ visual', e);\n      }\n    };\n\n    loadSvg();\n  }, [component.id, component.fzpzSource]);\n\n  useEffect(() => {\n    if (!svgContent) return;\n\n    // Extract viewBox from string\n    const match = svgContent.match(/viewBox=[\"']([^\"']+)[\"']/);\n    if (match) {\n      setViewBox(match[1]);\n    }\n  }, [svgContent]);\n\n  if (!svgContent) {\n    return (\n      <rect \n        width={component.footprint?.width || 50} \n        height={component.footprint?.height || 50} \n        fill=\"#333\" \n        stroke=\"#666\" \n        strokeWidth=\"1\"\n      />\n    );\n  }\n\n  // Inject the SVG content\n  // We need to strip the <svg> tags and just keep the inner content,\n  // OR render it inside a <g> with scaling.\n  \n  // Clean SVG: remove xmlns and the root <svg> tag but keep children\n  const innerContent = svgContent\n    .replace(/<svg[^>]*>/i, '')\n    .replace(/<\\/svg>/i, '');\n\n  // SECURITY: Sanitize SVG to prevent XSS from malicious FZPZ files\n  const sanitizedContent = DOMPurify.sanitize(innerContent, {\n    USE_PROFILES: { svg: true, svgFilters: true },\n    ADD_TAGS: ['use', 'symbol', 'defs', 'clipPath', 'mask'],\n    ADD_ATTR: ['xlink:href', 'clip-path', 'mask', 'transform', 'viewBox'],\n    FORBID_TAGS: ['script', 'style'],\n    FORBID_ATTR: ['onclick', 'onload', 'onerror', 'onmouseover']\n  });\n\n  const width = component.footprint?.width || 10;\n  const height = component.footprint?.height || 10;\n\n  return (\n    <g\n      className=\"fzpz-content\"\n      dangerouslySetInnerHTML={{ __html: sanitizedContent }}\n    />\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/diagram/wiring/BezierWire.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WireConnection' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":24},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":13,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":13,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cp1' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cp2' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":32,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React from 'react';\nimport { WireConnection, WirePoint } from '../../../types';\n\ninterface BezierWireProps {\n  start: { x: number; y: number };\n  end: { x: number; y: number };\n  points?: WirePoint[];\n  color?: string;\n  selected?: boolean;\n}\n\nexport const calculateBezierPath = (\n  start: { x: number; y: number },\n  end: { x: number; y: number },\n  points?: WirePoint[]\n): string => {\n  if (!points || points.length === 0) {\n    // Standard Cubic Bezier between two points\n    // Calculate control points based on distance\n    const dist = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n    const controlDist = Math.min(dist * 0.5, 150); // Cap at 150px slack\n    \n    // Simple heuristic: Horizontal wires curve vertically, Vertical curve horizontally?\n    // Fritzing style: usually curvy.\n    // Let's do a standard \"S\" curve logic assuming left-to-right flow mostly, \n    // but adapting to angle.\n    \n    // Control Point 1\n    const cp1 = { x: start.x, y: start.y + controlDist };\n    // Control Point 2\n    const cp2 = { x: end.x, y: end.y + controlDist };\n    \n    // Fritzing wires often come \"out\" of the pin perpendicular to the board.\n    // Assuming pins are vertical on breadboard:\n    // Start is (x, y), we want to exit (x, y+20) then curve.\n    \n    return `M ${start.x} ${start.y} C ${start.x} ${start.y + 50}, ${end.x} ${end.y + 50}, ${end.x} ${end.y}`;\n  }\n  \n  // Multi-point Bezier\n  // M start -> C ... p1 -> C ... p2 -> ... end\n  let path = `M ${start.x} ${start.y}`;\n  \n  // To keep it simple for MVP, just lines between points?\n  // No, we want Curves.\n  // We need to construct a spline.\n  \n  // TODO: Implement Catmull-Rom or similar for smooth path through arbitrary points.\n  // For now, linear segments for debug.\n  points.forEach(p => {\n      path += ` L ${p.x} ${p.y}`;\n  });\n  path += ` L ${end.x} ${end.y}`;\n  \n  return path;\n};\n\nexport const BezierWire: React.FC<BezierWireProps> = ({ start, end, points, color = '#00f3ff', selected }) => {\n  const pathData = calculateBezierPath(start, end, points);\n\n  return (\n    <g className=\"wire-group\">\n      {/* Shadow/Highlight for selection */}\n      <path\n        d={pathData}\n        fill=\"none\"\n        stroke={selected ? 'rgba(255, 255, 255, 0.5)' : 'transparent'}\n        strokeWidth=\"8\"\n        strokeLinecap=\"round\"\n      />\n      {/* Core Wire */}\n      <path\n        d={pathData}\n        fill=\"none\"\n        stroke={color}\n        strokeWidth=\"3\"\n        strokeLinecap=\"round\"\n        style={{ filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.5))' }}\n      />\n      {/* Wire Insulation Shine (Fritzing style) */}\n      <path\n        d={pathData}\n        fill=\"none\"\n        stroke=\"rgba(255, 255, 255, 0.3)\"\n        strokeWidth=\"1\"\n        strokeLinecap=\"round\"\n        transform=\"translate(0, -0.5)\"\n      />\n    </g>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/BOMModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/InventoryItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/InventoryList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/MacroPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/inventory/inventoryUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/AnalyticsDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/AppHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/AppLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/BootcampPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/CollaboratorList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/CommsLog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/CyberToast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/DebugWorkbench.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/HardwareTerminal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/MentorOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/ModeSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/OmniSearch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/ProjectTimeline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/SecurityReport.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/SimControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/StatusRail.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/SystemLogViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/SystemVitals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/layout/assistant/AssistantTabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/ConfigPortal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/DeveloperPortal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/DiagnosticsView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/LocalizationSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/PartsManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/ProfileSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/components/settings/SyncPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":45,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { QRCodeSVG } from 'qrcode.react';\nimport { peerDiscoveryService } from '../../services/peerDiscoveryService';\nimport { syncService, PeerNode } from '../../services/syncService';\n\nexport const SyncPanel: React.FC = () => {\n  const [peers, setPeers] = useState<PeerNode[]>([]);\n  const [newPeerIp, setNewPeerIp] = useState('');\n  const [newPeerName, setNewPeerName] = useState('');\n  const [isSyncing, setIsSyncing] = useState(false);\n\n  useEffect(() => {\n    setPeers(peerDiscoveryService.getPeers());\n  }, []);\n\n  const handleAddPeer = () => {\n    if (newPeerIp && newPeerName) {\n      peerDiscoveryService.addPeer(newPeerIp, newPeerName);\n      setPeers(peerDiscoveryService.getPeers());\n      setNewPeerIp('');\n      setNewPeerName('');\n    }\n  };\n\n  const handleRemovePeer = (id: string) => {\n    peerDiscoveryService.removePeer(id);\n    setPeers(peerDiscoveryService.getPeers());\n  };\n\n  const handlePush = async (peer: PeerNode) => {\n    setIsSyncing(true);\n    try {\n      await syncService.pushToPeer(peer);\n      alert(`Pushed to ${peer.name}`);\n    } catch (e) {\n      alert(`Push failed: ${e instanceof Error ? e.message : 'Unknown error'}`);\n    } finally {\n      setIsSyncing(false);\n    }\n  };\n\n  const handlePull = async (peer: PeerNode) => {\n    setIsSyncing(true);\n    try {\n      const data = await syncService.pullFromPeer(peer);\n      alert(`Pulled from ${peer.name}. Reloading state...`);\n      // In a real app, we'd update context/state here\n    } catch (e) {\n      alert(`Pull failed: ${e instanceof Error ? e.message : 'Unknown error'}`);\n    } finally {\n      setIsSyncing(false);\n    }\n  };\n\n  // Mock pairing key/QR data\n  const pairingData = JSON.stringify({\n    deviceId: 'master-station',\n    ip: '192.168.1.50',\n    key: '7788-9900'\n  });\n\n  return (\n    <div className=\"flex flex-col h-full bg-[#020203] p-4 space-y-6 overflow-y-auto custom-scrollbar\">\n      {/* Local ID & QR */}\n      <div className=\"bg-slate-900/80 border border-white/5 p-4 cut-corner-md flex gap-6 items-center\">\n        <div className=\"flex-1 space-y-2\">\n          <h3 className=\"text-xs font-bold text-white uppercase tracking-[0.3em]\">Local Identification</h3>\n          <p className=\"text-[10px] text-slate-500 font-mono\">ID: MASTER-STATION-01</p>\n          <p className=\"text-[10px] text-slate-500 font-mono\">STATUS: BROADCASTING...</p>\n          <div className=\"pt-2\">\n            <span className=\"text-[9px] px-2 py-0.5 bg-neon-cyan/10 border border-neon-cyan/30 text-neon-cyan font-bold uppercase tracking-widest cut-corner-sm\">\n              Local-Only Mode\n            </span>\n          </div>\n        </div>\n        <div className=\"bg-white p-2 rounded-sm shadow-[0_0_15px_rgba(255,255,255,0.1)]\">\n          <QRCodeSVG value={pairingData} size={80} level=\"M\" />\n        </div>\n      </div>\n\n      {/* Add Peer */}\n      <div className=\"space-y-3\">\n        <h3 className=\"text-[10px] font-bold text-slate-400 uppercase tracking-[0.2em] border-b border-white/5 pb-1\">Pair New Device</h3>\n        <div className=\"flex gap-2\">\n          <input \n            type=\"text\" \n            placeholder=\"Device Name...\" \n            value={newPeerName}\n            onChange={e => setNewPeerName(e.target.value)}\n            className=\"flex-1 bg-black border border-slate-700 cut-corner-sm px-3 py-2 text-[11px] text-white focus:border-neon-cyan focus:outline-none\"\n          />\n          <input \n            type=\"text\" \n            placeholder=\"IP Address...\" \n            value={newPeerIp}\n            onChange={e => setNewPeerIp(e.target.value)}\n            className=\"flex-1 bg-black border border-slate-700 cut-corner-sm px-3 py-2 text-[11px] text-white focus:border-neon-cyan focus:outline-none\"\n          />\n          <button \n            onClick={handleAddPeer}\n            className=\"bg-neon-cyan text-black font-bold px-4 py-2 cut-corner-sm text-[10px] tracking-[0.2em] hover:bg-white\"\n          >\n            PAIR\n          </button>\n        </div>\n      </div>\n\n      {/* Device List */}\n      <div className=\"space-y-3\">\n        <h3 className=\"text-[10px] font-bold text-slate-400 uppercase tracking-[0.2em] border-b border-white/5 pb-1\">Known Devices</h3>\n        {peers.length === 0 ? (\n          <div className=\"text-center py-8 opacity-20\">\n            <div className=\"loading-tech scale-75 mb-4 mx-auto grayscale\"></div>\n            <p className=\"text-[10px] uppercase tracking-widest\">No Paired Devices</p>\n          </div>\n        ) : (\n          <div className=\"space-y-2\">\n            {peers.map(peer => (\n              <div key={peer.deviceId} className=\"bg-white/5 border border-white/10 p-3 cut-corner-sm flex justify-between items-center group hover:border-neon-cyan/30 transition-all\">\n                <div className=\"space-y-1\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"w-1.5 h-1.5 rounded-full bg-neon-green shadow-[0_0_5px_#00ff9d]\" />\n                    <h4 className=\"text-[11px] font-bold text-slate-200 uppercase\">{peer.name}</h4>\n                  </div>\n                  <p className=\"text-[9px] text-slate-500 font-mono\">{peer.lastIp}</p>\n                </div>\n                <div className=\"flex gap-2\">\n                  <button \n                    disabled={isSyncing}\n                    onClick={() => handlePush(peer)}\n                    className=\"px-2 py-1 bg-neon-cyan/10 border border-neon-cyan/30 text-neon-cyan text-[9px] font-bold uppercase tracking-widest hover:bg-neon-cyan hover:text-black transition-all\"\n                  >\n                    PUSH\n                  </button>\n                  <button \n                    disabled={isSyncing}\n                    onClick={() => handlePull(peer)}\n                    className=\"px-2 py-1 bg-neon-amber/10 border border-neon-amber/30 text-neon-amber text-[9px] font-bold uppercase tracking-widest hover:bg-neon-amber hover:text-black transition-all\"\n                  >\n                    PULL\n                  </button>\n                  <button \n                    onClick={() => handleRemovePeer(peer.deviceId)}\n                    className=\"p-1.5 text-slate-600 hover:text-red-500 transition-colors\"\n                  >\n                    <svg className=\"w-3.5 h-3.5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n                    </svg>\n                  </button>\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {isSyncing && (\n        <div className=\"fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex flex-col items-center justify-center\">\n          <div className=\"loading-tech scale-150 mb-6\"></div>\n          <p className=\"text-neon-cyan font-bold tracking-[0.4em] text-xs animate-pulse uppercase\">Synchronizing Git History...</p>\n        </div>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/AssistantStateContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":52,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":52,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\nimport { ActionDelta } from '../types';\n\ntype GenerationMode = 'chat' | 'image' | 'video';\ntype ImageSize = '1K' | '2K' | '4K';\n\ninterface AssistantStateContextType {\n  generationMode: GenerationMode;\n  setGenerationMode: (mode: GenerationMode) => void;\n  imageSize: ImageSize;\n  setImageSize: (size: ImageSize) => void;\n  aspectRatio: string;\n  setAspectRatio: (ratio: string) => void;\n  useDeepThinking: boolean;\n  setUseDeepThinking: (enabled: boolean) => void;\n  \n  // History Buffer\n  recentHistory: ActionDelta[];\n  pushActionDelta: (delta: Omit<ActionDelta, 'timestamp'>) => void;\n}\n\nconst AssistantStateContext = createContext<AssistantStateContextType | undefined>(undefined);\n\nexport const AssistantStateProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [generationMode, setGenerationMode] = useState<GenerationMode>('chat');\n  const [imageSize, setImageSize] = useState<ImageSize>('1K');\n  const [aspectRatio, setAspectRatio] = useState<string>('16:9');\n  const [useDeepThinking, setUseDeepThinking] = useState(false);\n  const [recentHistory, setRecentHistory] = useState<ActionDelta[]>([]);\n\n  const pushActionDelta = useCallback((delta: Omit<ActionDelta, 'timestamp'>) => {\n    const newDelta = { ...delta, timestamp: Date.now() };\n    setRecentHistory((prev) => {\n      const next = [newDelta, ...prev];\n      return next.slice(0, 10); // Keep last 10 actions\n    });\n  }, []);\n\n  return (\n    <AssistantStateContext.Provider value={{\n      generationMode, setGenerationMode,\n      imageSize, setImageSize,\n      aspectRatio, setAspectRatio,\n      useDeepThinking, setUseDeepThinking,\n      recentHistory, pushActionDelta\n    }}>\n      {children}\n    </AssistantStateContext.Provider>\n  );\n};\n\nexport const useAssistantState = () => {\n  const context = useContext(AssistantStateContext);\n  if (context === undefined) {\n    throw new Error('useAssistantState must be used within an AssistantStateProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/AuthContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":104,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":104,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\nimport { authService, User, UserRole } from '../services/authService';\n\ninterface Permissions {\n  canEditInventory: boolean;\n  canModifyDiagram: boolean;\n  canViewAPIKeys: boolean;\n  canDeleteData: boolean;\n}\n\ninterface AuthContextType {\n  currentUser: User | null;\n  isLocked: boolean;\n  isSetup: boolean;\n  permissions: Permissions;\n  login: (pin: string) => Promise<boolean>;\n  logout: () => void;\n  setup: (pin: string) => Promise<void>;\n  lock: () => void;\n}\n\nconst DEFAULT_PERMISSIONS: Permissions = {\n  canEditInventory: false,\n  canModifyDiagram: false,\n  canViewAPIKeys: false,\n  canDeleteData: false\n};\n\nconst ROLE_PERMISSIONS: Record<UserRole, Permissions> = {\n  admin: {\n    canEditInventory: true,\n    canModifyDiagram: true,\n    canViewAPIKeys: true,\n    canDeleteData: true\n  },\n  engineer: {\n    canEditInventory: true,\n    canModifyDiagram: true,\n    canViewAPIKeys: false,\n    canDeleteData: false\n  },\n  observer: {\n    canEditInventory: false,\n    canModifyDiagram: false,\n    canViewAPIKeys: false,\n    canDeleteData: false\n  }\n};\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState<User | null>(null);\n  const [isLocked, setIsLocked] = useState(authService.isSetup());\n  const [isSetup, setIsSetup] = useState(authService.isSetup());\n\n  const login = async (pin: string): Promise<boolean> => {\n    const user = await authService.validatePin(pin);\n    if (user) {\n      setCurrentUser(user);\n      setIsLocked(false);\n      return true;\n    }\n    return false;\n  };\n\n  const setup = async (pin: string): Promise<void> => {\n    await authService.setupMasterPin(pin);\n    setIsSetup(true);\n    // Auto-login after setup\n    await login(pin);\n  };\n\n  const logout = useCallback(() => {\n    authService.logout();\n    setCurrentUser(null);\n    setIsLocked(true);\n  }, []);\n\n  const lock = useCallback(() => {\n    setIsLocked(true);\n  }, []);\n\n  const permissions = currentUser \n    ? ROLE_PERMISSIONS[currentUser.role] \n    : DEFAULT_PERMISSIONS;\n\n  return (\n    <AuthContext.Provider value={{\n      currentUser,\n      isLocked,\n      isSetup,\n      permissions,\n      login,\n      logout,\n      setup,\n      lock\n    }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/ConversationContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":15,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":15,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, ReactNode } from 'react';\nimport { useConversations, UseConversationsReturn } from '../hooks/useConversations';\n\nconst ConversationContext = createContext<UseConversationsReturn | undefined>(undefined);\n\nexport const ConversationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const conversationState = useConversations();\n  return (\n    <ConversationContext.Provider value={conversationState}>\n      {children}\n    </ConversationContext.Provider>\n  );\n};\n\nexport const useConversationContext = () => {\n  const context = useContext(ConversationContext);\n  if (context === undefined) {\n    throw new Error('useConversationContext must be used within a ConversationProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/DashboardContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[292,295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[292,295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":88,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":88,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\n\nexport interface WidgetLayout {\n  i: string;\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\nexport interface DashboardWidget {\n  id: string;\n  type: string;\n  layout: WidgetLayout;\n  props?: any;\n}\n\ninterface DashboardContextType {\n  widgets: DashboardWidget[];\n  isEditMode: boolean;\n  setEditMode: (edit: boolean) => void;\n  addWidget: (type: string) => void;\n  removeWidget: (id: string) => void;\n  updateLayout: (layout: WidgetLayout[]) => void;\n  resetDashboard: () => void;\n}\n\nconst DashboardContext = createContext<DashboardContextType | undefined>(undefined);\n\nconst DEFAULT_WIDGETS: DashboardWidget[] = [\n  { id: 'vitals-1', type: 'vitals', layout: { i: 'vitals-1', x: 0, y: 0, w: 4, h: 2 } },\n  { id: 'terminal-1', type: 'terminal', layout: { i: 'terminal-1', x: 4, y: 0, w: 8, h: 4 } }\n];\n\nexport const DashboardProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [widgets, setWidgets] = useState<DashboardWidget[]>(() => {\n    const saved = localStorage.getItem('cm_dashboard_widgets');\n    return saved ? JSON.parse(saved) : DEFAULT_WIDGETS;\n  });\n  const [isEditMode, setEditMode] = useState(false);\n\n  const saveWidgets = (newWidgets: DashboardWidget[]) => {\n    setWidgets(newWidgets);\n    localStorage.setItem('cm_dashboard_widgets', JSON.stringify(newWidgets));\n  };\n\n  const addWidget = useCallback((type: string) => {\n    const id = `${type}-${Date.now()}`;\n    const newWidget: DashboardWidget = {\n      id,\n      type,\n      layout: { i: id, x: 0, y: Infinity, w: 4, h: 4 }\n    };\n    saveWidgets([...widgets, newWidget]);\n  }, [widgets]);\n\n  const removeWidget = useCallback((id: string) => {\n    saveWidgets(widgets.filter(w => w.id !== id));\n  }, [widgets]);\n\n  const updateLayout = useCallback((layout: WidgetLayout[]) => {\n    const nextWidgets = widgets.map(w => {\n      const l = layout.find(l => l.i === w.id);\n      return l ? { ...w, layout: l } : w;\n    });\n    saveWidgets(nextWidgets);\n  }, [widgets]);\n\n  const resetDashboard = useCallback(() => {\n    saveWidgets(DEFAULT_WIDGETS);\n  }, []);\n\n  return (\n    <DashboardContext.Provider value={{\n      widgets,\n      isEditMode,\n      setEditMode,\n      addWidget,\n      removeWidget,\n      updateLayout,\n      resetDashboard\n    }}>\n      {children}\n    </DashboardContext.Provider>\n  );\n};\n\nexport const useDashboard = () => {\n  const context = useContext(DashboardContext);\n  if (context === undefined) {\n    throw new Error('useDashboard must be used within a DashboardProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/DiagramContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":151,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":151,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback, useRef } from 'react';\nimport { WiringDiagram } from '../types';\nimport { storageService } from '../services/storage';\nimport { migrateLegacyDiagram } from '../services/componentValidator';\nimport { useInventory } from './InventoryContext';\n\ninterface HistoryState {\n  past: WiringDiagram[];\n  present: WiringDiagram | null;\n  future: WiringDiagram[];\n}\n\ntype DiagramUpdater = WiringDiagram | null | ((current: WiringDiagram | null) => WiringDiagram | null);\n\ninterface DiagramContextType {\n  diagram: WiringDiagram | null;\n  history: HistoryState;\n  updateDiagram: (newDiagram: DiagramUpdater) => void;\n  undo: () => void;\n  redo: () => void;\n  canUndo: boolean;\n  canRedo: boolean;\n  saveToQuickSlot: () => void;\n  loadFromQuickSlot: () => void;\n}\n\nconst DiagramContext = createContext<DiagramContextType | undefined>(undefined);\n\nexport const DiagramProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const { inventory } = useInventory();\n  const migrationRan = useRef(false);\n\n  const [history, setHistory] = useState<HistoryState>(() => {\n    let savedPresent = null;\n    try {\n      const saved = localStorage.getItem('cm_autosave');\n      if (saved) savedPresent = JSON.parse(saved);\n    } catch (e: unknown) {\n      console.error(e instanceof Error ? e.message : 'Failed to load diagram');\n    }\n    return {\n      past: [],\n      present: savedPresent,\n      future: [],\n    };\n  });\n\n  // Run Migration on mount (once inventory is loaded)\n  useEffect(() => {\n    if (migrationRan.current || inventory.length === 0 || !history.present) return;\n    \n    const { diagram: migrated, repairedCount } = migrateLegacyDiagram(history.present, inventory);\n    \n    if (repairedCount > 0) {\n      setHistory(prev => ({\n        ...prev,\n        present: migrated\n      }));\n    }\n    \n    migrationRan.current = true;\n  }, [inventory, history.present]);\n\n  // Auto-save Diagram\n  useEffect(() => {\n    if (history.present) {\n      storageService.setItem('cm_autosave', JSON.stringify(history.present));\n    }\n  }, [history.present]);\n\n  const updateDiagram = useCallback((newDiagram: DiagramUpdater) => {\n    setHistory((curr) => {\n      const resolvedDiagram = typeof newDiagram === 'function'\n        ? newDiagram(curr.present)\n        : newDiagram;\n      if (curr.present === resolvedDiagram) return curr;\n      return {\n        past: curr.present ? [...curr.past, curr.present] : curr.past,\n        present: resolvedDiagram,\n        future: [],\n      };\n    });\n  }, []);\n\n  const undo = useCallback(() => {\n    setHistory((curr) => {\n      if (curr.past.length === 0) return curr;\n      const previous = curr.past[curr.past.length - 1];\n      const newPast = curr.past.slice(0, -1);\n      return {\n        past: newPast,\n        present: previous,\n        future: curr.present ? [curr.present, ...curr.future] : curr.future,\n      };\n    });\n  }, []);\n\n  const redo = useCallback(() => {\n    setHistory((curr) => {\n      if (curr.future.length === 0) return curr;\n      const next = curr.future[0];\n      const newFuture = curr.future.slice(1);\n      return {\n        past: curr.present ? [...curr.past, curr.present] : curr.past,\n        present: next,\n        future: newFuture,\n      };\n    });\n  }, []);\n\n  const saveToQuickSlot = useCallback(() => {\n    if (!history.present) return;\n    const data = {\n      diagram: history.present,\n      timestamp: Date.now(),\n    };\n    localStorage.setItem('savedDiagram', JSON.stringify(data));\n  }, [history.present]);\n\n  const loadFromQuickSlot = useCallback(() => {\n    const saved = localStorage.getItem('savedDiagram');\n    if (saved) {\n      try {\n        const parsed = JSON.parse(saved);\n        if (parsed.diagram) {\n          updateDiagram(parsed.diagram);\n        }\n      } catch (e) {\n        console.error('Failed to load', e);\n      }\n    }\n  }, [updateDiagram]);\n\n  return (\n    <DiagramContext.Provider value={{\n      diagram: history.present,\n      history,\n      updateDiagram,\n      undo,\n      redo,\n      canUndo: history.past.length > 0,\n      canRedo: history.future.length > 0,\n      saveToQuickSlot,\n      loadFromQuickSlot\n    }}>\n      {children}\n    </DiagramContext.Provider>\n  );\n};\n\nexport const useDiagram = () => {\n  const context = useContext(DiagramContext);\n  if (context === undefined) {\n    throw new Error('useDiagram must be used within a DiagramProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/HUDContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":81,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":81,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\n\nexport type FragmentType = 'info' | 'warning' | 'tip';\n\nexport interface HUDFragment {\n  id: string;\n  targetId: string; // Component or Pin ID\n  type: FragmentType;\n  content: string;\n  position: { x: number; y: number };\n  priority: number;\n}\n\ninterface HUDContextType {\n  fragments: HUDFragment[];\n  addFragment: (fragment: Omit<HUDFragment, 'id'> & { id?: string }) => string;\n  removeFragment: (id: string) => void;\n  clearHUD: () => void;\n  isVisible: boolean;\n  setVisible: (visible: boolean) => void;\n}\n\nconst HUDContext = createContext<HUDContextType | undefined>(undefined);\n\nexport const HUDProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [fragments, setFragments] = useState<HUDFragment[]>([]);\n  const [isVisible, setVisible] = useState(true);\n\n  const addFragment = useCallback((fragment: Omit<HUDFragment, 'id'> & { id?: string }) => {\n    const id = fragment.id || Math.random().toString(36).substring(2, 9);\n    \n    setFragments((prev) => {\n      const existingIdx = prev.findIndex(f => f.id === id);\n      const newFragment = { ...fragment, id } as HUDFragment;\n      \n      if (existingIdx !== -1) {\n        // Update existing fragment\n        const next = [...prev];\n        next[existingIdx] = newFragment;\n        return next;\n      }\n      return [...prev, newFragment];\n    });\n\n    // Priority-based auto-dismissal (Decay)\n    // Priority 1: Persistent (High)\n    // Priority 2+: Ephemeral (Low)\n    if (fragment.priority >= 2) {\n      setTimeout(() => {\n        setFragments((prev) => prev.filter((f) => f.id !== id));\n      }, 5000);\n    }\n\n    return id;\n  }, []);\n\n  const removeFragment = useCallback((id: string) => {\n    setFragments((prev) => prev.filter((f) => f.id !== id));\n  }, []);\n\n  const clearHUD = useCallback(() => {\n    setFragments([]);\n  }, []);\n\n  const contextValue = React.useMemo(() => ({\n    fragments,\n    addFragment,\n    removeFragment,\n    clearHUD,\n    isVisible,\n    setVisible\n  }), [fragments, addFragment, removeFragment, clearHUD, isVisible]);\n\n  return (\n    <HUDContext.Provider value={contextValue}>\n      {children}\n    </HUDContext.Provider>\n  );\n};\n\nexport const useHUD = () => {\n  const context = useContext(HUDContext);\n  if (context === undefined) {\n    throw new Error('useHUD must be used within a HUDProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/HealthContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":41,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":41,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { healthMonitor, HealthMetrics } from '../services/healthMonitor';\nimport { useLayout } from './LayoutContext';\n\ninterface HealthContextType {\n  metrics: HealthMetrics;\n}\n\nconst HealthContext = createContext<HealthContextType | undefined>(undefined);\n\nexport const HealthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [metrics, setMetrics] = useState<HealthMetrics>(healthMonitor.getMetrics());\n  const { setLowPerformanceMode } = useLayout();\n\n  useEffect(() => {\n    let lowFpsCount = 0;\n    const interval = setInterval(() => {\n      const currentMetrics = healthMonitor.getMetrics();\n      setMetrics(currentMetrics);\n\n      // Auto-degradation logic: 5 consecutive seconds of low FPS\n      if (currentMetrics.fps < 25) {\n        lowFpsCount++;\n        if (lowFpsCount >= 5) {\n          setLowPerformanceMode(true);\n        }\n      } else {\n        lowFpsCount = 0;\n      }\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [setLowPerformanceMode]);\n\n  return (\n    <HealthContext.Provider value={{ metrics }}>\n      {children}\n    </HealthContext.Provider>\n  );\n};\n\nexport const useHealth = () => {\n  const context = useContext(HealthContext);\n  if (context === undefined) {\n    throw new Error('useHealth must be used within a HealthProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/InventoryContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'initialData' is defined but never used. Allowed unused args must match /^_/u.","line":22,"column":119,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":130},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":152,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":152,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport { ElectronicComponent } from '../types';\nimport { storageService } from '../services/storage';\nimport { INITIAL_INVENTORY } from '../data/initialInventory';\nimport { FzpzLoader } from '../services/fzpzLoader';\nimport { partStorageService } from '../services/partStorageService';\n\ninterface InventoryContextType {\n  inventory: ElectronicComponent[];\n  setInventory: React.Dispatch<React.SetStateAction<ElectronicComponent[]>>;\n  addItem: (item: ElectronicComponent) => void;\n  updateItem: (item: ElectronicComponent) => void;\n  removeItem: (id: string) => void;\n  removeMany: (ids: string[]) => void;\n  updateMany: (items: ElectronicComponent[]) => void;\n  loadPartData: (id: string) => Promise<ElectronicComponent | null>;\n  isLoading: boolean;\n}\n\nconst InventoryContext = createContext<InventoryContextType | undefined>(undefined);\n\nexport const InventoryProvider: React.FC<{ children: ReactNode; initialData?: ElectronicComponent[] }> = ({ children, initialData }) => {\n  const [inventory, setInventory] = useState<ElectronicComponent[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Initialize inventory\n  useEffect(() => {\n    const init = async () => {\n      try {\n        const saved = await storageService.getItem('cm_inventory');\n        if (saved) {\n          setInventory(JSON.parse(saved));\n        } else {\n          setInventory(INITIAL_INVENTORY);\n        }\n      } catch (e) {\n        console.error('Failed to load inventory', e);\n        setInventory(INITIAL_INVENTORY);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    init();\n  }, []);\n\n  useEffect(() => {\n    if (!isLoading) {\n      storageService.setItem('cm_inventory', JSON.stringify(inventory));\n    }\n  }, [inventory, isLoading]);\n\n  const addItem = (item: ElectronicComponent) => {\n    setInventory((prev) => [...prev, item]);\n  };\n\n  const updateItem = (item: ElectronicComponent) => {\n    setInventory((prev) => prev.map((i) => (i.id === item.id ? item : i)));\n  };\n\n  const removeItem = (id: string) => {\n    setInventory((prev) => prev.filter((i) => i.id !== id));\n  };\n  \n  const removeMany = (ids: string[]) => {\n    setInventory((prev) => prev.filter((i) => !ids.includes(i.id)));\n  };\n\n  const updateMany = (items: ElectronicComponent[]) => {\n    const updates = new Map(items.map((i) => [i.id, i]));\n    setInventory((prev) => prev.map((i) => updates.get(i.id) || i));\n  };\n\n  /**\n   * Lazy-loads binary FZPZ data and footprints for a component.\n   * Checks cache first, then fetches and parses.\n   */\n  const loadPartData = useCallback(async (id: string): Promise<ElectronicComponent | null> => {\n    const comp = inventory.find(i => i.id === id);\n    if (!comp) return null;\n\n    // If already loaded in memory, return it\n    if (comp.fzpzSource && comp.footprint) return comp;\n\n    try {\n      // Check IndexedDB cache\n      const cached = await partStorageService.getPart(id);\n      if (cached) {\n        const updated = { \n          ...comp, \n          fzpzSource: cached.binary,\n          // Note: We might need to re-parse the XML to get the full footprint if not cached\n          // But for now let's assume we need to re-load if footprint is missing\n        };\n        \n        // If footprint is missing, re-parse the binary\n        if (!updated.footprint) {\n          const part = await FzpzLoader.load(cached.binary);\n          updated.footprint = part.component.footprint;\n        }\n\n        updateItem(updated);\n        return updated;\n      }\n\n      // Fetch from URL\n      if (!comp.fzpzUrl) return comp;\n\n      const response = await fetch(comp.fzpzUrl);\n      const buffer = await response.arrayBuffer();\n      const part = await FzpzLoader.load(buffer);\n\n      const loadedComp = {\n        ...comp,\n        fzpzSource: buffer,\n        footprint: part.component.footprint,\n        description: part.component.description || comp.description\n      };\n\n      // Save to cache\n      await partStorageService.savePart({\n        id,\n        binary: buffer,\n        breadboardSvg: part.svgs.breadboard,\n        lastUsed: Date.now()\n      });\n\n      updateItem(loadedComp);\n      return loadedComp;\n    } catch (e) {\n      console.error(`Failed to load FZPZ for ${id}`, e);\n      return comp;\n    }\n  }, [inventory]);\n\n  return (\n    <InventoryContext.Provider value={{ \n      inventory, \n      setInventory, \n      addItem, \n      updateItem, \n      removeItem,\n      removeMany,\n      updateMany,\n      loadPartData,\n      isLoading\n    }}>\n      {children}\n    </InventoryContext.Provider>\n  );\n};\n\nexport const useInventory = () => {\n  const context = useContext(InventoryContext);\n  if (context === undefined) {\n    throw new Error('useInventory must be used within an InventoryProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/LayoutContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":285,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":285,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport { storageService } from '../services/storage';\n\nexport type UIMode = 'design' | 'wiring' | 'debug';\n\ninterface LayoutSnapshot {\n  isInventoryOpen: boolean;\n  isAssistantOpen: boolean;\n  inventoryPinned: boolean;\n  assistantPinned: boolean;\n  inventoryWidth: number;\n  assistantWidth: number;\n}\n\ninterface LayoutContextType {\n  // Mode\n  activeMode: UIMode;\n  setActiveMode: (mode: UIMode) => void;\n\n  // Inventory\n  isInventoryOpen: boolean;\n  setInventoryOpen: (open: boolean) => void;\n  inventoryPinned: boolean;\n  setInventoryPinned: (pinned: boolean) => void;\n  inventoryWidth: number;\n  setInventoryWidth: (width: number) => void;\n  \n  // Assistant\n  isAssistantOpen: boolean;\n  setAssistantOpen: (open: boolean) => void;\n  assistantPinned: boolean;\n  setAssistantPinned: (pinned: boolean) => void;\n  assistantWidth: number;\n  setAssistantWidth: (width: number) => void;\n  \n  // Settings\n  isSettingsOpen: boolean;\n  setSettingsOpen: (open: boolean) => void;\n  settingsInitialTab: 'api' | 'profile' | 'ai' | 'layout' | 'dev' | 'config' | 'diagnostics' | 'locale';\n  setSettingsInitialTab: (tab: 'api' | 'profile' | 'ai' | 'layout' | 'dev' | 'config' | 'diagnostics' | 'locale') => void;\n\n  // Focus Mode\n  isFocusMode: boolean;\n  setFocusMode: (focus: boolean) => void;\n\n  // Sidebar Management\n  activeSidebar: 'inventory' | 'assistant' | 'none';\n  setActiveSidebar: (sidebar: 'inventory' | 'assistant' | 'none') => void;\n\n  // Performance\n  lowPerformanceMode: boolean;\n  setLowPerformanceMode: (enabled: boolean) => void;\n\n  // Neural Link (Gestures)\n  neuralLinkEnabled: boolean;\n  setNeuralLinkEnabled: (enabled: boolean) => void;\n\n  // Constants\n  inventoryDefaultWidth: number;\n  assistantDefaultWidth: number;\n}\n\nconst LayoutContext = createContext<LayoutContextType | undefined>(undefined);\n\nconst inventoryDefaultWidth = 360;\nconst assistantDefaultWidth = 380;\nconst inventoryWidthRange = { min: 280, max: 520 };\nconst assistantWidthRange = { min: 300, max: 560 };\nconst clampWidth = (value: number, min: number, max: number) => Math.min(max, Math.max(min, value));\n\nexport const LayoutProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  // Mode State\n  const [activeMode, setActiveModeState] = useState<UIMode>(() => {\n    try {\n      return (localStorage.getItem('cm_active_mode') as UIMode) || 'design';\n    } catch {\n      return 'design';\n    }\n  });\n\n  // Inventory State\n  const [isInventoryOpen, setIsInventoryOpen] = useState(() => {\n    try {\n      return localStorage.getItem('cm_inventory_open_default') === 'true';\n    } catch {\n      return false;\n    }\n  });\n  const [inventoryPinned, setInventoryPinned] = useState(() => {\n    try {\n      return localStorage.getItem('cm_inventory_pinned_default') === 'true';\n    } catch {\n      return false;\n    }\n  });\n  const [inventoryWidth, setInventoryWidth] = useState(() => {\n    try {\n      const saved = localStorage.getItem('cm_inventory_width');\n      const parsed = saved ? Number.parseInt(saved, 10) : inventoryDefaultWidth;\n      if (!Number.isFinite(parsed)) return inventoryDefaultWidth;\n      return clampWidth(parsed, inventoryWidthRange.min, inventoryWidthRange.max);\n    } catch {\n      return inventoryDefaultWidth;\n    }\n  });\n\n  // Assistant State\n  const [isAssistantOpen, setIsAssistantOpen] = useState(() => {\n    try {\n      const stored = localStorage.getItem('cm_assistant_open_default');\n      return stored ? stored === 'true' : true;\n    } catch {\n      return true;\n    }\n  });\n  const [assistantPinned, setAssistantPinned] = useState(() => {\n    try {\n      const stored = localStorage.getItem('cm_assistant_pinned_default');\n      return stored ? stored === 'true' : true;\n    } catch {\n      return true;\n    }\n  });\n  const [assistantWidth, setAssistantWidth] = useState(() => {\n    try {\n      const saved = localStorage.getItem('cm_assistant_width');\n      const parsed = saved ? Number.parseInt(saved, 10) : assistantDefaultWidth;\n      if (!Number.isFinite(parsed)) return assistantDefaultWidth;\n      return clampWidth(parsed, assistantWidthRange.min, assistantWidthRange.max);\n    } catch {\n      return assistantDefaultWidth;\n    }\n  });\n\n  // Settings State\n  const [isSettingsOpen, setIsSettingsOpen] = useState(false);\n  const [settingsInitialTab, setSettingsInitialTab] = useState<'api' | 'profile' | 'ai' | 'layout' | 'dev' | 'config' | 'diagnostics' | 'locale'>('api');\n\n  // Focus Mode State\n  const [isFocusMode, setIsFocusMode] = useState(false);\n\n  // Sidebar State\n  const [activeSidebar, setActiveSidebar] = useState<'inventory' | 'assistant' | 'none'>('none');\n\n  // Performance State\n  const [lowPerformanceMode, setLowPerformanceMode] = useState(() => {\n    try {\n      return localStorage.getItem('cm_low_performance_mode') === 'true';\n    } catch {\n      return false;\n    }\n  });\n\n  // Neural Link State\n  const [neuralLinkEnabled, setNeuralLinkEnabled] = useState(() => {\n    try {\n      return localStorage.getItem('cm_neural_link_enabled') === 'true';\n    } catch {\n      return false;\n    }\n  });\n\n  // Snapshot Logic\n  const setActiveMode = useCallback((mode: UIMode) => {\n    // 1. Snapshot current layout\n    const snapshot: LayoutSnapshot = {\n      isInventoryOpen,\n      isAssistantOpen,\n      inventoryPinned,\n      assistantPinned,\n      inventoryWidth,\n      assistantWidth\n    };\n    storageService.setItem(`cm_layout_snapshot_${activeMode}`, JSON.stringify(snapshot));\n\n    // 2. Change mode\n    setActiveModeState(mode);\n    storageService.setItem('cm_active_mode', mode);\n\n    // 3. Load next snapshot or apply defaults\n    const saved = localStorage.getItem(`cm_layout_snapshot_${mode}`);\n    if (saved) {\n      try {\n        const next: LayoutSnapshot = JSON.parse(saved);\n        setIsInventoryOpen(next.isInventoryOpen);\n        setIsAssistantOpen(next.isAssistantOpen);\n        setInventoryPinned(next.inventoryPinned);\n        setAssistantPinned(next.assistantPinned);\n        setInventoryWidth(next.inventoryWidth);\n        setAssistantWidth(next.assistantWidth);\n      } catch (e) {\n        console.error('Failed to parse layout snapshot', e);\n      }\n    } else {\n      // Default configurations for new modes (Auto-transitions)\n      if (mode === 'design') {\n        setIsInventoryOpen(true);\n        setIsAssistantOpen(false);\n        setInventoryPinned(true);\n      } else if (mode === 'wiring') {\n        setIsInventoryOpen(false);\n        setIsAssistantOpen(true);\n        setAssistantPinned(true);\n      } else if (mode === 'debug') {\n        setIsInventoryOpen(false);\n        setIsAssistantOpen(true);\n        setAssistantPinned(true);\n      }\n    }\n  }, [activeMode, isInventoryOpen, isAssistantOpen, inventoryPinned, assistantPinned, inventoryWidth, assistantWidth]);\n\n  // Persistence Effects\n  useEffect(() => {\n    // Update body class for mode-specific styling\n    document.body.classList.remove('mode-design', 'mode-wiring', 'mode-debug');\n    document.body.classList.add(`mode-${activeMode}`);\n  }, [activeMode]);\n\n  useEffect(() => {\n    storageService.setItem('cm_inventory_open_default', String(isInventoryOpen));\n  }, [isInventoryOpen]);\n\n  useEffect(() => {\n    storageService.setItem('cm_inventory_pinned_default', String(inventoryPinned));\n  }, [inventoryPinned]);\n\n  useEffect(() => {\n    storageService.setItem('cm_inventory_width', String(inventoryWidth));\n  }, [inventoryWidth]);\n\n  useEffect(() => {\n    storageService.setItem('cm_assistant_open_default', String(isAssistantOpen));\n  }, [isAssistantOpen]);\n\n  useEffect(() => {\n    storageService.setItem('cm_assistant_pinned_default', String(assistantPinned));\n  }, [assistantPinned]);\n\n  useEffect(() => {\n    storageService.setItem('cm_assistant_width', String(assistantWidth));\n  }, [assistantWidth]);\n\n  useEffect(() => {\n    storageService.setItem('cm_low_performance_mode', String(lowPerformanceMode));\n    if (lowPerformanceMode) {\n      document.body.classList.add('low-performance');\n    } else {\n      document.body.classList.remove('low-performance');\n    }\n  }, [lowPerformanceMode]);\n\n  useEffect(() => {\n    storageService.setItem('cm_neural_link_enabled', String(neuralLinkEnabled));\n  }, [neuralLinkEnabled]);\n\n  const contextValue = React.useMemo(() => ({\n    activeMode, setActiveMode,\n    isInventoryOpen, setInventoryOpen: setIsInventoryOpen,\n    inventoryPinned, setInventoryPinned,\n    inventoryWidth, setInventoryWidth,\n    isAssistantOpen, setAssistantOpen: setIsAssistantOpen,\n    assistantPinned, setAssistantPinned,\n    assistantWidth, setAssistantWidth,\n    isSettingsOpen, setSettingsOpen: setIsSettingsOpen,\n    settingsInitialTab, setSettingsInitialTab,\n    isFocusMode, setFocusMode: setIsFocusMode,\n    activeSidebar, setActiveSidebar,\n    lowPerformanceMode, setLowPerformanceMode,\n    neuralLinkEnabled, setNeuralLinkEnabled,\n    inventoryDefaultWidth,\n    assistantDefaultWidth\n  }), [\n    activeMode, setActiveMode, isInventoryOpen, inventoryPinned, inventoryWidth,\n    isAssistantOpen, assistantPinned, assistantWidth, isSettingsOpen, settingsInitialTab,\n    isFocusMode, activeSidebar, lowPerformanceMode, neuralLinkEnabled\n  ]);\n\n  return (\n    <LayoutContext.Provider value={contextValue}>\n      {children}\n    </LayoutContext.Provider>\n  );\n};\n\nexport const useLayout = () => {\n  const context = useContext(LayoutContext);\n  if (context === undefined) {\n    throw new Error('useLayout must be used within a LayoutProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/MacroContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[590,593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[590,593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":110,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":113,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2054,2057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2054,2057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":76,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":76,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\nimport { ActionIntent } from '../types';\nimport { MacroWorkflow, WorkflowStep, macroEngine } from '../services/macroEngine';\n\ninterface MacroContextType {\n  isRecording: boolean;\n  setIsRecording: (recording: boolean) => void;\n  recordedSteps: WorkflowStep[];\n  addRecordedStep: (action: ActionIntent) => void;\n  clearRecordedSteps: () => void;\n  savedMacros: MacroWorkflow[];\n  saveMacro: (name: string) => void;\n  runMacro: (macro: MacroWorkflow, executeAction: (action: ActionIntent) => Promise<any>) => Promise<void>;\n}\n\nconst MacroContext = createContext<MacroContextType | undefined>(undefined);\n\nexport const MacroProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [recordedSteps, setRecordedSteps] = useState<WorkflowStep[]>([]);\n  const [savedMacros, setSavedMacros] = useState<MacroWorkflow[]>(() => {\n    try {\n      const saved = localStorage.getItem('cm_macros');\n      return saved ? JSON.parse(saved) : [];\n    } catch {\n      return [];\n    }\n  });\n\n  const addRecordedStep = useCallback((action: ActionIntent) => {\n    const newStep: WorkflowStep = {\n      id: Date.now().toString(),\n      action,\n      description: action.label\n    };\n    setRecordedSteps(prev => [...prev, newStep]);\n  }, []);\n\n  const clearRecordedSteps = useCallback(() => setRecordedSteps([]), []);\n\n  const saveMacro = useCallback((name: string) => {\n    const newMacro: MacroWorkflow = {\n      id: Date.now().toString(),\n      name,\n      steps: [...recordedSteps],\n      author: 'user',\n      created: Date.now()\n    };\n    const nextMacros = [...savedMacros, newMacro];\n    setSavedMacros(nextMacros);\n    localStorage.setItem('cm_macros', JSON.stringify(nextMacros));\n    clearRecordedSteps();\n    setIsRecording(false);\n  }, [recordedSteps, savedMacros, clearRecordedSteps]);\n\n  const runMacro = useCallback(async (macro: MacroWorkflow, executeAction: (action: ActionIntent) => Promise<any>) => {\n    await macroEngine.execute(macro.steps, executeAction);\n  }, []);\n\n  return (\n    <MacroContext.Provider value={{\n      isRecording,\n      setIsRecording,\n      recordedSteps,\n      addRecordedStep,\n      clearRecordedSteps,\n      savedMacros,\n      saveMacro,\n      runMacro\n    }}>\n      {children}\n    </MacroContext.Provider>\n  );\n};\n\nexport const useMacros = () => {\n  const context = useContext(MacroContext);\n  if (context === undefined) {\n    throw new Error('useMacros must be used within a MacroProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/NotificationContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":86,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":86,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\n\nexport type NotificationSeverity = 'info' | 'success' | 'warning' | 'critical';\n\nexport interface AppNotification {\n  id: string;\n  severity: NotificationSeverity;\n  title: string;\n  message: string;\n  timestamp: number;\n  duration?: number;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  linkedObjectId?: string;\n}\n\ninterface NotificationContextType {\n  notifications: AppNotification[];\n  history: AppNotification[];\n  pushNotification: (n: Omit<AppNotification, 'id' | 'timestamp'> & { id?: string }) => void;\n  dismissNotification: (id: string) => void;\n  clearAll: () => void;\n}\n\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\n\nexport const NotificationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [notifications, setNotifications] = useState<AppNotification[]>([]);\n  const [history, setHistory] = useState<AppNotification[]>([]);\n\n  const dismissNotification = useCallback((id: string) => {\n    setNotifications((prev) => prev.filter((n) => n.id !== id));\n  }, []);\n\n  const pushNotification = useCallback((n: Omit<AppNotification, 'id' | 'timestamp'> & { id?: string }) => {\n    const id = n.id || crypto.randomUUID();\n    \n    setNotifications((prev) => {\n      // Prevent duplicate active notifications with the same ID\n      if (prev.some(notif => notif.id === id)) {\n        return prev;\n      }\n\n      const newNotification: AppNotification = {\n        ...n,\n        id,\n        timestamp: Date.now(),\n      };\n\n      return [...prev, newNotification];\n    });\n\n    // For history, we can still add it if needed, or check duplicates there too\n    const newEntry: AppNotification = { ...n, id, timestamp: Date.now() };\n    setHistory((prev) => [newEntry, ...prev].slice(0, 100));\n\n    if (n.duration !== 0) {\n      setTimeout(() => {\n        dismissNotification(id);\n      }, n.duration || 5000);\n    }\n  }, [dismissNotification]);\n\n  const clearAll = useCallback(() => {\n    setNotifications([]);\n    setHistory([]);\n  }, []);\n\n  const contextValue = React.useMemo(() => ({\n    notifications,\n    history,\n    pushNotification,\n    dismissNotification,\n    clearAll\n  }), [notifications, history, pushNotification, dismissNotification, clearAll]);\n\n  return (\n    <NotificationContext.Provider value={contextValue}>\n      {children}\n    </NotificationContext.Provider>\n  );\n};\n\nexport const useNotify = () => {\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotify must be used within a NotificationProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/SelectionContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":35,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":35,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\n\ninterface SelectionContextType {\n  selectedComponentId: string | null;\n  activeSelectionPath: string | undefined;\n  setSelectedComponentId: (id: string | null) => void;\n  setActiveSelectionPath: (path: string | undefined) => void;\n  clearSelection: () => void;\n}\n\nconst SelectionContext = createContext<SelectionContextType | undefined>(undefined);\n\nexport const SelectionProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [selectedComponentId, setSelectedComponentId] = useState<string | null>(null);\n  const [activeSelectionPath, setActiveSelectionPath] = useState<string | undefined>(undefined);\n\n  const clearSelection = useCallback(() => {\n    setSelectedComponentId(null);\n    setActiveSelectionPath(undefined);\n  }, []);\n\n  return (\n    <SelectionContext.Provider value={{\n      selectedComponentId,\n      activeSelectionPath,\n      setSelectedComponentId,\n      setActiveSelectionPath,\n      clearSelection\n    }}>\n      {children}\n    </SelectionContext.Provider>\n  );\n};\n\nexport const useSelection = () => {\n  const context = useContext(SelectionContext);\n  if (context === undefined) {\n    throw new Error('useSelection must be used within a SelectionProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/SimulationContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":75,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":75,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport { useDiagram } from './DiagramContext';\nimport { simulationEngine, SimulationResult } from '../services/simulationEngine';\nimport { useNotify } from './NotificationContext';\n\ninterface SimulationContextType {\n  result: SimulationResult | null;\n  isSimulating: boolean;\n  setSimulating: (sim: boolean) => void;\n  runTick: () => void;\n}\n\nconst SimulationContext = createContext<SimulationContextType | undefined>(undefined);\n\n/**\n * SimulationProvider manages the lifecycle and state of the electrical simulation.\n * It periodically runs the solver and provides results to the UI.\n */\nexport const SimulationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const { diagram } = useDiagram();\n  const [isSimulating, setIsSimulating] = useState(false);\n  const [result, setResult] = useState<SimulationResult | null>(null);\n  const { pushNotification } = useNotify();\n\n  const runTick = useCallback(() => {\n    if (!diagram) {\n      setResult(null);\n      return;\n    }\n    const res = simulationEngine.solve(diagram);\n    setResult(res);\n\n    if (res.isShortCircuit) {\n      pushNotification({\n        id: 'simulation-short-circuit',\n        severity: 'critical',\n        title: 'SIMULATION_CRASH',\n        message: 'Circuit logic failed. High risk of hardware damage detected.',\n        duration: 10000\n      });\n    }\n  }, [diagram, pushNotification]);\n\n  // Run simulation loop when active\n  useEffect(() => {\n    if (isSimulating) {\n      // Immediate first tick\n      runTick();\n      \n      const interval = setInterval(runTick, 500); // 2Hz for battery saving\n      return () => clearInterval(interval);\n    }\n  }, [isSimulating, runTick]);\n\n  // Auto-run tick once on diagram changes even if not continuously simulating\n  useEffect(() => {\n    runTick();\n  }, [diagram, runTick]);\n\n  return (\n    <SimulationContext.Provider value={{\n      result,\n      isSimulating,\n      setSimulating: setIsSimulating,\n      runTick\n    }}>\n      {children}\n    </SimulationContext.Provider>\n  );\n};\n\n/**\n * Hook to access current simulation results and controls.\n */\nexport const useSimulation = () => {\n  const context = useContext(SimulationContext);\n  if (context === undefined) {\n    throw new Error('useSimulation must be used within a SimulationProvider');\n  }\n  return context;\n};","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/TelemetryContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":92,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":92,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport { serialService, TelemetryPacket } from '../services/serialService';\nimport { vizEngine } from '../services/viz/vizEngine';\n\ninterface TelemetryContextType {\n  liveData: Record<string, TelemetryPacket>; // Key: compId:pin\n  isConnected: boolean;\n  connect: (baudRate?: number) => Promise<void>;\n  disconnect: () => Promise<void>;\n  rawLogs: string[];\n  clearLogs: () => void;\n}\n\nconst TelemetryContext = createContext<TelemetryContextType | undefined>(undefined);\n\n/**\n * TelemetryProvider manages the state of real-time hardware data.\n * It bridges the SerialService with the React UI.\n */\nexport const TelemetryProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [liveData, setLiveData] = useState<Record<string, TelemetryPacket>>({});\n  const [isConnected, setIsConnected] = useState(false);\n  const [rawLogs, setRawLogs] = useState<string[]>([]);\n\n  useEffect(() => {\n    // Setup listeners for serial data\n    serialService.onData((packet) => {\n      const key = `${packet.componentId}:${packet.pin || 'default'}`;\n      setLiveData((prev) => ({\n        ...prev,\n        [key]: packet\n      }));\n\n      // Feed vizEngine for high-speed charts\n      // Convert value to number if possible\n      const numVal = parseFloat(String(packet.value));\n      if (!isNaN(numVal)) {\n        vizEngine.addData(key, numVal);\n        // Also map to global streams for widgets\n        vizEngine.addData('main-osc', numVal);\n        if (packet.pin === 'D0') vizEngine.addData('d0-logic', numVal > 0 ? 1 : 0);\n      }\n    });\n\n    serialService.onRawData((line) => {\n      const timestamp = new Date().toLocaleTimeString();\n      const entry = `[${timestamp}] ${line}`;\n      setRawLogs((prev) => [...prev.slice(-499), entry]); // Keep last 500 lines\n    });\n\n    return () => {\n      serialService.close();\n    };\n  }, []);\n\n  const connect = useCallback(async (baudRate: number = 115200) => {\n    try {\n      await serialService.openPort({ baudRate });\n      setIsConnected(true);\n    } catch (e) {\n      console.error('Failed to connect hardware:', e);\n      setIsConnected(false);\n    }\n  }, []);\n\n  const disconnect = useCallback(async () => {\n    await serialService.close();\n    setIsConnected(false);\n  }, []);\n\n  const clearLogs = useCallback(() => {\n    setRawLogs([]);\n  }, []);\n\n  return (\n    <TelemetryContext.Provider value={{\n      liveData,\n      isConnected,\n      connect,\n      disconnect,\n      rawLogs,\n      clearLogs\n    }}>\n      {children}\n    </TelemetryContext.Provider>\n  );\n};\n\n/**\n * Hook to access live hardware telemetry data.\n */\nexport const useTelemetry = () => {\n  const context = useContext(TelemetryContext);\n  if (context === undefined) {\n    throw new Error('useTelemetry must be used within a TelemetryProvider');\n  }\n  return context;\n};","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/TutorialContext.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'completeQuest'. Either include it or remove the dependency array.","line":57,"column":6,"nodeType":"ArrayExpression","endLine":57,"endColumn":37,"suggestions":[{"desc":"Update the dependencies array to be: [activeQuest, completeQuest, currentStepIndex]","fix":{"range":[2013,2044],"text":"[activeQuest, completeQuest, currentStepIndex]"}}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":101,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":101,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, ReactNode, useCallback, useEffect } from 'react';\nimport { WiringDiagram, ElectronicComponent } from '../types';\nimport { useDiagram } from './DiagramContext';\nimport { useInventory } from './InventoryContext';\nimport { validateStep } from '../services/tutorialValidator';\n\nexport interface TutorialStep {\n  id: string;\n  title: string;\n  instructions: string;\n  mentorTip?: string;\n  targetElementId?: string;\n  // A function that takes current state and returns if step is done\n  condition: (state: { diagram: WiringDiagram | null; inventory: ElectronicComponent[] }) => boolean;\n}\n\nexport interface TutorialQuest {\n  id: string;\n  title: string;\n  difficulty: 'beginner' | 'intermediate' | 'expert';\n  steps: TutorialStep[];\n}\n\ninterface TutorialContextType {\n  activeQuest: TutorialQuest | null;\n  currentStepIndex: number;\n  completedSteps: string[];\n  startQuest: (quest: TutorialQuest) => void;\n  nextStep: () => void;\n  completeQuest: () => void;\n  resetTutorial: () => void;\n}\n\nconst TutorialContext = createContext<TutorialContextType | undefined>(undefined);\n\nexport const TutorialProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [activeQuest, setActiveQuest] = useState<TutorialQuest | null>(null);\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [completedSteps, setCompletedSteps] = useState<string[]>([]);\n\n  const { diagram } = useDiagram();\n  const { inventory } = useInventory();\n\n  const startQuest = useCallback((quest: TutorialQuest) => {\n    setActiveQuest(quest);\n    setCurrentStepIndex(0);\n    setCompletedSteps([]);\n  }, []);\n\n  const nextStep = useCallback(() => {\n    if (activeQuest && currentStepIndex < activeQuest.steps.length - 1) {\n      setCompletedSteps(prev => [...prev, activeQuest.steps[currentStepIndex].id]);\n      setCurrentStepIndex(prev => prev + 1);\n    } else if (activeQuest && currentStepIndex === activeQuest.steps.length - 1) {\n      completeQuest();\n    }\n  }, [activeQuest, currentStepIndex]);\n\n  const completeQuest = useCallback(() => {\n    setActiveQuest(null);\n    setCurrentStepIndex(0);\n    setCompletedSteps([]);\n  }, []);\n\n  const resetTutorial = useCallback(() => {\n    setCurrentStepIndex(0);\n    setCompletedSteps([]);\n  }, []);\n\n  // Auto-validation loop\n  useEffect(() => {\n    if (activeQuest) {\n      const currentStep = activeQuest.steps[currentStepIndex];\n      const isDone = validateStep(currentStep, diagram, inventory);\n      \n      if (isDone) {\n        // Use a small delay for better UX\n        const timer = setTimeout(() => {\n          nextStep();\n        }, 800);\n        return () => clearTimeout(timer);\n      }\n    }\n  }, [activeQuest, currentStepIndex, diagram, inventory, nextStep]);\n\n  return (\n    <TutorialContext.Provider value={{\n      activeQuest,\n      currentStepIndex,\n      completedSteps,\n      startQuest,\n      nextStep,\n      completeQuest,\n      resetTutorial\n    }}>\n      {children}\n    </TutorialContext.Provider>\n  );\n};\n\nexport const useTutorial = () => {\n  const context = useContext(TutorialContext);\n  if (context === undefined) {\n    throw new Error('useTutorial must be used within a TutorialProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/UserContext.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'user'. Either include it or remove the dependency array.","line":45,"column":6,"nodeType":"ArrayExpression","endLine":45,"endColumn":31,"suggestions":[{"desc":"Update the dependencies array to be: [user, user.preferences.theme]","fix":{"range":[1517,1542],"text":"[user, user.preferences.theme]"}}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":94,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":94,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { userProfileService, UserProfile } from '../services/userProfileService';\n\ninterface UserContextType {\n  user: UserProfile | null;\n  isLoading: boolean;\n  refreshUser: () => Promise<void>;\n  updatePreferences: (prefs: Partial<UserProfile['preferences']>) => Promise<void>;\n  switchProfile: (id: string) => Promise<void>;\n  updateExpertise: (level: UserProfile['expertise']) => Promise<void>;\n}\n\nconst UserContext = createContext<UserContextType | undefined>(undefined);\n\nexport const UserProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [user, setUser] = useState<UserProfile | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n\n  const refreshUser = async () => {\n    setIsLoading(true);\n    try {\n      const profile = await userProfileService.getActiveProfile();\n      setUser(profile);\n    } catch (error) {\n      console.error('Failed to load user profile:', error);\n      // Fallback handled by service, but if that fails, we might be in trouble.\n      // Ideally show error toast\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    refreshUser();\n  }, []);\n\n  // Sync Theme to DOM\n  useEffect(() => {\n    if (!user) return;\n    \n    // Remove old themes\n    document.body.classList.remove('theme-cyber', 'theme-industrial', 'theme-minimal');\n    // Add new theme\n    document.body.classList.add(`theme-${user.preferences.theme}`);\n  }, [user?.preferences.theme]);\n\n  const updatePreferences = async (prefs: Partial<UserProfile['preferences']>) => {\n    if (!user) return;\n    try {\n      const updated = await userProfileService.updatePreferences(user.id, prefs);\n      setUser(updated);\n      \n      // Apply CSS Variables for theme if needed (can be done in a separate effect or here)\n      // This will be handled by LayoutContext or a global style manager listening to user changes\n    } catch (error) {\n      console.error('Failed to update preferences:', error);\n    }\n  };\n\n  const switchProfile = async (id: string) => {\n    try {\n      userProfileService.switchProfile(id);\n      await refreshUser();\n    } catch (error) {\n      console.error('Failed to switch profile:', error);\n    }\n  };\n\n  const updateExpertise = async (level: UserProfile['expertise']) => {\n    if (!user) return;\n    try {\n      const updated = { ...user, expertise: level };\n      await userProfileService.saveProfile(updated);\n      setUser(updated);\n    } catch (error) {\n      console.error('Failed to update expertise:', error);\n    }\n  };\n\n  return (\n    <UserContext.Provider value={{ \n      user, \n      isLoading, \n      refreshUser, \n      updatePreferences, \n      switchProfile,\n      updateExpertise \n    }}>\n      {children}\n    </UserContext.Provider>\n  );\n};\n\nexport const useUser = () => {\n  const context = useContext(UserContext);\n  if (context === undefined) {\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/contexts/VoiceAssistantContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":176,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":176,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect, useRef, useCallback, ReactNode } from 'react';\nimport { LiveSession } from '../services/liveAudio';\nimport { transcribeAudio } from '../services/geminiService';\nimport { useToast } from '../hooks/useToast';\n\ninterface VoiceAssistantContextType {\n  isRecording: boolean;\n  startRecording: () => Promise<void>;\n  stopRecording: () => void;\n  isProcessingAudio: boolean;\n  loadingText: string; // \"Transcribing...\", \"Thinking...\"\n  \n  isLiveActive: boolean;\n  liveStatus: string;\n  toggleLiveMode: () => Promise<void>;\n  \n  registerVisualContextProvider: (id: string, provider: () => Promise<Blob | null>) => void;\n  unregisterVisualContextProvider: (id: string) => void;\n  \n  // Event for when a transcription is ready\n  lastTranscription: string | null;\n  clearTranscription: () => void;\n}\n\nconst VoiceAssistantContext = createContext<VoiceAssistantContextType | undefined>(undefined);\n\nexport const VoiceAssistantProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const toast = useToast();\n  \n  // Recording State\n  const [isRecording, setIsRecording] = useState(false);\n  const [isProcessingAudio, setIsProcessingAudio] = useState(false);\n  const [loadingText, setLoadingText] = useState('');\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n  const [lastTranscription, setLastTranscription] = useState<string | null>(null);\n\n  // Live Mode State\n  const [isLiveActive, setIsLiveActive] = useState(false);\n  const [liveStatus, setLiveStatus] = useState('disconnected');\n  const liveSessionRef = useRef<LiveSession | null>(null);\n  \n  // Visual Context\n  const visualContextProvidersRef = useRef<Map<string, () => Promise<Blob | null>>>(new Map());\n\n  const registerVisualContextProvider = useCallback((id: string, provider: () => Promise<Blob | null>) => {\n    visualContextProvidersRef.current.set(id, provider);\n    // Update live session if active\n    if (liveSessionRef.current) {\n      liveSessionRef.current.setVisualContextProviders(Array.from(visualContextProvidersRef.current.values()));\n    }\n  }, []);\n\n  const unregisterVisualContextProvider = useCallback((id: string) => {\n    visualContextProvidersRef.current.delete(id);\n    // Update live session if active\n    if (liveSessionRef.current) {\n      liveSessionRef.current.setVisualContextProviders(Array.from(visualContextProvidersRef.current.values()));\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (mediaRecorderRef.current) {\n        if (mediaRecorderRef.current.state === 'recording') {\n          mediaRecorderRef.current.stop();\n        }\n        mediaRecorderRef.current.stream?.getTracks().forEach((track) => track.stop());\n      }\n      if (liveSessionRef.current) {\n        liveSessionRef.current.disconnect();\n      }\n    };\n  }, []);\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (err: unknown) {\n      const message = err instanceof Error ? err.message : 'Unknown error';\n      console.error(message);\n      toast.error('Could not access microphone.');\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.onstop = async () => {\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });\n        setIsRecording(false);\n        setLoadingText('Transcribing...');\n        setIsProcessingAudio(true);\n\n        try {\n          const reader = new FileReader();\n          reader.readAsDataURL(audioBlob);\n          reader.onloadend = async () => {\n            const base64Audio = reader.result as string;\n            const transcription = await transcribeAudio(base64Audio);\n            setIsProcessingAudio(false);\n            setLoadingText('');\n            \n            if (transcription && transcription.trim()) {\n              setLastTranscription(transcription.trim());\n            } else {\n              toast.warning('No speech detected.');\n            }\n          };\n        } catch (_e: unknown) {\n          toast.error('Transcription failed.');\n          setIsProcessingAudio(false);\n          setLoadingText('');\n        }\n        mediaRecorderRef.current?.stream.getTracks().forEach((track) => track.stop());\n      };\n      mediaRecorderRef.current.stop();\n    }\n  };\n\n  const toggleLiveMode = async () => {\n    if (isLiveActive) {\n      liveSessionRef.current?.disconnect();\n      setIsLiveActive(false);\n    } else {\n      setIsLiveActive(true);\n      liveSessionRef.current = new LiveSession((status) => {\n        setLiveStatus(status);\n        if (status === 'disconnected' || status === 'error') {\n          setIsLiveActive(false);\n        }\n      });\n\n      if (visualContextProvidersRef.current.size > 0) {\n        liveSessionRef.current.setVisualContextProviders(Array.from(visualContextProvidersRef.current.values()));\n      }\n\n      await liveSessionRef.current.connect();\n    }\n  };\n  \n  const clearTranscription = () => setLastTranscription(null);\n\n  return (\n    <VoiceAssistantContext.Provider value={{\n      isRecording,\n      startRecording,\n      stopRecording,\n      isProcessingAudio,\n      loadingText,\n      isLiveActive,\n      liveStatus,\n      toggleLiveMode,\n      registerVisualContextProvider,\n      unregisterVisualContextProvider,\n      lastTranscription,\n      clearTranscription\n    }}>\n      {children}\n    </VoiceAssistantContext.Provider>\n  );\n};\n\nexport const useVoiceAssistant = () => {\n  const context = useContext(VoiceAssistantContext);\n  if (context === undefined) {\n    throw new Error('useVoiceAssistant must be used within a VoiceAssistantProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/__tests__/useConversations.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/appControlHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/canvasHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/diagramHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateDiagram' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":148,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ActionContext, HandlerResult } from './types';\nimport { ElectronicComponent, ActionRecord } from '../../types';\n\nconst generateId = () => `action-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\ninterface AddComponentPayload {\n  component: ElectronicComponent;\n  x?: number;\n  y?: number;\n}\n\ninterface RemoveComponentPayload {\n  componentId: string;\n}\n\ninterface CreateConnectionPayload {\n  fromComponentId: string;\n  fromPin: string;\n  toComponentId: string;\n  toPin: string;\n  color?: string;\n  description?: string;\n}\n\ninterface RemoveConnectionPayload {\n  wireIndex: number;\n}\n\nexport async function addComponent(\n  payload: AddComponentPayload,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { component, x, y } = payload;\n  const { diagram, updateDiagram, canvasRef, activeConversationId, recordUndo } = context;\n\n  if (!diagram) {\n    return { success: false, error: 'No active diagram' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'addComponent',\n    payload: { componentId: component.id },\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  // Deep clone to ensure isolation from inventory\n  const newComponent = JSON.parse(JSON.stringify({\n    ...component,\n    id: `${component.id}-${Date.now()}`,\n    sourceInventoryId: component.id\n  }));\n\n  updateDiagram({\n    ...diagram,\n    components: [...diagram.components, newComponent],\n  });\n\n  if (x !== undefined && y !== undefined) {\n    canvasRef.current?.setComponentPosition(newComponent.id, x, y);\n  }\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n\nexport async function removeComponent(\n  payload: RemoveComponentPayload,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { componentId } = payload;\n  const { diagram, updateDiagram, activeConversationId, recordUndo } = context;\n\n  if (!diagram) {\n    return { success: false, error: 'No active diagram' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'removeComponent',\n    payload: { componentId },\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  updateDiagram({\n    ...diagram,\n    components: diagram.components.filter((c) => c.id !== componentId),\n    connections: diagram.connections.filter(\n      (conn) => conn.fromComponentId !== componentId && conn.toComponentId !== componentId\n    ),\n  });\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n\nexport async function createConnection(\n  payload: CreateConnectionPayload,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { fromComponentId, fromPin, toComponentId, toPin, color, description } = payload;\n  const { diagram, updateDiagram, activeConversationId, recordUndo } = context;\n\n  if (!diagram) {\n    return { success: false, error: 'No active diagram' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'createConnection',\n    payload: { fromComponentId, fromPin, toComponentId, toPin },\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  updateDiagram({\n    ...diagram,\n    connections: [\n      ...diagram.connections,\n      {\n        fromComponentId,\n        fromPin,\n        toComponentId,\n        toPin,\n        color: color || '#00f3ff',\n        description: description || 'Connection',\n      },\n    ],\n  });\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n\nexport async function removeConnection(\n  payload: RemoveConnectionPayload,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { wireIndex } = payload;\n  const { diagram, updateDiagram, activeConversationId, recordUndo } = context;\n\n  if (!diagram || wireIndex < 0 || wireIndex >= diagram.connections.length) {\n    return { success: false, error: 'Invalid wire index' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'removeConnection',\n    payload: { wireIndex, connection: diagram.connections[wireIndex] },\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n\nexport async function clearCanvas(\n  _payload: Record<string, unknown>,\n  context: ActionContext\n): Promise<HandlerResult> {\n  const { diagram, updateDiagram, activeConversationId, recordUndo } = context;\n\n  if (!diagram) {\n    return { success: false, error: 'No active diagram' };\n  }\n\n  const undoRecord: ActionRecord = {\n    id: generateId(),\n    timestamp: Date.now(),\n    type: 'clearCanvas',\n    payload: {},\n    conversationId: activeConversationId || undefined,\n    undoable: true,\n    snapshotBefore: JSON.parse(JSON.stringify(diagram)),\n  };\n\n  updateDiagram({\n    ...diagram,\n    components: [],\n    connections: [],\n  });\n\n  await recordUndo(undoRecord);\n  return { success: true };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/navHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/actions/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useAIActions.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'addRecordedStep', 'isRecording', 'perms.canEditInventory', and 'perms.canModifyDiagram'. Either include them or remove the dependency array.","line":112,"column":6,"nodeType":"ArrayExpression","endLine":117,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [canvasRef, inventory, diagram, setInventory, setInventoryOpen, setSettingsOpen, setSelectedComponent, setGenerationMode, updateDiagram, activeConversationId, recordUndo, handleUndo, handleRedo, saveDiagram, loadDiagram, addToHistory, perms.canModifyDiagram, perms.canEditInventory, isRecording, pushActionDelta, addRecordedStep]","fix":{"range":[4955,5226],"text":"[canvasRef, inventory, diagram, setInventory, setInventoryOpen, setSettingsOpen, setSelectedComponent, setGenerationMode, updateDiagram, activeConversationId, recordUndo, handleUndo, handleRedo, saveDiagram, loadDiagram, addToHistory, perms.canModifyDiagram, perms.canEditInventory, isRecording, pushActionDelta, addRecordedStep]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'stagedActions'. Either exclude it or remove the dependency array.","line":130,"column":6,"nodeType":"ArrayExpression","endLine":130,"endColumn":21,"suggestions":[{"desc":"Update the dependencies array to be: []","fix":{"range":[5715,5730],"text":"[]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useState, useMemo } from 'react';\nimport { ActionIntent, ElectronicComponent } from '../types';\nimport { DiagramCanvasRef, HighlightOptions } from '../components/DiagramCanvas';\nimport { getHandler, ActionContext } from './actions';\nimport { useAutonomySettings } from './useAutonomySettings';\nimport { useActionHistory, ActionResult } from './useActionHistory';\nimport { useInventory } from '../contexts/InventoryContext';\nimport { useDiagram } from '../contexts/DiagramContext';\nimport { useLayout } from '../contexts/LayoutContext';\nimport { useAssistantState } from '../contexts/AssistantStateContext';\nimport { useConversationContext } from '../contexts/ConversationContext';\nimport { useMacros } from '../contexts/MacroContext';\nimport { engineeringMetricsService } from '../services/aiMetricsService';\nimport { usePermissions } from './usePermissions';\nimport { auditService } from '../services/logging/auditService';\nimport { PredictiveAction } from '../services/predictionEngine';\n\nexport type { ActionResult } from './useActionHistory';\n\nexport interface UseAIActionsOptions {\n  canvasRef: React.RefObject<DiagramCanvasRef | null>; // Updated type to match nullable ref\n  setSelectedComponent: (component: ElectronicComponent | null) => void;\n}\n\nexport function useAIActions(options: UseAIActionsOptions) {\n  const { canvasRef, setSelectedComponent } = options;\n\n  // Contexts\n  const { inventory, setInventory } = useInventory();\n  const { diagram, updateDiagram, undo: handleUndo, redo: handleRedo, saveToQuickSlot: saveDiagram, loadFromQuickSlot: loadDiagram } = useDiagram();\n  const { setInventoryOpen, setSettingsOpen } = useLayout();\n  const { setGenerationMode, pushActionDelta } = useAssistantState();\n  const { activeConversationId } = useConversationContext();\n\n  const [pendingActions, setPendingActions] = useState<ActionIntent[]>([]);\n  const [stagedActions, setStagedActions] = useState<PredictiveAction[]>([]);\n  const { autonomySettings, updateAutonomySettings, isActionSafe } = useAutonomySettings();\n  const { actionHistory, addToHistory, recordUndo, undo, canUndo } = useActionHistory(updateDiagram);\n  const { isRecording, addRecordedStep } = useMacros();\n  const perms = usePermissions();\n\n  // Execute action via handler registry\n  const executeAction = useCallback(async (action: ActionIntent, auto: boolean): Promise<ActionResult> => {\n    // 0. Permission Check\n    if (action.type === 'addComponent' || action.type === 'removeComponent' || action.type === 'clearCanvas') {\n      if (!perms.canModifyDiagram) {\n        return { action, success: false, timestamp: Date.now(), auto, error: 'Access Denied: Insufficient Permissions' };\n      }\n    }\n    if (action.type === 'openInventory') {\n      if (!perms.canEditInventory) {\n        // Observers can see inventory but maybe not edit? \n        // For now let's be strict if we want to guard the tab\n      }\n    }\n\n    // ...\n    // context building omitted for brevity in replace\n    const context: ActionContext = {\n      canvasRef: canvasRef as React.RefObject<DiagramCanvasRef>, // Cast for compatibility with handler types\n      inventory, diagram, setInventory,\n      setIsInventoryOpen: setInventoryOpen,\n      setIsSettingsOpen: setSettingsOpen,\n      setSelectedComponent,\n      setGenerationMode, updateDiagram, activeConversationId,\n      recordUndo,\n      // App Controls\n      handleUndo, handleRedo, saveDiagram, loadDiagram\n    };\n\n    const result: ActionResult = {\n      action,\n      success: false,\n      timestamp: Date.now(),\n      auto,\n    }\n\n    try {\n      const handler = getHandler(action.type);\n      if (!handler) {\n        result.error = `Unknown action type: ${action.type}`;\n        auditService.log('error', 'action-handler', `Unknown action type: ${action.type}`);\n      } else {\n        const handlerResult = await handler(action.payload, context);\n        result.success = handlerResult.success;\n        result.error = handlerResult.error;\n        \n        if (!result.success) {\n          auditService.log('warn', 'action-handler', `Action failed: ${action.type}`, { error: result.error });\n        }\n      }\n    } catch (err) {\n      result.error = err instanceof Error ? err.message : 'Unknown error';\n      auditService.log('error', 'action-handler', `Action crashed: ${action.type}`, { error: result.error });\n    }\n\n    if (result.success) {\n      auditService.log('info', 'action-handler', `Action executed: ${action.type}`, { label: action.label, auto });\n      engineeringMetricsService.logEvent('action_execute', { type: action.type, label: action.label });\n      if (isRecording) {\n        addRecordedStep(action);\n      }\n      pushActionDelta({\n        type: action.type,\n        targetId: (action.payload['componentId'] || action.payload['nodeId'] || action.payload['id']) as string | undefined,\n        description: action.label\n      });\n    }\n\n    addToHistory(result);\n    return result;\n  }, [\n    canvasRef, inventory, diagram, setInventory,\n    setInventoryOpen, setSettingsOpen, setSelectedComponent,\n    setGenerationMode, updateDiagram, activeConversationId,\n    recordUndo, addToHistory, handleUndo, handleRedo, saveDiagram, loadDiagram, pushActionDelta\n  ]);\n\n  // Staged Actions (Predictions)\n  const acceptStagedAction = useCallback(async (id: string) => {\n    const prediction = stagedActions.find((a) => a.id === id);\n    if (prediction) {\n      setStagedActions((prev) => prev.filter((a) => a.id !== id));\n      return await executeAction(prediction.action, false);\n    }\n  }, [stagedActions, executeAction]);\n\n  const rejectStagedAction = useCallback((id: string) => {\n    setStagedActions((prev) => prev.filter((a) => a.id !== id));\n  }, [stagedActions]);\n\n  const clearStagedActions = useCallback(() => setStagedActions([]), []);\n  const stageActions = useCallback((actions: PredictiveAction[]) => setStagedActions(actions), []);\n\n  // Main execute - checks autonomy settings\n  const execute = useCallback(async (action: ActionIntent): Promise<ActionResult> => {\n    const safe = action.safe ?? isActionSafe(action.type);\n\n    if (safe && autonomySettings.autoExecuteSafeActions) {\n      return executeAction(action, true);\n    } else {\n      setPendingActions((prev) => [...prev, action]);\n      return {\n        action,\n        success: false,\n        timestamp: Date.now(),\n        auto: false,\n        error: 'Awaiting user confirmation',\n      };\n    }\n  }, [autonomySettings, isActionSafe, executeAction]);\n\n  const confirmAction = useCallback(async (action: ActionIntent): Promise<ActionResult> => {\n    setPendingActions((prev) => prev.filter((a) => a !== action));\n    return executeAction(action, false);\n  }, [executeAction]);\n\n  const rejectAction = useCallback((action: ActionIntent) => {\n    setPendingActions((prev) => prev.filter((a) => a !== action));\n  }, []);\n\n  const clearPendingActions = useCallback(() => setPendingActions([]), []);\n\n  // Convenience shortcuts (direct canvas calls)\n  const highlightComponent = useCallback((id: string, opts?: HighlightOptions) => {\n    canvasRef.current?.highlightComponent(id, opts);\n  }, [canvasRef]);\n\n  const centerOnComponent = useCallback((id: string) => {\n    canvasRef.current?.centerOnComponent(id);\n  }, [canvasRef]);\n\n  const zoomTo = useCallback((level: number) => {\n    canvasRef.current?.setZoom(level);\n  }, [canvasRef]);\n\n  const resetView = useCallback(() => {\n    canvasRef.current?.resetView();\n  }, [canvasRef]);\n\n  const openInventory = useCallback(() => setInventoryOpen(true), [setInventoryOpen]);\n  const closeInventory = useCallback(() => setInventoryOpen(false), [setInventoryOpen]);\n  const openSettings = useCallback(() => setSettingsOpen(true), [setSettingsOpen]);\n  const closeSettings = useCallback(() => setSettingsOpen(false), [setSettingsOpen]);\n\n  const openComponentEditor = useCallback((componentId: string) => {\n    const component = inventory.find((c) => c.id === componentId);\n    if (component) setSelectedComponent(component);\n  }, [inventory, setSelectedComponent]);\n\n  const switchGenerationMode = useCallback((mode: 'chat' | 'image' | 'video') => {\n    setGenerationMode(mode);\n  }, [setGenerationMode]);\n\n  return useMemo(() => ({\n    execute,\n    pendingActions,\n    confirmAction,\n    rejectAction,\n    clearPendingActions,\n    stagedActions,\n    acceptStagedAction,\n    rejectStagedAction,\n    clearStagedActions,\n    stageActions,\n    canUndo,\n    undo,\n    actionHistory,\n    highlightComponent,\n    centerOnComponent,\n    zoomTo,\n    resetView,\n    openInventory,\n    closeInventory,\n    openSettings,\n    closeSettings,\n    openComponentEditor,\n    switchGenerationMode,\n    autonomySettings,\n    updateAutonomySettings,\n  }), [\n    execute,\n    pendingActions,\n    confirmAction,\n    rejectAction,\n    clearPendingActions,\n    stagedActions,\n    acceptStagedAction,\n    rejectStagedAction,\n    clearStagedActions,\n    stageActions,\n    canUndo,\n    undo,\n    actionHistory,\n    highlightComponent,\n    centerOnComponent,\n    zoomTo,\n    resetView,\n    openInventory,\n    closeInventory,\n    openSettings,\n    closeSettings,\n    openComponentEditor,\n    switchGenerationMode,\n    autonomySettings,\n    updateAutonomySettings,\n  ]);\n}\n\n// Re-export for backwards compatibility\nexport { saveAutonomySettings } from './useAutonomySettings';","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useActionHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useAutonomySettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useClickOutside.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useConnectivity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useConversations.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5230,5233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5230,5233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'react';\nimport { Conversation, EnhancedChatMessage, WiringDiagram, GroundingSource } from '../types';\nimport {\n  saveConversation,\n  listConversations,\n  deleteConversation as deleteConversationFromDB,\n  getPrimaryConversation,\n  saveMessage,\n  loadMessages,\n} from '../services/storage';\n\n// Generate a unique ID\nconst generateId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n// Generate title from first message\nconst generateTitle = (content: string): string => {\n  const cleaned = content.replace(/\\n/g, ' ').trim();\n  if (cleaned.length <= 50) return cleaned;\n  return cleaned.substring(0, 47) + '...';\n};\n\nconst WELCOME_MESSAGE = 'System Online. I am CircuitMind AI.\\n\\nI can generate wiring diagrams, create concept art, analyze your circuit photos/videos, or answer complex questions.';\n\nexport interface UseConversationsReturn {\n  // State\n  conversations: Conversation[];\n  activeConversationId: string | null;\n  activeConversation: Conversation | null;\n  messages: EnhancedChatMessage[];\n  isLoading: boolean;\n\n  // Conversation CRUD\n  createConversation: (isPrimary?: boolean) => Promise<string>;\n  switchConversation: (id: string) => Promise<void>;\n  deleteConversation: (id: string) => Promise<void>;\n  renameConversation: (id: string, title: string) => Promise<void>;\n\n  // Message operations\n  addMessage: (\n    message: Omit<EnhancedChatMessage, 'id' | 'conversationId' | 'timestamp'>\n  ) => Promise<EnhancedChatMessage>;\n  updateMessage: (id: string, updates: Partial<EnhancedChatMessage>) => Promise<void>;\n\n  // Utility\n  getOrCreatePrimaryConversation: () => Promise<string>;\n  refreshConversations: () => Promise<void>;\n}\n\nexport function useConversations(): UseConversationsReturn {\n  const [conversations, setConversations] = useState<Conversation[]>([]);\n  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);\n  const [messages, setMessages] = useState<EnhancedChatMessage[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Track if we've initialized\n  const initialized = useRef(false);\n\n  // Get active conversation object\n  const activeConversation = conversations.find((c) => c.id === activeConversationId) || null;\n\n  // Load conversations on mount\n  useEffect(() => {\n    if (initialized.current) return;\n    initialized.current = true;\n\n    const init = async () => {\n      setIsLoading(true);\n      try {\n        // Load all conversations (most recent first)\n        const convs = await listConversations(50);\n        setConversations(convs);\n\n        // Try to find or create primary conversation\n        let primary = await getPrimaryConversation();\n        if (!primary && convs.length === 0) {\n          // Create first primary conversation\n          const id = generateId();\n          primary = {\n            id,\n            title: 'CircuitMind Session',\n            createdAt: Date.now(),\n            updatedAt: Date.now(),\n            messageCount: 0,\n            isPrimary: true,\n          };\n          await saveConversation(primary);\n          setConversations([primary]);\n        }\n\n        // Activate primary or most recent\n        const toActivate = primary || convs[0];\n        if (toActivate) {\n          setActiveConversationId(toActivate.id);\n          const msgs = await loadMessages(toActivate.id);\n          if (msgs.length === 0 && toActivate.isPrimary) {\n            const welcomeMessage: EnhancedChatMessage = {\n              id: generateId(),\n              conversationId: toActivate.id,\n              role: 'model',\n              content: WELCOME_MESSAGE,\n              timestamp: Date.now(),\n              linkedComponents: [],\n              suggestedActions: [],\n            };\n            await saveMessage(welcomeMessage);\n            setMessages([welcomeMessage]);\n\n            const updatedConversation: Conversation = {\n              ...toActivate,\n              messageCount: 1,\n              updatedAt: Date.now(),\n              lastMessagePreview: welcomeMessage.content.substring(0, 100),\n            };\n            await saveConversation(updatedConversation);\n            setConversations((prev) =>\n              prev.map((c) => (c.id === updatedConversation.id ? updatedConversation : c))\n            );\n          } else {\n            setMessages(msgs);\n          }\n        }\n      } catch (e) {\n        console.error('Failed to initialize conversations:', e);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    init();\n  }, []);\n\n  const createConversationInternal = useCallback(async (\n    isPrimary: boolean,\n    title?: string\n  ): Promise<Conversation> => {\n    const id = generateId();\n    const conversation: Conversation = {\n      id,\n      title: title || (isPrimary ? 'CircuitMind Session' : 'New Conversation'),\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      messageCount: 0,\n      isPrimary,\n    };\n\n    await saveConversation(conversation);\n    setConversations((prev) => [conversation, ...prev]);\n    setActiveConversationId(id);\n    setMessages([]);\n\n    return conversation;\n  }, []);\n\n  // Create a new conversation\n  const createConversation = useCallback(async (isPrimaryArg: any = false): Promise<string> => {\n    // If called as an event handler, the first arg is an event object.\n    // We want to ensure it's a strict boolean.\n    const isPrimary = typeof isPrimaryArg === 'boolean' ? isPrimaryArg : false;\n    const conversation = await createConversationInternal(isPrimary);\n    return conversation.id;\n  }, [createConversationInternal]);\n\n  // Switch to a different conversation\n  const switchConversation = useCallback(async (id: string): Promise<void> => {\n    if (id === activeConversationId) return;\n\n    setIsLoading(true);\n    try {\n      const msgs = await loadMessages(id);\n      setMessages(msgs);\n      setActiveConversationId(id);\n    } catch (e) {\n      console.error('Failed to switch conversation:', e);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [activeConversationId]);\n\n  // Delete a conversation\n  const deleteConversation = useCallback(async (id: string): Promise<void> => {\n    await deleteConversationFromDB(id);\n    setConversations((prev) => prev.filter((c) => c.id !== id));\n\n    // If we deleted the active conversation, switch to another\n    if (id === activeConversationId) {\n      const remaining = conversations.filter((c) => c.id !== id);\n      if (remaining.length > 0) {\n        await switchConversation(remaining[0].id);\n      } else {\n        // Create new primary\n        await createConversation(true);\n      }\n    }\n  }, [activeConversationId, conversations, switchConversation, createConversation]);\n\n  // Rename a conversation\n  const renameConversation = useCallback(async (id: string, title: string): Promise<void> => {\n    const conv = conversations.find((c) => c.id === id);\n    if (!conv) return;\n\n    const updated: Conversation = {\n      ...conv,\n      title,\n      updatedAt: Date.now(),\n    };\n\n    await saveConversation(updated);\n    setConversations((prev) => prev.map((c) => (c.id === id ? updated : c)));\n  }, [conversations]);\n\n  // Add a message to the active conversation\n  const addMessage = useCallback(\n    async (\n      messageData: Omit<EnhancedChatMessage, 'id' | 'conversationId' | 'timestamp'>\n    ): Promise<EnhancedChatMessage> => {\n      const createdConversation = !activeConversationId\n        ? await createConversationInternal(true, 'CircuitMind Session')\n        : null;\n\n      const conversationId = activeConversationId || createdConversation?.id;\n      if (!conversationId) {\n        throw new Error('No active conversation available');\n      }\n\n      const message: EnhancedChatMessage = {\n        ...messageData,\n        id: generateId(),\n        conversationId,\n        timestamp: Date.now(),\n        linkedComponents: messageData.linkedComponents || [],\n        suggestedActions: messageData.suggestedActions || [],\n      };\n\n      await saveMessage(message);\n\n      setMessages((prev) => {\n        if (activeConversationId && conversationId !== activeConversationId) {\n          return prev;\n        }\n        return [...prev, message];\n      });\n\n      const conv = conversations.find((c) => c.id === conversationId) || createdConversation;\n      if (conv) {\n        const isFirstMessage = conv.messageCount === 0 && messageData.role === 'user';\n        const updated: Conversation = {\n          ...conv,\n          messageCount: conv.messageCount + 1,\n          updatedAt: Date.now(),\n          lastMessagePreview: messageData.content.substring(0, 100),\n          title: isFirstMessage ? generateTitle(messageData.content) : conv.title,\n        };\n        await saveConversation(updated);\n        setConversations((prev) =>\n          prev.map((c) => (c.id === conversationId ? updated : c))\n        );\n      }\n\n      return message;\n    },\n    [activeConversationId, conversations, createConversationInternal]\n  );\n\n  // Update an existing message\n  const updateMessage = useCallback(\n    async (id: string, updates: Partial<EnhancedChatMessage>): Promise<void> => {\n      const message = messages.find((m) => m.id === id);\n      if (!message) return;\n\n      const updated: EnhancedChatMessage = {\n        ...message,\n        ...updates,\n      };\n\n      await saveMessage(updated);\n      setMessages((prev) => prev.map((m) => (m.id === id ? updated : m)));\n    },\n    [messages]\n  );\n\n  // Get or create primary conversation\n  const getOrCreatePrimaryConversation = useCallback(async (): Promise<string> => {\n    const primary = await getPrimaryConversation();\n    if (primary) {\n      return primary.id;\n    }\n    return createConversation(true);\n  }, [createConversation]);\n\n  // Refresh conversations list\n  const refreshConversations = useCallback(async (): Promise<void> => {\n    const convs = await listConversations(50);\n    setConversations(convs);\n  }, []);\n\n  return {\n    // State\n    conversations,\n    activeConversationId,\n    activeConversation,\n    messages,\n    isLoading,\n\n    // Conversation CRUD\n    createConversation,\n    switchConversation,\n    deleteConversation,\n    renameConversation,\n\n    // Message operations\n    addMessage,\n    updateMessage,\n\n    // Utility\n    getOrCreatePrimaryConversation,\n    refreshConversations,\n  };\n}\n\n// Helper to convert old ChatMessage to EnhancedChatMessage\nexport function migrateMessage(\n  old: {\n    id: string;\n    role: 'user' | 'model' | 'system';\n    content: string;\n    timestamp?: number;\n    diagramData?: WiringDiagram;\n    image?: string;\n    video?: string;\n    groundingSources?: GroundingSource[];\n    audioResponse?: string;\n  },\n  conversationId: string\n): EnhancedChatMessage {\n  return {\n    id: old.id,\n    conversationId,\n    role: old.role,\n    content: old.content,\n    timestamp: old.timestamp || Date.now(),\n    diagramData: old.diagramData,\n    image: old.image,\n    video: old.video,\n    groundingSources: old.groundingSources,\n    audioResponse: old.audioResponse,\n    linkedComponents: [],\n    suggestedActions: [],\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useHoverBehavior.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useInventorySync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":213,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":213,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useInventorySync Hook\n *\n * Automatically syncs diagram components with inventory changes.\n * Inventory is the SINGLE SOURCE OF TRUTH - diagram components inherit changes.\n */\n\nimport { useEffect, useRef, useCallback } from 'react';\nimport type { ElectronicComponent, WiringDiagram } from '../types';\nimport {\n  validateDiagramInventoryConsistency,\n  syncDiagramWithInventory,\n} from '../services/componentValidator';\n\ninterface UseInventorySyncOptions {\n  /** Enable auto-sync when inventory changes (default: true) */\n  autoSync?: boolean;\n  /** Debounce time for validation in ms (default: 300) */\n  debounceMs?: number;\n  /** Callback when sync occurs */\n  onSync?: (changeCount: number) => void;\n  /** Callback when validation fails */\n  onValidationFail?: (mismatches: ReturnType<typeof validateDiagramInventoryConsistency>['mismatches']) => void;\n}\n\ninterface UseInventorySyncReturn {\n  /** Manually trigger sync */\n  syncNow: () => number;\n  /** Manually trigger validation */\n  validateNow: () => ReturnType<typeof validateDiagramInventoryConsistency>;\n  /** Last sync timestamp */\n  lastSyncTime: number | null;\n  /** Whether currently syncing */\n  isSyncing: boolean;\n}\n\n/**\n * Hook that keeps diagram components in sync with inventory\n *\n * @param inventory - Current inventory items\n * @param diagram - Current wiring diagram\n * @param updateDiagram - Function to update the diagram\n * @param options - Configuration options\n */\nexport function useInventorySync(\n  inventory: ElectronicComponent[],\n  diagram: WiringDiagram | null,\n  updateDiagram: (diagram: WiringDiagram) => void,\n  options: UseInventorySyncOptions = {}\n): UseInventorySyncReturn {\n  const {\n    autoSync = true,\n    debounceMs = 300,\n    onSync,\n    onValidationFail,\n  } = options;\n\n  const lastSyncTimeRef = useRef<number | null>(null);\n  const isSyncingRef = useRef(false);\n  const debounceTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const prevInventoryRef = useRef<string>('');\n\n  /**\n   * Manually validate diagram against inventory\n   */\n  const validateNow = useCallback(() => {\n    if (!diagram) {\n      return {\n        isValid: true,\n        mismatches: [],\n        orphanedCount: 0,\n        syncedCount: 0,\n        totalChecked: 0,\n      };\n    }\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    if (!result.isValid && onValidationFail) {\n      onValidationFail(result.mismatches);\n    }\n\n    return result;\n  }, [diagram, inventory, onValidationFail]);\n\n  /**\n   * Manually sync diagram with inventory\n   */\n  const syncNow = useCallback(() => {\n    if (!diagram) return 0;\n\n    isSyncingRef.current = true;\n\n    const { diagram: syncedDiagram, changeCount } = syncDiagramWithInventory(\n      diagram,\n      inventory\n    );\n\n    if (changeCount > 0) {\n      updateDiagram(syncedDiagram);\n      lastSyncTimeRef.current = Date.now();\n\n      if (onSync) {\n        onSync(changeCount);\n      }\n    }\n\n    isSyncingRef.current = false;\n    return changeCount;\n  }, [diagram, inventory, updateDiagram, onSync]);\n\n  /**\n   * Debounced sync triggered by inventory changes\n   */\n  const debouncedSync = useCallback(() => {\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n    }\n\n    debounceTimerRef.current = setTimeout(() => {\n      syncNow();\n    }, debounceMs);\n  }, [syncNow, debounceMs]);\n\n  /**\n   * Watch for inventory changes and auto-sync\n   */\n  useEffect(() => {\n    if (!autoSync || !diagram) return;\n\n    // Create a stable representation of inventory for comparison\n    const inventorySnapshot = JSON.stringify(\n      inventory.map(i => ({ id: i.id, name: i.name, type: i.type, pins: i.pins }))\n    );\n\n    // Skip if inventory hasn't actually changed\n    if (inventorySnapshot === prevInventoryRef.current) {\n      return;\n    }\n\n    prevInventoryRef.current = inventorySnapshot;\n\n    // First sync - no debounce\n    if (lastSyncTimeRef.current === null) {\n      syncNow();\n      return;\n    }\n\n    // Subsequent changes - debounce\n    debouncedSync();\n\n    return () => {\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current);\n      }\n    };\n  }, [inventory, diagram, autoSync, syncNow, debouncedSync]);\n\n  /**\n   * Validate on diagram changes\n   */\n  useEffect(() => {\n    if (!diagram || process.env.NODE_ENV !== 'development') return;\n\n    // Validate when diagram loads or changes\n    // We use a small timeout to let the sync effect finish if it's racing\n    const timer = setTimeout(() => {\n        const result = validateNow();\n\n        if (!result.isValid) {\n          console.warn(\n            ` Diagram has ${result.mismatches.length} inconsistencies.`\n          );\n        } else {\n            // Optional: Log success if we want to confirm sync\n            // console.log(' Diagram consistency verified');\n        }\n    }, 500);\n\n    return () => clearTimeout(timer);\n  }, [diagram, validateNow]);\n\n  return {\n    syncNow,\n    validateNow,\n    lastSyncTime: lastSyncTimeRef.current,\n    isSyncing: isSyncingRef.current,\n  };\n}\n\n/**\n * Lightweight validation hook for dev mode warnings\n * (Less overhead than full sync hook)\n */\nexport function useDevValidation(\n  inventory: ElectronicComponent[],\n  diagram: WiringDiagram | null,\n  debounceMs = 300\n): void {\n  const debounceTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  useEffect(() => {\n    // Only run in development\n    if (process.env.NODE_ENV !== 'development') return;\n    if (!diagram) return;\n\n    // Debounced validation\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n    }\n\n    debounceTimerRef.current = setTimeout(() => {\n      const result = validateDiagramInventoryConsistency(diagram, inventory);\n      // Validation runs silently - check result in dev tools if needed\n    }, debounceMs);\n\n    return () => {\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current);\n      }\n    };\n  }, [inventory, diagram, debounceMs]);\n}\n\nexport default useInventorySync;\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useNeuralLink.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2901,2904],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2901,2904],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef, useCallback } from 'react';\nimport { gestureEngine, GestureResult } from '../services/gesture/GestureEngine';\nimport { useLayout } from '../contexts/LayoutContext';\n\nexport function useNeuralLink() {\n  const { lowPerformanceMode } = useLayout();\n  const [isActive, setIsActive] = useState(false);\n  const [isInitializing, setIsInitializing] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [result, setResult] = useState<GestureResult | null>(null);\n  \n  const videoRef = useRef<HTMLVideoElement | null>(null);\n  const rafRef = useRef<number | null>(null);\n  \n  // Use refs to avoid startTracking identity changes and infinite loops\n  const isActiveRef = useRef(false);\n  const isInitializingRef = useRef(false);\n\n  const stopTracking = useCallback(() => {\n    if (rafRef.current) cancelAnimationFrame(rafRef.current);\n    if (videoRef.current?.srcObject) {\n      (videoRef.current.srcObject as MediaStream).getTracks().forEach(t => t.stop());\n    }\n    setIsActive(false);\n    isActiveRef.current = false;\n    setIsInitializing(false);\n    isInitializingRef.current = false;\n  }, []);\n\n  const startTracking = useCallback(async () => {\n    if (isActiveRef.current || isInitializingRef.current) return;\n    \n    setIsInitializing(true);\n    isInitializingRef.current = true;\n    try {\n      setError(null);\n      await gestureEngine.init();\n\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('Camera API not supported in this browser/context');\n      }\n\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          width: { ideal: 640 },\n          height: { ideal: 480 },\n          frameRate: { ideal: 30 }\n        },\n        audio: false\n      });\n\n      if (!videoRef.current) {\n        videoRef.current = document.createElement('video');\n        videoRef.current.setAttribute('playsinline', '');\n      }\n      videoRef.current.srcObject = stream;\n      \n      await new Promise((resolve) => {\n        if (!videoRef.current) return resolve(null);\n        videoRef.current.onloadedmetadata = () => resolve(null);\n      });\n\n      await videoRef.current.play();\n\n      setIsActive(true);\n      isActiveRef.current = true;\n      setIsInitializing(false);\n      isInitializingRef.current = false;\n\n      const tick = async () => {\n        if (!videoRef.current || videoRef.current.paused) return;\n        \n        try {\n          await gestureEngine.processFrame(videoRef.current);\n        } catch (err) {\n          console.warn('Neural Link tracking tick failed:', err);\n        }\n\n        if (lowPerformanceMode) {\n          setTimeout(() => {\n            rafRef.current = requestAnimationFrame(tick);\n          }, 100);\n        } else {\n          rafRef.current = requestAnimationFrame(tick);\n        }\n      };\n\n      tick();\n    } catch (e: any) {\n      console.error('Neural Link: Failed to start:', e);\n      setError(e.message || 'Camera access denied');\n      setIsActive(false);\n      isActiveRef.current = false;\n      setIsInitializing(false);\n      isInitializingRef.current = false;\n    }\n  }, [lowPerformanceMode]);\n\n  useEffect(() => {\n    const unsub = gestureEngine.onLandmarks((res) => {\n      setResult(res);\n    });\n    return () => {\n      unsub();\n      stopTracking();\n    };\n  }, [stopTracking]);\n\n  const getSnapshotBlob = useCallback(async (): Promise<Blob | null> => {\n    if (!videoRef.current || videoRef.current.paused) return null;\n    const canvas = document.createElement('canvas');\n    canvas.width = videoRef.current.videoWidth;\n    canvas.height = videoRef.current.videoHeight;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return null;\n    ctx.drawImage(videoRef.current, 0, 0);\n    return new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.7));\n  }, []);\n\n  return {\n    isActive,\n    isInitializing,\n    startTracking,\n    stopTracking,\n    error,\n    result,\n    getSnapshotBlob,\n    // Engagement check: Hand landmarks must be present\n    isEngaged: result && result.landmarks.length > 0\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/usePermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useResizeHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/hooks/useToast.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":104,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":104,"endColumn":28},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":115,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":115,"endColumn":26},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":124,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":124,"endColumn":25},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":227,"column":16,"nodeType":"Identifier","messageId":"namedExport","endLine":227,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Toast Notification System\n *\n * Lightweight toast notifications replacing browser alert() calls.\n * Matches the app's dark theme aesthetic.\n */\n\nimport React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\n\n// ============================================\n// Types\n// ============================================\n\nexport type ToastType = 'success' | 'error' | 'warning' | 'info';\n\nexport interface ToastAction {\n  label: string;\n  onClick: () => void;\n}\n\nexport interface Toast {\n  id: string;\n  type: ToastType;\n  message: string;\n  duration?: number;\n  action?: ToastAction;\n}\n\n// ============================================\n// Contexts\n// ============================================\n\nconst ToastStateContext = createContext<Toast[]>([]);\nconst ToastApiContext = createContext<{\n  addToast: (type: ToastType, message: string, duration?: number, action?: ToastAction, id?: string) => string;\n  removeToast: (id: string) => void;\n  success: (message: string, duration?: number, action?: ToastAction, id?: string) => string;\n  error: (message: string, duration?: number, action?: ToastAction, id?: string) => string;\n  warning: (message: string, duration?: number, action?: ToastAction, id?: string) => string;\n  info: (message: string, duration?: number, action?: ToastAction, id?: string) => string;\n} | null>(null);\n\n// ============================================\n// Provider\n// ============================================\n\ninterface ToastProviderProps {\n  children: ReactNode;\n}\n\nexport function ToastProvider({ children }: ToastProviderProps) {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n\n  const removeToast = useCallback((id: string) => {\n    setToasts(prev => prev.filter(t => t.id !== id));\n  }, []);\n\n  const addToast = useCallback(\n    (type: ToastType, message: string, duration = 4000, action?: ToastAction, manualId?: string) => {\n      const id = manualId || `toast-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n      const toast: Toast = { id, type, message, duration, action };\n\n      setToasts(prev => {\n        if (prev.some(t => t.id === id)) return prev;\n        return [...prev, toast];\n      });\n\n      if (duration > 0) {\n        setTimeout(() => removeToast(id), duration);\n      }\n\n      return id;\n    },\n    [removeToast]\n  );\n\n  const success = useCallback((msg: string, dur?: number, act?: ToastAction, id?: string) => addToast('success', msg, dur, act, id), [addToast]);\n  const error = useCallback((msg: string, dur?: number, act?: ToastAction, id?: string) => addToast('error', msg, dur ?? 6000, act, id), [addToast]);\n  const warning = useCallback((msg: string, dur?: number, act?: ToastAction, id?: string) => addToast('warning', msg, dur ?? 5000, act, id), [addToast]);\n  const info = useCallback((msg: string, dur?: number, act?: ToastAction, id?: string) => addToast('info', msg, dur, act, id), [addToast]);\n\n  const api = React.useMemo(() => ({\n    addToast, removeToast, success, error, warning, info\n  }), [addToast, removeToast, success, error, warning, info]);\n\n  return (\n    <ToastStateContext.Provider value={toasts}>\n      <ToastApiContext.Provider value={api}>\n        {children}\n        <ToastContainer toasts={toasts} onDismiss={removeToast} />\n      </ToastApiContext.Provider>\n    </ToastStateContext.Provider>\n  );\n}\n\n// ============================================\n// Hooks\n// ============================================\n\n/**\n * Hook for components that only need to trigger toasts.\n * Returns a stable API that won't trigger re-renders when toasts change.\n */\nexport function useToastApi() {\n  const api = useContext(ToastApiContext);\n  if (!api) {\n    throw new Error('useToastApi must be used within a ToastProvider');\n  }\n  return api;\n}\n\n/**\n * Hook for components that need to display the list of toasts.\n */\nexport function useToasts() {\n  return useContext(ToastStateContext);\n}\n\n/**\n * Legacy hook for backward compatibility. \n * NOTE: Using this in useEffect dependencies will cause infinite loops \n * if any toast is added/removed. Use useToastApi() instead.\n */\nexport function useToast() {\n  const toasts = useToasts();\n  const api = useToastApi();\n  \n  return React.useMemo(() => ({\n    toasts,\n    ...api\n  }), [toasts, api]);\n}\n\n// ============================================\n// Toast Container Component\n// ============================================\n\ninterface ToastContainerProps {\n  toasts: Toast[];\n  onDismiss: (id: string) => void;\n}\n\nfunction ToastContainer({ toasts, onDismiss }: ToastContainerProps) {\n  if (toasts.length === 0) return null;\n\n  return (\n    <div className=\"fixed bottom-4 right-4 z-[100] flex flex-col gap-2 max-w-sm\">\n      {toasts.map(toast => (\n        <ToastItem key={toast.id} toast={toast} onDismiss={onDismiss} />\n      ))}\n    </div>\n  );\n}\n\n// ============================================\n// Individual Toast Component\n// ============================================\n\ninterface ToastItemProps {\n  toast: Toast;\n  onDismiss: (id: string) => void;\n}\n\nconst TOAST_STYLES: Record<ToastType, { bg: string; border: string; icon: string }> = {\n  success: {\n    bg: 'bg-green-950/90',\n    border: 'border-green-700',\n    icon: '',\n  },\n  error: {\n    bg: 'bg-red-950/90',\n    border: 'border-red-700',\n    icon: '',\n  },\n  warning: {\n    bg: 'bg-yellow-950/90',\n    border: 'border-yellow-700',\n    icon: '',\n  },\n  info: {\n    bg: 'bg-blue-950/90',\n    border: 'border-blue-700',\n    icon: '',\n  },\n};\n\nfunction ToastItem({ toast, onDismiss }: ToastItemProps) {\n  const style = TOAST_STYLES[toast.type];\n\n  return (\n    <div\n      className={`\n        ${style.bg} ${style.border}\n        border px-4 py-3 cut-corner-sm\n        shadow-lg backdrop-blur-sm\n        animate-slide-in-right\n        flex items-start gap-3\n        text-sm text-gray-100\n      `}\n      role=\"alert\"\n    >\n      <span className=\"text-lg leading-none mt-0.5\">{style.icon}</span>\n      <p className=\"flex-1 leading-snug\">{toast.message}</p>\n      {toast.action && (\n        <button\n          onClick={() => {\n            toast.action?.onClick();\n            onDismiss(toast.id);\n          }}\n          className=\"text-[10px] font-semibold uppercase tracking-[0.28em] text-neon-cyan hover:text-white transition-colors\"\n          aria-label={toast.action.label}\n        >\n          {toast.action.label}\n        </button>\n      )}\n      <button\n        onClick={() => onDismiss(toast.id)}\n        className=\"text-gray-400 hover:text-white transition-colors ml-2\"\n        aria-label=\"Dismiss\"\n      >\n        \n      </button>\n    </div>\n  );\n}\n\nexport default useToast;\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/aiMetricsService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/componentValidator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vi' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for componentValidator service\n * Ensures inventory-canvas consistency validation works correctly\n */\n\nimport { describe, it, expect, vi } from 'vitest';\nimport {\n  validateDiagramInventoryConsistency,\n  analyzeUsage,\n  determineOrphanAction,\n  syncComponentWithInventory,\n  syncDiagramWithInventory,\n  removeOrphanedComponents,\n} from '../componentValidator';\nimport type { ElectronicComponent, WiringDiagram } from '../../types';\n\n// ============================================\n// Test Data Factories\n// ============================================\n\nconst createComponent = (overrides: Partial<ElectronicComponent> = {}): ElectronicComponent => ({\n  id: 'test-component',\n  name: 'Test Component',\n  type: 'sensor',\n  description: 'A test component',\n  pins: ['VCC', 'GND', 'DATA'],\n  ...overrides,\n});\n\nconst createDiagram = (components: ElectronicComponent[] = [], connections: any[] = []): WiringDiagram => ({\n  title: 'Test Diagram',\n  components,\n  connections,\n  explanation: 'Test diagram',\n});\n\n// ============================================\n// validateDiagramInventoryConsistency Tests\n// ============================================\n\ndescribe('validateDiagramInventoryConsistency', () => {\n  it('should return valid for empty diagram', () => {\n    const diagram = createDiagram();\n    const inventory: ElectronicComponent[] = [];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(true);\n    expect(result.mismatches).toHaveLength(0);\n    expect(result.totalChecked).toBe(0);\n  });\n\n  it('should return valid when all components match', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'Arduino Uno' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Arduino Uno',\n      sourceInventoryId: '1',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(true);\n    expect(result.syncedCount).toBe(1);\n  });\n\n  it('should detect name mismatch', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'Arduino Uno R3' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Arduino Uno',\n      sourceInventoryId: '1',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(false);\n    expect(result.mismatches).toHaveLength(1);\n    expect(result.mismatches[0].field).toBe('name');\n    expect(result.mismatches[0].expected).toBe('Arduino Uno R3');\n    expect(result.mismatches[0].actual).toBe('Arduino Uno');\n  });\n\n  it('should detect type mismatch', () => {\n    const inventoryItem = createComponent({ id: '1', type: 'microcontroller' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      type: 'sensor',\n      sourceInventoryId: '1',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(false);\n    expect(result.mismatches.some(m => m.field === 'type')).toBe(true);\n  });\n\n  it('should detect pin mismatch', () => {\n    const inventoryItem = createComponent({ id: '1', pins: ['VCC', 'GND', 'D0', 'D1'] });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      pins: ['VCC', 'GND'],\n      sourceInventoryId: '1',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(false);\n    expect(result.mismatches.some(m => m.field === 'pins')).toBe(true);\n  });\n\n  it('should detect orphaned component (source deleted)', () => {\n    const diagramItem = createComponent({\n      id: '1-123456',\n      sourceInventoryId: 'deleted-id',\n    });\n\n    const diagram = createDiagram([diagramItem]);\n    const inventory: ElectronicComponent[] = [];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    expect(result.isValid).toBe(false);\n    expect(result.orphanedCount).toBe(1);\n    expect(result.mismatches[0].field).toBe('missing');\n  });\n\n  it('should handle legacy components without sourceInventoryId', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'Arduino' });\n    const legacyDiagramItem = createComponent({\n      id: '1-123456',\n      name: 'Arduino',\n      // No sourceInventoryId - legacy component\n    });\n\n    const diagram = createDiagram([legacyDiagramItem]);\n    const inventory = [inventoryItem];\n\n    const result = validateDiagramInventoryConsistency(diagram, inventory);\n\n    // Should find match by ID prefix\n    expect(result.isValid).toBe(true);\n    expect(result.syncedCount).toBe(1);\n  });\n});\n\n// ============================================\n// analyzeUsage Tests\n// ============================================\n\ndescribe('analyzeUsage', () => {\n  it('should return empty usage for unused component', () => {\n    const diagram = createDiagram();\n\n    const usage = analyzeUsage('unused-id', diagram);\n\n    expect(usage.inDiagramCount).toBe(0);\n    expect(usage.hasActiveConnections).toBe(false);\n    expect(usage.connectionCount).toBe(0);\n  });\n\n  it('should detect component in diagram without connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp]);\n\n    const usage = analyzeUsage('1', diagram);\n\n    expect(usage.inDiagramCount).toBe(1);\n    expect(usage.hasActiveConnections).toBe(false);\n    expect(usage.connectionCount).toBe(0);\n  });\n\n  it('should detect component with active connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp], [\n      { fromComponentId: '1-123456', fromPin: 'VCC', toComponentId: 'other', toPin: 'IN', description: 'test' },\n    ]);\n\n    const usage = analyzeUsage('1', diagram);\n\n    expect(usage.hasActiveConnections).toBe(true);\n    expect(usage.connectionCount).toBe(1);\n  });\n\n  it('should count multiple connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp], [\n      { fromComponentId: '1-123456', fromPin: 'VCC', toComponentId: 'other', toPin: 'IN', description: 'test1' },\n      { fromComponentId: 'other', fromPin: 'OUT', toComponentId: '1-123456', toPin: 'DATA', description: 'test2' },\n    ]);\n\n    const usage = analyzeUsage('1', diagram);\n\n    expect(usage.connectionCount).toBe(2);\n  });\n});\n\n// ============================================\n// determineOrphanAction Tests\n// ============================================\n\ndescribe('determineOrphanAction', () => {\n  it('should return cascade for unused component', () => {\n    const diagram = createDiagram();\n\n    const { action, reason } = determineOrphanAction('unused', diagram);\n\n    expect(action).toBe('cascade');\n    expect(reason).toContain('not used');\n  });\n\n  it('should return block for component with active connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp], [\n      { fromComponentId: '1-123456', fromPin: 'VCC', toComponentId: 'other', toPin: 'IN', description: 'test' },\n    ]);\n\n    const { action, reason } = determineOrphanAction('1', diagram);\n\n    expect(action).toBe('block');\n    expect(reason).toContain('Cannot delete');\n    expect(reason).toContain('wire');\n  });\n\n  it('should return cascade for component in diagram without connections', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp]);\n\n    const { action } = determineOrphanAction('1', diagram);\n\n    // No saved diagrams passed, so it's treated as draft only\n    expect(action).toBe('cascade');\n  });\n});\n\n// ============================================\n// syncComponentWithInventory Tests\n// ============================================\n\ndescribe('syncComponentWithInventory', () => {\n  it('should update component with inventory data', () => {\n    const inventoryItem = createComponent({\n      id: '1',\n      name: 'Updated Name',\n      type: 'microcontroller',\n      pins: ['A', 'B', 'C'],\n    });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Old Name',\n      type: 'sensor',\n      pins: ['X', 'Y'],\n      sourceInventoryId: '1',\n    });\n\n    const synced = syncComponentWithInventory(diagramItem, [inventoryItem]);\n\n    expect(synced.id).toBe('1-123456'); // ID preserved\n    expect(synced.name).toBe('Updated Name');\n    expect(synced.type).toBe('microcontroller');\n    expect(synced.pins).toEqual(['A', 'B', 'C']);\n    expect(synced.sourceInventoryId).toBe('1');\n  });\n\n  it('should return original if no source found', () => {\n    const diagramItem = createComponent({\n      id: '1-123456',\n      sourceInventoryId: 'missing',\n    });\n\n    const synced = syncComponentWithInventory(diagramItem, []);\n\n    expect(synced).toEqual(diagramItem);\n  });\n});\n\n// ============================================\n// syncDiagramWithInventory Tests\n// ============================================\n\ndescribe('syncDiagramWithInventory', () => {\n  it('should sync all components and count changes', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'New Name' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Old Name',\n      sourceInventoryId: '1',\n    });\n    const diagram = createDiagram([diagramItem]);\n\n    const { diagram: synced, changeCount } = syncDiagramWithInventory(diagram, [inventoryItem]);\n\n    expect(changeCount).toBe(1);\n    expect(synced.components[0].name).toBe('New Name');\n  });\n\n  it('should return 0 changes when already in sync', () => {\n    const inventoryItem = createComponent({ id: '1', name: 'Same Name' });\n    const diagramItem = createComponent({\n      id: '1-123456',\n      name: 'Same Name',\n      sourceInventoryId: '1',\n      type: inventoryItem.type,\n      description: inventoryItem.description,\n      pins: inventoryItem.pins,\n    });\n    const diagram = createDiagram([diagramItem]);\n\n    const { changeCount } = syncDiagramWithInventory(diagram, [inventoryItem]);\n\n    expect(changeCount).toBe(0);\n  });\n});\n\n// ============================================\n// removeOrphanedComponents Tests\n// ============================================\n\ndescribe('removeOrphanedComponents', () => {\n  it('should remove components with deleted inventory source', () => {\n    const orphanedComp = createComponent({\n      id: '1-123456',\n      sourceInventoryId: 'deleted',\n    });\n    const validComp = createComponent({\n      id: '2-123456',\n      sourceInventoryId: '2',\n    });\n    const diagram = createDiagram([orphanedComp, validComp]);\n    const inventory = [createComponent({ id: '2' })];\n\n    const { diagram: cleaned, removedIds } = removeOrphanedComponents(diagram, inventory);\n\n    expect(cleaned.components).toHaveLength(1);\n    expect(cleaned.components[0].id).toBe('2-123456');\n    expect(removedIds).toContain('1-123456');\n  });\n\n  it('should also remove connections to orphaned components', () => {\n    const orphanedComp = createComponent({ id: '1-123456', sourceInventoryId: 'deleted' });\n    const validComp = createComponent({ id: '2-123456', sourceInventoryId: '2' });\n    const diagram = createDiagram(\n      [orphanedComp, validComp],\n      [\n        { fromComponentId: '1-123456', fromPin: 'OUT', toComponentId: '2-123456', toPin: 'IN', description: '' },\n        { fromComponentId: '2-123456', fromPin: 'OUT', toComponentId: '3', toPin: 'IN', description: '' },\n      ]\n    );\n    const inventory = [createComponent({ id: '2' })];\n\n    const { diagram: cleaned } = removeOrphanedComponents(diagram, inventory);\n\n    // Connection to orphaned component should be removed\n    expect(cleaned.connections).toHaveLength(1);\n    expect(cleaned.connections[0].fromComponentId).toBe('2-123456');\n  });\n\n  it('should return empty removedIds when nothing to remove', () => {\n    const comp = createComponent({ id: '1-123456', sourceInventoryId: '1' });\n    const diagram = createDiagram([comp]);\n    const inventory = [createComponent({ id: '1' })];\n\n    const { removedIds } = removeOrphanedComponents(diagram, inventory);\n\n    expect(removedIds).toHaveLength(0);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/fzpzLoader.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'JSZip' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'str' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":17,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\nimport { FzpzLoader } from '../fzpzLoader';\nimport JSZip from 'jszip';\n\n// Mock DOMParser for Node environment\nclass MockDOMParser {\n  parseFromString(str: string) {\n    return {\n      querySelector: () => ({\n        getAttribute: (name: string) => {\n          if (name === 'width') return '1in';\n          if (name === 'height') return '1in';\n          if (name === 'viewBox') return '0 0 1000 1000';\n          return null;\n        }\n      }),\n      getElementById: (id: string) => ({\n        tagName: 'circle',\n        getAttribute: (name: string) => {\n          if (name === 'cx') return '500';\n          if (name === 'cy') return '500';\n          return null;\n        }\n      })\n    };\n  }\n}\n\nvi.stubGlobal('DOMParser', MockDOMParser);\n\ndescribe('FzpzLoader', () => {\n  it('should parse unit \"in\" correctly', async () => {\n    // This is hard to test without a real zip, but we can test the private extractFootprint logic\n    // if we make it public or test through the main load method with a mocked zip.\n    \n    // For now, let's verify the logic we improved in Task 2.1\n    // 1in should be 10 units\n    const loader = FzpzLoader as any;\n    const footprint = loader.extractFootprint({\n        module: {\n            connectors: {\n                connector: {\n                    _attributes: { id: 'connector0' },\n                    views: { breadboardView: { p: { _attributes: { svgId: 'pin0' } } } }\n                }\n            }\n        }\n    }, '<svg width=\"1in\" height=\"1in\" viewBox=\"0 0 1000 1000\"><circle id=\"pin0\" cx=\"500\" cy=\"500\" r=\"10\"/></svg>');\n\n    expect(footprint.width).toBe(10);\n    expect(footprint.pins[0].x).toBe(5); // (500 / 1000) * 10\n  });\n\n  it('should parse unit \"mm\" correctly', () => {\n    const loader = FzpzLoader as any;\n    const footprint = loader.extractFootprint({\n        module: { connectors: { connector: [] } }\n    }, '<svg width=\"25.4mm\" height=\"25.4mm\" viewBox=\"0 0 100 100\"></svg>');\n\n    expect(footprint.width).toBeCloseTo(10, 1);\n  });\n\n  it('should parse unit \"mil\" correctly', () => {\n    const loader = FzpzLoader as any;\n    const footprint = loader.extractFootprint({\n        module: { connectors: { connector: [] } }\n    }, '<svg width=\"1000mil\" height=\"1000mil\" viewBox=\"0 0 100 100\"></svg>');\n\n    expect(footprint.width).toBe(10);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/geminiService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/securityAuditor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/storageSanitization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/__tests__/userProfileService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/aiContextBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/aiMetricsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/analytics/projectAnalyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/api/apiDispatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/api/apiGateway.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/api/events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/api/tokenService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/apiKeyStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/authService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/bomService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/circuitAnalysisService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/collabService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/componentValidator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":483,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":483,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13196,13199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13196,13199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Component Validator Service\n * Ensures 100% consistency between inventory and diagram canvas\n *\n * Key principle: Inventory is the SINGLE SOURCE OF TRUTH\n * Diagram components must always match their inventory source\n */\n\nimport type { ElectronicComponent, WiringDiagram, WireConnection } from '../types';\n\n// ============================================\n// Types\n// ============================================\n\nexport interface ComponentMismatch {\n  diagramComponentId: string;\n  diagramComponentName: string;\n  inventoryId: string | undefined;\n  field: 'name' | 'type' | 'pins' | 'description' | 'missing' | 'orphaned';\n  expected: unknown;\n  actual: unknown;\n  severity: 'error' | 'warning';\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  mismatches: ComponentMismatch[];\n  orphanedCount: number;\n  syncedCount: number;\n  totalChecked: number;\n}\n\nexport interface ComponentUsage {\n  inventoryId: string;\n  inDiagramCount: number;\n  hasActiveConnections: boolean;\n  connectionCount: number;\n  inSavedDiagrams: boolean;\n  onlyInDrafts: boolean;\n  diagramIds: string[];\n}\n\nexport type OrphanAction = 'block' | 'warn' | 'cascade';\n\n// ============================================\n// Main Validation Functions\n// ============================================\n\n/**\n * Validate all diagram components against inventory\n * Returns detailed mismatches for debugging/fixing\n */\nexport function validateDiagramInventoryConsistency(\n  diagram: WiringDiagram,\n  inventory: ElectronicComponent[]\n): ValidationResult {\n  const mismatches: ComponentMismatch[] = [];\n  let orphanedCount = 0;\n  let syncedCount = 0;\n\n  const inventoryMap = new Map(inventory.map(i => [i.id, i]));\n\n  for (const comp of diagram.components) {\n    // Check if component has a source reference\n    if (!comp.sourceInventoryId) {\n      // Legacy component without reference - try to find by ID prefix\n      const baseId = comp.id.split('-')[0];\n      const source = inventoryMap.get(baseId);\n\n      if (!source) {\n        mismatches.push({\n          diagramComponentId: comp.id,\n          diagramComponentName: comp.name,\n          inventoryId: undefined,\n          field: 'orphaned',\n          expected: 'Component should have inventory source',\n          actual: 'No sourceInventoryId and no matching inventory item',\n          severity: 'warning',\n        });\n        orphanedCount++;\n        continue;\n      }\n      // Found by ID prefix - check consistency\n      const sourceMismatches = compareComponent(comp, source);\n      mismatches.push(...sourceMismatches);\n      if (sourceMismatches.length === 0) syncedCount++;\n      continue;\n    }\n\n    // Has sourceInventoryId - look it up\n    const source = inventoryMap.get(comp.sourceInventoryId);\n\n    if (!source) {\n      // Source was deleted from inventory\n      mismatches.push({\n        diagramComponentId: comp.id,\n        diagramComponentName: comp.name,\n        inventoryId: comp.sourceInventoryId,\n        field: 'missing',\n        expected: `Inventory item ${comp.sourceInventoryId}`,\n        actual: 'Inventory item no longer exists',\n        severity: 'error',\n      });\n      orphanedCount++;\n      continue;\n    }\n\n    // Compare all fields\n    const sourceMismatches = compareComponent(comp, source);\n    mismatches.push(...sourceMismatches);\n    if (sourceMismatches.length === 0) syncedCount++;\n  }\n\n  return {\n    isValid: mismatches.length === 0,\n    mismatches,\n    orphanedCount,\n    syncedCount,\n    totalChecked: diagram.components.length,\n  };\n}\n\n/**\n * Compare a diagram component against its inventory source\n */\nfunction compareComponent(\n  diagramComp: ElectronicComponent,\n  inventoryComp: ElectronicComponent\n): ComponentMismatch[] {\n  const mismatches: ComponentMismatch[] = [];\n  const inventoryId = diagramComp.sourceInventoryId || inventoryComp.id;\n\n  // Check name\n  if (diagramComp.name !== inventoryComp.name) {\n    mismatches.push({\n      diagramComponentId: diagramComp.id,\n      diagramComponentName: diagramComp.name,\n      inventoryId,\n      field: 'name',\n      expected: inventoryComp.name,\n      actual: diagramComp.name,\n      severity: 'error',\n    });\n  }\n\n  // Check type\n  if (diagramComp.type !== inventoryComp.type) {\n    mismatches.push({\n      diagramComponentId: diagramComp.id,\n      diagramComponentName: diagramComp.name,\n      inventoryId,\n      field: 'type',\n      expected: inventoryComp.type,\n      actual: diagramComp.type,\n      severity: 'error',\n    });\n  }\n\n  // Check pins (order-independent comparison)\n  const diagramPins = new Set(diagramComp.pins || []);\n  const inventoryPins = new Set(inventoryComp.pins || []);\n\n  if (!areSetsEqual(diagramPins, inventoryPins)) {\n    mismatches.push({\n      diagramComponentId: diagramComp.id,\n      diagramComponentName: diagramComp.name,\n      inventoryId,\n      field: 'pins',\n      expected: Array.from(inventoryPins),\n      actual: Array.from(diagramPins),\n      severity: 'error',\n    });\n  }\n\n  return mismatches;\n}\n\n/**\n * Check if two sets are equal\n */\nfunction areSetsEqual<T>(a: Set<T>, b: Set<T>): boolean {\n  if (a.size !== b.size) return false;\n  for (const item of a) {\n    if (!b.has(item)) return false;\n  }\n  return true;\n}\n\n// ============================================\n// Usage Analysis (for deletion rules)\n// ============================================\n\n/**\n * Analyze how an inventory item is used across all diagrams\n */\nexport function analyzeUsage(\n  inventoryId: string,\n  currentDiagram: WiringDiagram,\n  savedDiagrams: WiringDiagram[] = []\n): ComponentUsage {\n  const allDiagrams = [currentDiagram, ...savedDiagrams];\n  const diagramIds: string[] = [];\n  let totalConnections = 0;\n  let hasActiveConnections = false;\n  let inSavedDiagrams = false;\n\n  for (let i = 0; i < allDiagrams.length; i++) {\n    const diagram = allDiagrams[i];\n    const isSaved = i > 0; // First is current, rest are saved\n\n    // Find instances of this inventory item in the diagram\n    const instances = diagram.components.filter(c =>\n      c.sourceInventoryId === inventoryId ||\n      c.id === inventoryId ||\n      c.id.startsWith(`${inventoryId}-`)\n    );\n\n    if (instances.length > 0) {\n      diagramIds.push(diagram.title || `Diagram ${i}`);\n      if (isSaved) inSavedDiagrams = true;\n\n      // Check for connections to these instances\n      for (const instance of instances) {\n        const connections = countConnectionsToComponent(instance.id, diagram.connections);\n        totalConnections += connections;\n        if (connections > 0) hasActiveConnections = true;\n      }\n    }\n  }\n\n  return {\n    inventoryId,\n    inDiagramCount: diagramIds.length,\n    hasActiveConnections,\n    connectionCount: totalConnections,\n    inSavedDiagrams,\n    onlyInDrafts: diagramIds.length > 0 && !inSavedDiagrams,\n    diagramIds,\n  };\n}\n\n/**\n * Count connections to a specific component\n */\nfunction countConnectionsToComponent(\n  componentId: string,\n  connections: WireConnection[]\n): number {\n  return connections.filter(\n    c => c.fromComponentId === componentId || c.toComponentId === componentId\n  ).length;\n}\n\n// ============================================\n// Smart Orphan Handling\n// ============================================\n\n/**\n * Determine what action to take when deleting an inventory item\n * Based on context-aware rules\n */\nexport function determineOrphanAction(\n  inventoryId: string,\n  currentDiagram: WiringDiagram,\n  savedDiagrams: WiringDiagram[] = []\n): { action: OrphanAction; reason: string; usage: ComponentUsage } {\n  const usage = analyzeUsage(inventoryId, currentDiagram, savedDiagrams);\n\n  // BLOCK: Component has active wired connections\n  if (usage.hasActiveConnections) {\n    return {\n      action: 'block',\n      reason: `Cannot delete: component is used in ${usage.connectionCount} wire connection(s). Remove wires first.`,\n      usage,\n    };\n  }\n\n  // WARN: Component exists in SAVED diagrams\n  if (usage.inSavedDiagrams) {\n    return {\n      action: 'warn',\n      reason: `Component is used in ${usage.inDiagramCount} saved diagram(s): ${usage.diagramIds.join(', ')}. Remove from all?`,\n      usage,\n    };\n  }\n\n  // CASCADE: Component only in current/draft diagram with no connections\n  if (usage.onlyInDrafts) {\n    return {\n      action: 'cascade',\n      reason: `Component will be removed from current diagram (no saved references).`,\n      usage,\n    };\n  }\n\n  // Not used anywhere - safe to delete\n  return {\n    action: 'cascade',\n    reason: 'Component is not used in any diagrams.',\n    usage,\n  };\n}\n\n// ============================================\n// Sync Helpers\n// ============================================\n\n/**\n * Migration mapping for legacy component IDs\n */\nconst LEGACY_ID_MAP: Record<string, string> = {\n  'mcu': 'mcu-arduino-uno-r3',\n  'mcu1': 'mcu-arduino-uno-r3',\n  'pot': 'other-potentiometer',\n  'pot1': 'other-potentiometer',\n  'servo': 'actuator-servo',\n  'servo1': 'actuator-servo',\n  'sensor': 'sensor-hcsr04',\n  'hcsr04': 'sensor-hcsr04',\n  'dht11': 'sensor-dht11',\n  'lcd': 'display-lcd1602',\n};\n\n/**\n * Repairs a legacy diagram by mapping old IDs to new semantic inventory IDs\n */\nexport function migrateLegacyDiagram(\n  diagram: WiringDiagram,\n  inventory: ElectronicComponent[]\n): { diagram: WiringDiagram; repairedCount: number } {\n  let repairedCount = 0;\n  const inventoryIds = new Set(inventory.map(i => i.id));\n\n  const migratedComponents = diagram.components.map(comp => {\n    // Already has a valid reference?\n    if (comp.sourceInventoryId && inventoryIds.has(comp.sourceInventoryId)) {\n      return comp;\n    }\n\n    // Try to find mapping for legacy ID or prefix\n    const baseId = comp.sourceInventoryId || comp.id.split('-')[0];\n    const newSourceId = LEGACY_ID_MAP[baseId] || LEGACY_ID_MAP[comp.name.toLowerCase()] || undefined;\n\n    if (newSourceId && inventoryIds.has(newSourceId)) {\n      repairedCount++;\n      return {\n        ...comp,\n        sourceInventoryId: newSourceId\n      };\n    }\n\n    // Fallback: try finding by name exact match\n    const byName = inventory.find(i => i.name === comp.name);\n    if (byName) {\n      repairedCount++;\n      return {\n        ...comp,\n        sourceInventoryId: byName.id\n      };\n    }\n\n    return comp;\n  });\n\n  return {\n    diagram: {\n      ...diagram,\n      components: migratedComponents\n    },\n    repairedCount\n  };\n}\n\n/**\n * Sync a diagram component with its inventory source\n * Returns the updated component (or original if no source found)\n */\nexport function syncComponentWithInventory(\n  diagramComp: ElectronicComponent,\n  inventory: ElectronicComponent[]\n): ElectronicComponent {\n  const inventoryMap = new Map(inventory.map(i => [i.id, i]));\n\n  // Find source\n  const sourceId = diagramComp.sourceInventoryId || diagramComp.id.split('-')[0];\n  const source = inventoryMap.get(sourceId);\n\n  if (!source) {\n    // No source found - return as-is\n    return diagramComp;\n  }\n\n  // Sync fields from inventory (preserve diagram instance id)\n  return {\n    ...diagramComp,\n    sourceInventoryId: source.id,\n    name: source.name,\n    type: source.type,\n    description: source.description,\n    pins: source.pins ? [...source.pins] : undefined,\n    datasheetUrl: source.datasheetUrl,\n    imageUrl: source.imageUrl,\n  };\n}\n\n/**\n * Sync all diagram components with inventory\n * Returns new diagram with synced components\n */\nexport function syncDiagramWithInventory(\n  diagram: WiringDiagram,\n  inventory: ElectronicComponent[]\n): { diagram: WiringDiagram; changeCount: number } {\n  let changeCount = 0;\n\n  const syncedComponents = diagram.components.map(comp => {\n    const synced = syncComponentWithInventory(comp, inventory);\n\n    // Check if anything changed\n    if (JSON.stringify(comp) !== JSON.stringify(synced)) {\n      changeCount++;\n    }\n\n    return synced;\n  });\n\n  return {\n    diagram: {\n      ...diagram,\n      components: syncedComponents,\n    },\n    changeCount,\n  };\n}\n\n/**\n * Remove orphaned components from diagram\n * (components whose inventory source no longer exists)\n */\nexport function removeOrphanedComponents(\n  diagram: WiringDiagram,\n  inventory: ElectronicComponent[]\n): { diagram: WiringDiagram; removedIds: string[] } {\n  const inventoryIds = new Set(inventory.map(i => i.id));\n  const removedIds: string[] = [];\n\n  const filteredComponents = diagram.components.filter(comp => {\n    const sourceId = comp.sourceInventoryId || comp.id.split('-')[0];\n    const exists = inventoryIds.has(sourceId);\n\n    if (!exists) {\n      removedIds.push(comp.id);\n    }\n\n    return exists;\n  });\n\n  // Also remove connections to removed components\n  const removedIdSet = new Set(removedIds);\n  const filteredConnections = diagram.connections.filter(\n    c => !removedIdSet.has(c.fromComponentId) && !removedIdSet.has(c.toComponentId)\n  );\n\n  return {\n    diagram: {\n      ...diagram,\n      components: filteredComponents,\n      connections: filteredConnections,\n    },\n    removedIds,\n  };\n}\n\n// ============================================\n// Debug/Dev Utilities\n// ============================================\n\n/**\n * Validates a 3D model's dimensions against expected standards.\n * Returns a score from 0-1 and any specific deviations.\n */\nexport function verifyModelDimensions(\n  model: any, // Three.js Object3D (as JSON or instance)\n  expected: { width: number, length: number, height: number }\n): { score: number; deviations: string[] } {\n  const deviations: string[] = [];\n  \n  // Calculate bounding box from JSON data if necessary\n  // For simplicity here, we assume we are checking the dimensions already extracted\n  // In reality, ThreeViewer will call this after loading.\n  \n  const widthDiff = Math.abs(model.width - expected.width);\n  const lengthDiff = Math.abs(model.length - expected.length);\n  const heightDiff = Math.abs(model.height - expected.height);\n\n  if (widthDiff > expected.width * 0.1) deviations.push(`Width mismatch: ${model.width}mm vs ${expected.width}mm`);\n  if (lengthDiff > expected.length * 0.1) deviations.push(`Length mismatch: ${model.length}mm vs ${expected.length}mm`);\n  if (heightDiff > expected.height * 0.2) deviations.push(`Height mismatch: ${model.height}mm vs ${expected.height}mm`);\n\n  const score = Math.max(0, 1 - (deviations.length * 0.3));\n  return { score, deviations };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/config/configManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[993,996],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[993,996],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import yaml from 'js-yaml';\n\nexport interface WorkspaceConfig {\n  version: string;\n  metadata: {\n    name: string;\n    environment: 'home' | 'work' | 'lab';\n  };\n  ui: Record<string, unknown>;\n  ai: Record<string, unknown>;\n  standards: Record<string, unknown>;\n}\n\nclass ConfigManager {\n  /**\n   * Serializes current app state to YAML string.\n   */\n  serialize(data: unknown): string {\n    const scrubbed = this.scrubSecrets(data);\n    return yaml.dump(scrubbed);\n  }\n\n  /**\n   * Parses and validates a configuration string.\n   */\n  deserialize(content: string): WorkspaceConfig | null {\n    try {\n      const parsed = yaml.load(content) as unknown;\n      if (this.validate(parsed)) return parsed;\n      return null;\n    } catch (e) {\n      console.error('Failed to parse config', e);\n      return null;\n    }\n  }\n\n  private scrubSecrets(data: unknown): unknown {\n    if (!data || typeof data !== 'object') return data;\n    \n    const copy = JSON.parse(JSON.stringify(data)) as Record<string, any>;\n    // Implementation to remove API keys, PINs etc.\n    if (copy.ai && typeof copy.ai === 'object' && copy.ai.apiKey) {\n      copy.ai.apiKey = '********';\n    }\n    return copy;\n  }\n\n  private validate(config: unknown): config is WorkspaceConfig {\n    if (!config || typeof config !== 'object') return false;\n    const c = config as Record<string, unknown>;\n    return typeof c.version === 'string';\n  }\n}\n\nexport const configManager = new ConfigManager();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/connectivityService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'response' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":35,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"type ConnectivityListener = (isOnline: boolean) => void;\n\nclass ConnectivityService {\n  private listeners: Set<ConnectivityListener> = new Set();\n  private isOnline: boolean = navigator.onLine;\n\n  constructor() {\n    window.addEventListener('online', () => this.handleStatusChange(true));\n    window.addEventListener('offline', () => this.handleStatusChange(false));\n  }\n\n  private handleStatusChange(status: boolean) {\n    this.isOnline = status;\n    this.listeners.forEach(l => l(status));\n  }\n\n  onStatusChange(listener: ConnectivityListener) {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  getIsOnline(): boolean {\n    return this.isOnline;\n  }\n\n  /**\n   * Performs an actual network request to verify if the Gemini API is reachable.\n   * Useful when ICMP (ping) is blocked by firewalls but HTTPS is allowed.\n   */\n  async checkApiReachability(): Promise<boolean> {\n    try {\n      // Use a HEAD request to minimize data usage\n      const response = await fetch('https://generativelanguage.googleapis.com/', {\n        method: 'HEAD',\n        mode: 'no-cors' // We just need to know if the server is there\n      });\n      return true; // If we get here, the server responded (even if it's a 404/403)\n    } catch (e) {\n      console.warn('API Reachability check failed:', e);\n      return false;\n    }\n  }\n}\n\nexport const connectivityService = new ConnectivityService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/datasetService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/datasheetProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[959,962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[959,962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nexport interface ScrapedPin {\n  number: number;\n  name: string;\n  function: string;\n}\n\nexport interface ScrapedSpecs {\n  voltageMin: number;\n  voltageMax: number;\n  currentLimit?: number;\n  logicLevel: '3.3V' | '5V' | 'Adjustable' | 'Other';\n}\n\nexport interface ScrapedMetadata {\n  pins: ScrapedPin[];\n  specs: ScrapedSpecs;\n  confidence: number;\n}\n\nclass DatasheetProcessor {\n  /**\n   * Converts a File to base64 string for API consumption.\n   */\n  async fileToBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => {\n        const base64 = reader.result as string;\n        // Remove the data:application/pdf;base64, prefix\n        resolve(base64.split(',')[1]);\n      };\n      reader.onerror = (error) => reject(error);\n    });\n  }\n\n  /**\n   * Utility to validate the structure of scraped data.\n   */\n  validateMetadata(data: any): data is ScrapedMetadata {\n    return (\n      data &&\n      Array.isArray(data.pins) &&\n      typeof data.specs === 'object' &&\n      typeof data.confidence === 'number'\n    );\n  }\n}\n\nexport const datasheetProcessor = new DatasheetProcessor();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/diagramDiff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/error/diagnosticsHub.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/feedback/correctionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/fzpzLoader.ts","messages":[{"ruleId":"prefer-const","severity":1,"message":"'clean' is never reassigned. Use 'const' instead.","line":78,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":78,"endColumn":16,"fix":{"range":[2340,2514],"text":"const clean = content\n        .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n        .replace(/on\\w+=\"[^\"]*\"/g, '')\n        .replace(/on\\w+='[^']*'/g, '');"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5290,5293],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5290,5293],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"no-undef","severity":2,"message":"'DOMParser' is not defined.","line":118,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"\nimport JSZip from 'jszip';\nimport { xml2js, ElementCompact } from 'xml-js';\nimport { ElectronicComponent, ComponentFootprint } from '../types';\n\nexport interface FritzingPart {\n  moduleId: string;\n  fzp: ElementCompact;\n  svgs: {\n    breadboard?: string;\n    schematic?: string;\n    pcb?: string;\n    icon?: string;\n  };\n  component: Partial<ElectronicComponent>;\n}\n\nexport class FzpzLoader {\n  \n  static async load(file: File | ArrayBuffer): Promise<FritzingPart> {\n    const zip = new JSZip();\n    const contents = await zip.loadAsync(file);\n    \n    let fzpFile = '';\n    let fzpContent = '';\n    \n    // Find .fzp file\n    for (const filename of Object.keys(contents.files)) {\n      if (filename.endsWith('.fzp')) {\n        fzpFile = filename;\n        fzpContent = await contents.files[filename].async('text');\n        break;\n      }\n    }\n    \n    if (!fzpFile) {\n      throw new Error('Invalid FZPZ: No .fzp metadata found');\n    }\n    \n    // Parse FZP XML\n    const fzp = xml2js(fzpContent, { compact: true }) as ElementCompact;\n    const module = fzp.module;\n    const moduleId = module._attributes.moduleId;\n    \n    const svgs: FritzingPart['svgs'] = {};\n    \n    // Extract SVG layers\n    const views = module.views;\n    if (views.breadboardView?.layers?._attributes?.image) {\n      svgs.breadboard = await this.extractSvg(zip, views.breadboardView.layers._attributes.image);\n    }\n    if (views.schematicView?.layers?._attributes?.image) {\n      svgs.schematic = await this.extractSvg(zip, views.schematicView.layers._attributes.image);\n    }\n    \n    // Build Component Data\n    const component: Partial<ElectronicComponent> = {\n      name: module.title?._text || 'Unknown Part',\n      description: module.label?._text || '',\n      type: 'other', // Default, needs heuristic\n      fzpzSource: file instanceof File ? await file.arrayBuffer() : file,\n      footprint: this.extractFootprint(module, svgs.breadboard)\n    };\n    \n    return {\n      moduleId,\n      fzp: module,\n      svgs: this.sanitizeSvgs(svgs),\n      component\n    };\n  }\n\n  private static sanitizeSvgs(svgs: FritzingPart['svgs']): FritzingPart['svgs'] {\n    const sanitized: FritzingPart['svgs'] = {};\n    for (const [view, content] of Object.entries(svgs)) {\n      if (!content) continue;\n      // Basic sanitization: remove scripts and event handlers\n      let clean = content\n        .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n        .replace(/on\\w+=\"[^\"]*\"/g, '')\n        .replace(/on\\w+='[^']*'/g, '');\n      \n      sanitized[view as keyof FritzingPart['svgs']] = clean;\n    }\n    return sanitized;\n  }\n  \n  private static async extractSvg(zip: JSZip, path: string): Promise<string> {\n    // Fritzing paths are often relative like 'breadboard/foo.svg'\n    // But zip might be flat or nested.\n    // Standard .fzpz is flat with 'svg.breadboard.foo.svg' naming\n    \n    // Try exact path\n    if (zip.file(path)) {\n        return await zip.file(path)!.async('text');\n    }\n    \n    // Try flattening path (standard fzpz structure)\n    // image='breadboard/part.svg' -> 'svg.breadboard.part.svg'\n    const parts = path.split('/');\n    \n    // Search for fuzzy match\n    const matchingFile = Object.keys(zip.files).find(f => f.endsWith(parts[parts.length - 1]));\n    if (matchingFile) {\n        return await zip.file(matchingFile)!.async('text');\n    }\n    \n    return '';\n  }\n  \n  private static extractFootprint(fzp: ElementCompact, breadboardSvg?: string): ComponentFootprint | undefined {\n    if (!breadboardSvg) return undefined;\n    \n    // Parse SVG dimensions\n    let width = 10;\n    let height = 10;\n    \n    const parser = new DOMParser(); // eslint-disable-line no-undef\n    const doc = parser.parseFromString(breadboardSvg, 'image/svg+xml');\n    const svgEl = doc.querySelector('svg');\n    \n    if (svgEl) {\n      const wAttr = svgEl.getAttribute('width');\n      const hAttr = svgEl.getAttribute('height');\n      const viewBox = svgEl.getAttribute('viewBox');\n      \n      const parseUnit = (val: string | null): number => {\n          if (!val) return 0;\n          const num = parseFloat(val);\n          if (val.endsWith('in')) return num * 10; // 1in = 10 units (0.1\" grid)\n          if (val.endsWith('mm')) return (num / 25.4) * 10; // 25.4mm = 1in = 10 units\n          if (val.endsWith('mil')) return num / 10; // 1000mil = 1in = 10 units -> 100mil = 1 unit\n          if (val.endsWith('px')) return (num / 96) * 10; // Assume 96dpi\n          return num; // Unknown, assume 1/1000 inch (mil) if large, or inches if small\n      };\n      \n      width = parseUnit(wAttr);\n      height = parseUnit(hAttr);\n\n      // Fallback to viewBox if width/height missing\n      if (!width || !height) {\n          if (viewBox) {\n              const [, , w, h] = viewBox.split(/\\s+/).map(parseFloat);\n              // If large numbers, assume mil\n              width = w > 50 ? w / 10 : w;\n              height = h > 50 ? h / 10 : h;\n          } else {\n              width = 10;\n              height = 10;\n          }\n      }\n    }\n    \n    const pins: ComponentFootprint['pins'] = [];\n    \n    // Map connectors\n    const connectors = fzp.module.connectors.connector;\n    const connectorArray = Array.isArray(connectors) ? connectors : [connectors];\n    \n    connectorArray.forEach((c: any) => {\n        const id = c._attributes.id;\n        const breadboardLayer = c.views?.breadboardView?.p;\n        const svgId = breadboardLayer?._attributes?.svgId;\n        \n        if (svgId && doc) {\n            const el = doc.getElementById(svgId);\n            if (el) {\n                let x = 0, y = 0;\n                if (el.tagName === 'circle') {\n                    x = parseFloat(el.getAttribute('cx') || '0');\n                    y = parseFloat(el.getAttribute('cy') || '0');\n                } else if (el.tagName === 'rect') {\n                    x = parseFloat(el.getAttribute('x') || '0') + parseFloat(el.getAttribute('width') || '0') / 2;\n                    y = parseFloat(el.getAttribute('y') || '0') + parseFloat(el.getAttribute('height') || '0') / 2;\n                } else {\n                    // Try to find a child circle or rect or use bounding box centroid\n                    const child = el.querySelector('circle, rect');\n                    if (child) {\n                         if (child.tagName === 'circle') {\n                            x = parseFloat(child.getAttribute('cx') || '0');\n                            y = parseFloat(child.getAttribute('cy') || '0');\n                        } else {\n                            x = parseFloat(child.getAttribute('x') || '0') + parseFloat(child.getAttribute('width') || '0') / 2;\n                            y = parseFloat(child.getAttribute('y') || '0') + parseFloat(child.getAttribute('height') || '0') / 2;\n                        }\n                    }\n                }\n                \n                // Normalize coordinates\n                const viewBox = svgEl?.getAttribute('viewBox')?.split(/\\s+/) || ['0', '0', '100', '100'];\n                const vbW = parseFloat(viewBox[2]);\n                const vbH = parseFloat(viewBox[3]);\n                \n                const scaleX = width / vbW;\n                const scaleY = height / vbH;\n                \n                pins.push({\n                    id,\n                    x: x * scaleX,\n                    y: y * scaleY,\n                    svgElementId: svgId\n                });\n            }\n        }\n    });\n    \n    return {\n      width,\n      height,\n      pins\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/bom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/chat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/components.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7715,7718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7715,7718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":297,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":297,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":305,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10939,10942],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10939,10942],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13595,13598],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13595,13598],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ElectronicComponent } from \"../../../types\";\nimport { getAIClient, MODELS } from \"../client\";\nimport { PROMPTS } from \"../prompts\";\nimport { COMPONENT_SCHEMA, PART_FINDER_SCHEMA } from \"../types\";\nimport { aiMetricsService } from \"../../aiMetricsService\";\nimport { standardsService } from \"../../standardsService\";\n\nconst CACHE_KEY_PREFIX = 'cm_3d_code_';\n\nexport const explainComponent = async (componentName: string): Promise<string> => {\n  const startTime = Date.now();\n  const model = MODELS.CHAT;\n  const ai = getAIClient();\n\n  // Check if API key is configured\n  const apiKey = localStorage.getItem('cm_gemini_api_key') || process.env.API_KEY;\n  if (!apiKey) {\n    return `**API Key Required**\\n\\nTo get component explanations, please configure your Gemini API key in Settings.\\n\\n*Component: ${componentName}*`;\n  }\n\n  try {\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: PROMPTS.EXPLAIN_COMPONENT(componentName),\n    });\n\n    aiMetricsService.logMetric({\n        model,\n        operation: 'explainComponent',\n        latencyMs: Date.now() - startTime,\n        success: true\n      });\n\n    return response.text || \"Could not retrieve explanation.\";\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    console.error('[explainComponent] Error:', errorMessage);\n\n    aiMetricsService.logMetric({\n        model,\n        operation: 'explainComponent',\n        latencyMs: Date.now() - startTime,\n        success: false,\n        error: errorMessage\n      });\n\n    // Provide user-friendly error messages\n    if (errorMessage.includes('API_KEY') || errorMessage.includes('401') || errorMessage.includes('invalid')) {\n      return `**API Key Error**\\n\\nYour Gemini API key may be invalid or expired. Please check your API key in Settings.\\n\\n*Error: ${errorMessage}*`;\n    }\n    if (errorMessage.includes('429') || errorMessage.includes('quota') || errorMessage.includes('rate')) {\n      return `**Rate Limited**\\n\\nToo many requests. Please wait a moment and try again.\\n\\n*Component: ${componentName}*`;\n    }\n    if (errorMessage.includes('network') || errorMessage.includes('fetch') || errorMessage.includes('Failed to fetch')) {\n      return `**Connection Error**\\n\\nCouldn't connect to the AI service. Please check your internet connection.\\n\\n*Component: ${componentName}*`;\n    }\n\n    return `**Error Loading Details**\\n\\nCouldn't retrieve information for \"${componentName}\".\\n\\n*Error: ${errorMessage}*`;\n  }\n};\n\nexport const smartFillComponent = async (name: string, type?: string): Promise<Partial<ElectronicComponent>> => {\n  const startTime = Date.now();\n  const model = MODELS.SMART_FILL;\n  const ai = getAIClient();\n  \n  try {\n    const response = await ai.models.generateContent({\n      model: model, \n      contents: PROMPTS.SMART_FILL(name, type),\n      config: {\n        tools: [{ googleSearch: {} }],\n        // responseMimeType: \"application/json\" is unsupported when tools are used\n      }\n    });\n\n    if (response.text) {\n        aiMetricsService.logMetric({ model, operation: 'smartFillComponent', latencyMs: Date.now() - startTime, success: true });\n        return JSON.parse(response.text);\n    }\n    return {};\n  } catch (e) {\n      aiMetricsService.logMetric({ model, operation: 'smartFillComponent', latencyMs: Date.now() - startTime, success: false, error: String(e) });\n      console.error(\"Smart Fill Error\", e);\n      throw e;\n  }\n}\n\nexport const assistComponentEditor = async (\n  history: { role: string, text: string }[],\n  currentComponent: Partial<ElectronicComponent>,\n  userInstruction: string\n): Promise<{\n  reply: string, \n  updates: Partial<ElectronicComponent>,\n  foundImages: string[],\n  suggestedActions: string[]\n}> => {\n  const startTime = Date.now();\n  const model = MODELS.ASSIST_EDITOR;\n  const ai = getAIClient();\n  \n  try {\n    const contextPrompt = PROMPTS.ASSIST_EDITOR(JSON.stringify(currentComponent, null, 2), userInstruction);\n    const chatHistory = history.map(h => ({ role: h.role, parts: [{ text: h.text }] }));\n\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: [\n        ...chatHistory,\n        { role: 'user', parts: [{ text: contextPrompt }] }\n      ],\n      config: {\n        tools: [{ googleSearch: {} }],\n        // responseMimeType: \"application/json\" is unsupported when tools are used\n      }\n    });\n\n    if (response.text) {\n      aiMetricsService.logMetric({ model, operation: 'assistComponentEditor', latencyMs: Date.now() - startTime, success: true });\n      return JSON.parse(response.text);\n    }\n    throw new Error(\"No response from AI assistant\");\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'assistComponentEditor', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"Assistant Error\", error);\n    throw error;\n  }\n};\n\nexport const augmentComponentData = async (partialName: string): Promise<Partial<ElectronicComponent>> => {\n  const startTime = Date.now();\n  const model = MODELS.AUTO_ID;\n  const ai = getAIClient();\n  \n  try {\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: PROMPTS.AUGMENT_COMPONENT(partialName),\n      config: {\n        responseMimeType: \"application/json\",\n        responseSchema: COMPONENT_SCHEMA\n      }\n    });\n    if (response.text) {\n      aiMetricsService.logMetric({ model, operation: 'augmentComponentData', latencyMs: Date.now() - startTime, success: true });\n      return JSON.parse(response.text);\n    }\n    throw new Error(\"Failed to identify\");\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'augmentComponentData', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"Auto-ID Error\", error);\n    throw error;\n  }\n};\n\nexport const findComponentSpecs = async (query: string): Promise<Partial<ElectronicComponent>[]> => {\n  const startTime = Date.now();\n  const model = MODELS.PART_FINDER;\n  const ai = getAIClient();\n  \n  try {\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: PROMPTS.FIND_COMPONENT(query),\n      config: {\n        responseMimeType: \"application/json\",\n        responseSchema: PART_FINDER_SCHEMA\n      }\n    });\n    \n    if (response.text) {\n      aiMetricsService.logMetric({ model, operation: 'findComponentSpecs', latencyMs: Date.now() - startTime, success: true });\n      return JSON.parse(response.text);\n    }\n    return [];\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'findComponentSpecs', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"Part Finder Error\", error);\n    throw error;\n  }\n};\n\nexport const identifyComponentFromImage = async (imageBase64: string): Promise<Partial<ElectronicComponent>> => {\n  const ai = getAIClient();\n  try {\n    const cleanBase64 = imageBase64.replace(/^data:image\\/(png|jpeg|jpg|webp);base64,/, '');\n    const response = await ai.models.generateContent({\n      model: MODELS.IMAGE, // Ensure this maps to a valid model like gemini-2.0-flash\n      contents: {\n        parts: [\n          { inlineData: { mimeType: 'image/png', data: cleanBase64 } },\n          { text: PROMPTS.IDENTIFY_IMAGE }\n        ]\n      },\n    });\n    \n    if (response.text) {\n      const text = response.text.replace(/```json/g, '').replace(/```/g, '').trim();\n      return JSON.parse(text);\n    }\n    throw new Error(\"Failed to identify image\");\n  } catch (error) {\n    console.error(\"Image ID Error\", error);\n    throw error;\n  }\n};\n\nexport const performDeepSpecSearch = async (name: string, type: string): Promise<any> => {\n  const ai = getAIClient();\n  const isLikelyBoard = type.toLowerCase().includes('board') || \n                        type.toLowerCase().includes('module') || \n                        type.toLowerCase().includes('breakout') || \n                        name.toLowerCase().includes('shield') ||\n                        name.toLowerCase().includes('hat');\n\n  const prompt = isLikelyBoard \n    ? `\n      Search for the mechanical specifications of the electronic board/module \"${name}\".\n      Prioritize finding:\n      1. PCB Dimensions (Width x Length in mm).\n      2. Mounting Hole spacing/coordinates.\n      3. Key Interface locations (USB port, Power jack, Pin headers).\n      \n      Return ONLY a JSON object:\n      {\n        \"category\": \"board\",\n        \"width\": number,\n        \"length\": number,\n        \"height\": number (approx 1.6 if pcb only, more if connectors),\n        \"mounting_holes\": [ { \"x\": number, \"z\": number, \"diameter\": number } ],\n        \"interfaces\": [\n           { \"type\": \"usb\"|\"header\"|\"jack\"|\"button\", \"edge\": \"left\"|\"right\"|\"top\"|\"bottom\", \"offset_mm\": number }\n        ]\n      }\n    `\n    : `\n      Search for the datasheet and physical dimensions of the electronic component \"${name}\".\n      Prioritize finding:\n      1. Package Type (e.g. SOIC-8, TO-220, QFN-32).\n      2. Exact Body Dimensions (Width x Length x Height).\n      3. Pin Pitch and Count.\n      \n      Return ONLY a JSON object:\n      { \n        \"category\": \"component\",\n        \"package\": string, \n        \"width\": number, \n        \"length\": number, \n        \"height\": number, \n        \"pitch\": number, \n        \"pins\": number,\n        \"datasheet_ref\": string \n      }\n    `;\n  \n  try {\n    const response = await ai.models.generateContent({\n      model: MODELS.SMART_FILL,\n      contents: prompt,\n      config: { tools: [{ googleSearch: {} }] }\n    });\n    \n    if (response.text) {\n        const cleaned = response.text.replace(/```json/g, '').replace(/```/g, '').trim();\n        const data = JSON.parse(cleaned);\n        return data;\n    }\n  } catch (e) {\n    console.warn(\"Spec search failed\", e);\n  }\n  return null;\n};\n\nexport const generateComponent3DCode = async (\n  componentName: string, \n  componentType: string,\n  customInstructions?: string,\n  force: boolean = false,\n  imageUrl?: string,\n  precisionLevel: 'draft' | 'masterpiece' = 'draft'\n): Promise<string> => {\n  const startTime = Date.now();\n  const model = MODELS.CODE_GEN;\n  const ai = getAIClient();\n  \n  // Cache Key: name + type + instructions + (hasImage) + precision\n  const cacheKey = `${CACHE_KEY_PREFIX}${componentName}_${componentType}_${customInstructions || ''}_${imageUrl ? 'img' : ''}_${precisionLevel}`.replace(/\\s+/g, '_').toLowerCase();\n  \n  // Try Cache (unless forced)\n  if (!force) {\n    try {\n      const cached = localStorage.getItem(cacheKey);\n      if (cached) {\n        return cached;\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n  }\n  \n  // 1. Spec Extraction Pass (Grounding)\n  const standard = standardsService.getPackage(componentName) || standardsService.getPackage(componentType);\n  const board = standardsService.getBoardMap(componentName) || standardsService.getBoardMap(componentType);\n  let deepSpec: any = null;\n\n  if (!standard && !board) {\n    deepSpec = await performDeepSpecSearch(componentName, componentType);\n    \n    // If deep search found a component package that matches a standard, snap to it?\n    // For now, we trust the deep search if it returned data.\n  }\n\n  let dimensionHint = \"\";\n  if (board) {\n    dimensionHint = `\n      ASSEMBLY PLAN (INTERNAL STANDARD):\n      This is a known board (\"${board.name}\").\n      DO NOT guess. Use this exact placement for major components on the PCB:\n      - PCB: ${board.width}x${board.length}x1.6mm\n      - Sub-components:\n        ${board.components.map(c => `- ${c.name} (${c.type}): At x:${c.x}, z:${c.z}${c.rotation ? `, rot:${c.rotation}` : ''}${c.params ? `, params:${JSON.stringify(c.params)}` : ''}`).join('\\n        ')}\n      REQUIREMENT: You must instantiate every one of these sub-components using Primitives.\n    `;\n  } else if (deepSpec) {\n      if (deepSpec.category === 'board') {\n          dimensionHint = `\n            ASSEMBLY PLAN (FROM WEB DATASHEET):\n            Dimensions: ${deepSpec.width}mm x ${deepSpec.length}mm.\n            Mounting Holes: ${JSON.stringify(deepSpec.mounting_holes || [])}.\n            Interfaces: ${JSON.stringify(deepSpec.interfaces || [])}.\n            \n            USE 'Primitives.createLayout(${deepSpec.width}, ${deepSpec.length})'.\n            Place interfaces at their approximate edges.\n          `;\n      } else {\n          dimensionHint = `\n            GROUNDING DATA (FROM WEB DATASHEET):\n            Package: \"${deepSpec.package}\".\n            Dimensions: ${deepSpec.width}x${deepSpec.length}x${deepSpec.height}mm.\n            Pitch: ${deepSpec.pitch}mm.\n            Pins: ${deepSpec.pins}.\n            Ref: ${deepSpec.datasheet_ref || 'Web Search'}.\n          `;\n      }\n  } else if (standard) {\n    dimensionHint = `\n      GROUNDING DATA (IPC-7351 STANDARD):\n      This component matches package \"${standard.pin_count || 'N/A'}-pin ${standard.pin_type || 'N/A'}\".\n      Use these EXACT dimensions:\n      - body_width: ${standard.body_width}mm\n      - body_length: ${standard.body_length}mm\n      - height: ${standard.height}mm\n      - pitch: ${standard.pitch || 'N/A'}mm\n    `;\n  }\n\n  // 1.5. Visual Analysis Pass (Vision Grounding)\n  let visualAnalysis = \"\";\n  if (imageUrl && !board) { // Only needed if we don't have a hard-coded board map\n      try {\n          // Fetch the image to get base64/blob for Gemini\n          // Note: In a real app, might need a proxy or CORS handling. \n          // Assuming imageUrl is accessible or a data URI.\n          // For now, we'll try-catch this block aggressively.\n          \n          let imagePart: any = null;\n          if (imageUrl.startsWith('data:')) {\n             const mimeType = imageUrl.split(';')[0].split(':')[1];\n             const data = imageUrl.split(',')[1];\n             imagePart = { inlineData: { mimeType, data } };\n          } else {\n             // If it's a URL, we might skip or try to fetch.\n             // For safety in this CLI environment, let's assume if it's not data URI, we skip \n             // unless we add a fetch tool. But let's assume the UI passes data URIs mostly.\n          }\n\n          if (imagePart) {\n             const visionResponse = await ai.models.generateContent({\n                 model: MODELS.IMAGE, // Use a vision-capable model\n                 contents: [\n                     { text: PROMPTS.ANALYZE_COMPONENT_VISUALS },\n                     imagePart\n                 ]\n             });\n             visualAnalysis = visionResponse.text || \"\";\n          }\n      } catch (e) {\n          console.warn(\"Visual analysis failed\", e);\n      }\n  }\n\n  // 2. Assembly Pass (Code Generation)\n  try {\n    const prompt = PROMPTS.GENERATE_3D_CODE(componentName, componentType, customInstructions, dimensionHint, visualAnalysis, precisionLevel);\n    \n    const response = await ai.models.generateContent({\n      model: model,\n      contents: prompt,\n      config: {\n         thinkingConfig: { thinkingBudget: 4096 },\n         tools: [{ googleSearch: {} }],\n         systemInstruction: \"You are a Master 3D Architect. Output only valid JavaScript. Use Primitives and Materials for everything. Be precise.\"\n      }\n    });\n\n    let code = response.text || \"\";\n    \n    // 2.5. Self-Correction Pass (Review & Refine)\n    const correctionPrompt = `\n        Review the following 3D model code for an electronic component.\n        CHECK FOR:\n        1. Syntax errors or mismatched brackets.\n        2. \"Magic numbers\" (all positions should use layout.place()).\n        3. Missing return group; statement.\n        4. Floating components (everything must be added to 'group').\n        \n        CODE TO REVIEW:\n        ${code}\n        \n        If perfect, return the code as-is. \n        If flawed, output the FIXED valid JavaScript code ONLY.\n    `;\n    \n    const correctionResponse = await ai.models.generateContent({\n        model: MODELS.CHAT, // Use a faster model for review\n        contents: correctionPrompt,\n        config: {\n            systemInstruction: \"You are a Senior 3D Code Auditor. Output ONLY valid JS code.\"\n        }\n    });\n    \n    if (correctionResponse.text) {\n        code = correctionResponse.text;\n    }\n\n    // 1. Heavy Markdown/Prose Cleanup\n    code = code.replace(/```(?:javascript|js)?\\n?([\\s\\S]*?)```/g, '$1');\n    \n    // 2. Remove common AI \"Sure thing!\" prose at the start\n    // We only want to strip prose if it appears BEFORE the first valid code line.\n    // Valid code lines start with: const, let, var, import, function, class, or Primitives/THREE/group.\n    \n    // Find the index of the first line that looks like code\n    const lines = code.split('\\n');\n    let firstCodeLineIndex = -1;\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        // Check for comments\n        if (line.startsWith('//') || line.startsWith('/*')) {\n             if (firstCodeLineIndex === -1) firstCodeLineIndex = i; // Comments count as code start usually\n             continue;\n        }\n        // Check for code keywords\n        if (\n            line.startsWith('const ') || \n            line.startsWith('let ') || \n            line.startsWith('var ') || \n            line.startsWith('return ') ||\n            line.startsWith('group') ||\n            line.startsWith('THREE') || \n            line.startsWith('Primitives') ||\n            line.startsWith('layout')\n        ) {\n            firstCodeLineIndex = i;\n            break;\n        }\n    }\n    \n    if (firstCodeLineIndex !== -1) {\n        code = lines.slice(firstCodeLineIndex).join('\\n');\n    }\n\n    // 3. Handle the \"Arrow Function\" Hallucination\n    // If AI wrapped code in (THREE, Primitives, Materials) => { ... }\n    // we want just the ... part.\n    const arrowFuncPattern = /^\\s*\\(?THREE,\\s*Primitives,\\s*Materials\\)?\\s*=>\\s*\\{?([\\s\\S]*?)\\}?\\s*;?\\s*$/i;\n    const arrowMatch = code.match(arrowFuncPattern);\n    if (arrowMatch) {\n        code = arrowMatch[1];\n    }\n\n    // 4. Bracket/Paren Balancer (Crucial for \"Unexpected token ')'\")\n    // If the code ends with a return and then a trailing paren/brace, strip it.\n    const lastReturnIdx = code.lastIndexOf('return group;');\n    if (lastReturnIdx !== -1) {\n        const afterReturn = code.substring(lastReturnIdx + 13).trim();\n        // If there's garbage after return group; like ')', '}', or prose\n        if (afterReturn.length > 0) {\n            // Check if it's just semicolons or single closing marks\n            if (/^[;})\\s]+$/.test(afterReturn)) {\n                code = code.substring(0, lastReturnIdx + 13);\n            } else {\n                // If it's more complex prose, still cut at return group;\n                code = code.substring(0, lastReturnIdx + 13);\n            }\n        }\n    }\n\n    code = code.trim();\n    \n    // Final Syntax Sanity: if it starts with ( and ends with ), strip them\n    if (code.startsWith('(') && code.endsWith(')')) {\n        code = code.substring(1, code.length - 1).trim();\n    }\n    \n    if (code.length < 20) throw new Error(\"Generated code is too short or invalid\");\n\n    // Save to Cache\n    try {\n        localStorage.setItem(cacheKey, code); // Using localStorage for consistency with read\n    } catch (e) {\n        console.warn(\"Failed to cache 3D code\", e);\n    }\n\n    aiMetricsService.logMetric({ model, operation: 'generateComponent3DCode', latencyMs: Date.now() - startTime, success: true });\n    return code;\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'generateComponent3DCode', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"3D Generation Error:\", error);\n    throw error;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/datasheets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/hud.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/media.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3528,3531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3528,3531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getAIClient, getApiKey, MODELS, APIError } from \"../client\";\nimport { PROMPTS } from \"../prompts\";\nimport { aiMetricsService } from \"../../aiMetricsService\";\nimport { Modality } from \"@google/genai\";\nimport { GoogleGenAI } from \"@google/genai\"; // Needed for local instantiation in generateConceptImage\n\nexport const transcribeAudio = async (audioBase64: string): Promise<string> => {\n  const startTime = Date.now();\n  const model = MODELS.AUDIO_TRANSCRIPTION;\n  const ai = getAIClient();\n  try {\n    const cleanBase64 = audioBase64.split(',')[1] || audioBase64;\n    const response = await ai.models.generateContent({\n      model: model,\n      contents: [\n        {\n          parts: [\n            { inlineData: { mimeType: 'audio/wav', data: cleanBase64 } },\n            { text: PROMPTS.TRANSCRIBE_AUDIO }\n          ]\n        }\n      ]\n    });\n    aiMetricsService.logMetric({ model, operation: 'transcribeAudio', latencyMs: Date.now() - startTime, success: true });\n    return response.text || \"\";\n  } catch (error) {\n    aiMetricsService.logMetric({ model, operation: 'transcribeAudio', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n    console.error(\"Transcription Error\", error);\n    throw error;\n  }\n}\n\nexport const generateSpeech = async (text: string): Promise<string> => {\n  const ai = getAIClient();\n  try {\n    const response = await ai.models.generateContent({\n      model: MODELS.TTS,\n      contents: [{ parts: [{ text: text }] }],\n      config: {\n        responseModalities: [Modality.AUDIO],\n        speechConfig: {\n            voiceConfig: {\n              prebuiltVoiceConfig: { voiceName: 'Kore' },\n            },\n        },\n      },\n    });\n\n    const base64Audio = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;\n    if (!base64Audio) throw new Error(\"No audio generated\");\n    \n    return base64Audio;\n  } catch (error) {\n    console.error(\"TTS Error\", error);\n    throw error;\n  }\n}\n\nexport const generateEditedImage = async (\n  imageBase64: string, \n  prompt: string\n): Promise<string> => {\n  const ai = getAIClient();\n  try {\n    const cleanBase64 = imageBase64.replace(/^data:image\\/(png|jpeg|jpg|webp);base64,/, '');\n\n    const response = await ai.models.generateContent({\n      model: MODELS.IMAGE_GEN,\n      contents: {\n        parts: [\n          {\n            inlineData: {\n              data: cleanBase64,\n              mimeType: 'image/png', \n            },\n          },\n          {\n            text: prompt,\n          },\n        ],\n      },\n    });\n\n    for (const part of response.candidates?.[0]?.content?.parts || []) {\n      if (part.inlineData && part.inlineData.data) {\n        return part.inlineData.data;\n      }\n    }\n    \n    throw new Error(\"No image generated\");\n  } catch (error) {\n    console.error(\"Image Generation Error:\", error);\n    throw error;\n  }\n};\n\nexport const generateConceptImage = async (\n  prompt: string,\n  size: '1K' | '2K' | '4K',\n  aspectRatio: string = '16:9',\n  enableSearch: boolean = false\n): Promise<string> => {\n  const startTime = Date.now();\n  const model = MODELS.IMAGE_GEN;\n  \n  if (window.aistudio && typeof window.aistudio.hasSelectedApiKey === 'function') {\n    const hasKey = await window.aistudio.hasSelectedApiKey();\n    if (!hasKey) {\n      await window.aistudio.openSelectKey();\n    }\n  }\n\n  // Helper to execute request with error handling/retry\n  const executeRequest = async () => {\n    const apiKey = getApiKey();\n    const aiClient = new GoogleGenAI({ apiKey });\n    \n    const config: any = {\n        imageConfig: {\n          imageSize: size,\n          aspectRatio: aspectRatio,\n        },\n    };\n    \n    if (enableSearch) {\n        config.tools = [{ googleSearch: {} }];\n    }\n\n    return await aiClient.models.generateContent({\n      model: model,\n      contents: {\n        parts: [{ text: prompt }],\n      },\n      config: config,\n    });\n  };\n\n  try {\n    const result = (await executeRequest()).candidates?.[0]?.content?.parts?.[0]?.inlineData?.data || \"\";\n    aiMetricsService.logMetric({ model, operation: 'generateConceptImage', latencyMs: Date.now() - startTime, success: true });\n    return result;\n  } catch (error: unknown) {\n     aiMetricsService.logMetric({ model, operation: 'generateConceptImage', latencyMs: Date.now() - startTime, success: false, error: String(error) });\n     // Handle Permission Denied (403) or Not Found\n    const apiError = error as APIError;\n    if (apiError.status === 403 || (apiError.message && (apiError.message.includes('403') || apiError.message.includes('PERMISSION_DENIED') || apiError.message.includes('not found')))) {\n      if (window.aistudio && typeof window.aistudio.openSelectKey === 'function') {\n        await window.aistudio.openSelectKey();\n        const retryResponse = await executeRequest();\n        return retryResponse.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data || \"\";\n      }\n    }\n    throw error;\n  }\n}\n\n// Generates a small 1K square image for thumbnails\nexport const generateComponentThumbnail = async (componentName: string, customPrompt?: string): Promise<string> => {\n    const prompt = PROMPTS.GENERATE_THUMBNAIL(componentName);\n    return await generateConceptImage(\n        customPrompt || prompt, \n        '1K', \n        '1:1',\n        true\n    );\n};\n\nexport const generateCircuitVideo = async (\n  prompt: string,\n  aspectRatio: '16:9' | '9:16',\n  imageBase64?: string\n): Promise<string> => {\n  if (window.aistudio && typeof window.aistudio.hasSelectedApiKey === 'function') {\n    const hasKey = await window.aistudio.hasSelectedApiKey();\n    if (!hasKey) {\n      await window.aistudio.openSelectKey();\n    }\n  }\n\n  const executeVideoRequest = async () => {\n    const apiKey = getApiKey();\n    const aiClient = new GoogleGenAI({ apiKey });\n    let imageParam = undefined;\n    if (imageBase64) {\n      const cleanBase64 = imageBase64.replace(/^data:image\\/(png|jpeg|jpg|webp);base64,/, '');\n      imageParam = {\n        imageBytes: cleanBase64,\n        mimeType: 'image/png',\n      };\n    }\n\n    let operation = await aiClient.models.generateVideos({\n      model: MODELS.VIDEO,\n      prompt: PROMPTS.GENERATE_VIDEO(prompt),\n      image: imageParam,\n      config: {\n        numberOfVideos: 1,\n        resolution: '720p',\n        aspectRatio: aspectRatio\n      }\n    });\n\n    while (!operation.done) {\n      await new Promise(resolve => setTimeout(resolve, 5000));\n      operation = await aiClient.operations.getVideosOperation({operation: operation});\n    }\n\n    const videoUri = operation.response?.generatedVideos?.[0]?.video?.uri;\n    if (!videoUri) throw new Error(\"Video generation failed to return a URI\");\n\n    return `${videoUri}&key=${apiKey}`;\n  };\n  \n  try {\n    return await executeVideoRequest();\n  } catch (error: unknown) {\n    const apiError = error as APIError;\n    if (apiError.status === 403 || (apiError.message && (apiError.message.includes('403') || apiError.message.includes('PERMISSION_DENIED')))) {\n      if (window.aistudio && typeof window.aistudio.openSelectKey === 'function') {\n        await window.aistudio.openSelectKey();\n        return await executeVideoRequest();\n      }\n    }\n    throw error;\n  }\n};\n\nexport const embedText = async (text: string): Promise<number[]> => {\n  const model = MODELS.EMBEDDING;\n  const ai = getAIClient();\n  try {\n    const result = await ai.models.embedContent({\n      model: model,\n      contents: [{ parts: [{ text }] }],\n    });\n    \n    if (result.embeddings?.[0]?.values) {\n        return result.embeddings[0].values;\n    }\n    throw new Error(\"No embedding returned\");\n  } catch (error) {\n    console.error(\"Embedding Error\", error);\n    throw error;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/predictions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[944,947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[944,947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getAIClient, MODELS } from '../client';\nimport { PROMPTS } from '../prompts';\nimport { AIContext } from '../../../types';\nimport { PredictiveAction } from '../../predictionEngine';\n\n/**\n * Generates AI-powered design predictions based on full workspace context.\n */\nexport const generatePredictions = async (context: AIContext): Promise<PredictiveAction[]> => {\n  const genAI = getAIClient();\n  const contextStr = JSON.stringify(context);\n  const prompt = PROMPTS.GENERATE_PREDICTIONS(contextStr);\n\n  try {\n    const result = await genAI.models.generateContent({\n      model: MODELS.PART_FINDER,\n      contents: [{ role: 'user', parts: [{ text: prompt }] }],\n      config: {\n        temperature: 0.3,\n        responseMimeType: \"application/json\",\n      }\n    });\n    \n    const response = result.text || '[]';\n    const parsed = JSON.parse(response);\n    \n    // Transform payloadJson strings back to objects\n    return parsed.map((p: any) => ({\n      ...p,\n      action: {\n        ...p.action,\n        payload: JSON.parse(p.action.payloadJson)\n      }\n    }));\n  } catch (error) {\n    console.error('Prediction generation failed:', error);\n    return [];\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/simulation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/suggestions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/versioning.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/features/wiring.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/parsers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ParsedAIResponse' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ActionIntent, ActionType, ComponentReference } from \"../../types\";\nimport { ParsedAIResponse, AISuggestedAction, AIComponentMention } from \"./types\";\n\n/**\n * Normalizes proactive suggestions from AI response\n */\nexport const normalizeProactiveSuggestions = (input: unknown): string[] => {\n  if (!Array.isArray(input)) return [];\n\n  const normalized = input\n    .map((item) => {\n      if (typeof item === 'string') return item.trim();\n      if (item && typeof item === 'object' && 'label' in item) {\n        const label = (item as { label?: unknown }).label;\n        if (typeof label === 'string') return label.trim();\n      }\n      return null;\n    })\n    .filter((item): item is string => Boolean(item && item.length > 0));\n\n  return normalized.slice(0, 3);\n};\n\n/**\n * Parses raw JSON text from AI response, handling common formatting issues\n */\nexport const parseJSONResponse = <T>(text: string): T => {\n    try {\n        // Remove markdown code blocks if present\n        const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();\n        return JSON.parse(cleanText) as T;\n    } catch (error) {\n        // Basic fallback if strict JSON parse fails? \n        // For now, re-throw so the caller can handle or default\n        throw new Error(`Failed to parse AI JSON response: ${String(error)}`);\n    }\n};\n\n/**\n * Extracts component mentions from parsed AI response\n */\nexport const extractComponentMentions = (\n    parsedMentions: AIComponentMention[] | undefined,\n    messageText: string\n): ComponentReference[] => {\n    return (parsedMentions || []).map((m) => {\n        const name = m.componentName || '';\n        const lowerMessage = messageText.toLowerCase();\n        const lowerName = name.toLowerCase();\n        const idx = lowerName ? lowerMessage.indexOf(lowerName) : -1;\n        return {\n            componentId: m.componentId,\n            componentName: name,\n            mentionStart: idx >= 0 ? idx : 0,\n            mentionEnd: idx >= 0 ? idx + name.length : 0,\n        };\n    });\n};\n\n/**\n * Extracts and normalizes suggested actions from parsed AI response\n */\nexport const extractSuggestedActions = (\n    parsedActions: AISuggestedAction[] | undefined\n): ActionIntent[] => {\n    return (parsedActions || []).map((a) => {\n        let payload = {};\n        if (a.payloadJson) {\n            try {\n                // LLMs sometimes output escaped JSON or include extra quotes\n                const cleanJson = a.payloadJson.replace(/^`+|`+$/g, '').trim();\n                payload = JSON.parse(cleanJson);\n            } catch (_e) {\n                console.warn('Failed to parse payloadJson:', a.payloadJson);\n                // If it looks like a simple string, maybe it was meant to be a component ID?\n                if (typeof a.payloadJson === 'string' && a.payloadJson.length < 50 && !a.payloadJson.includes('{')) {\n                    payload = { componentId: a.payloadJson };\n                }\n            }\n        } else if (a.payload) {\n            // Fallback for legacy format\n            payload = a.payload;\n        }\n        return {\n            type: a.type as ActionType,\n            label: a.label,\n            payload,\n            safe: a.safe ?? false,\n        };\n    });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/prompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gemini/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/geminiService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gesture/GestureEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[188,191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[188,191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface HandLandmark {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport interface GestureResult {\n  landmarks: HandLandmark[][];\n  worldLandmarks: HandLandmark[][];\n  handedness: any[][];\n  timestamp: number;\n}\n\ntype GestureListener = (result: GestureResult) => void;\n\nclass GestureEngine {\n  private worker: Worker | null = null;\n  private listeners: Set<GestureListener> = new Set();\n  private isInitialized = false;\n  private isProcessing = false;\n\n  async init(): Promise<void> {\n    if (this.isInitialized) return;\n\n    return new Promise((resolve, reject) => {\n      try {\n        // Load the worker as a classic script because MediaPipe bundles use importScripts internally\n        this.worker = new Worker('/assets/mediapipe/gestureWorker.js');\n        \n        const timeout = setTimeout(() => {\n          if (!this.isInitialized) {\n            console.error('GestureEngine: Initialization timed out');\n            reject(new Error('Gesture tracking initialization timed out.'));\n          }\n        }, 15000); // 15s timeout for model loading\n\n        this.worker.onmessage = (event) => {\n          const { type, payload } = event.data;\n\n          if (type === 'INIT_COMPLETE') {\n            this.isInitialized = true;\n            clearTimeout(timeout);\n            resolve();\n          } else if (type === 'LANDMARKS') {\n            this.listeners.forEach(l => l(payload));\n            this.isProcessing = false;\n          } else if (type === 'ERROR') {\n            console.error('Gesture Worker Error:', payload);\n            this.isProcessing = false;\n            if (!this.isInitialized) {\n              clearTimeout(timeout);\n              reject(new Error(payload));\n            }\n          }\n        };\n\n        this.worker.onerror = (e) => {\n          console.error('Gesture Worker Critical Error:', e);\n          clearTimeout(timeout);\n          reject(new Error('Gesture worker failed to load. Check console for details.'));\n        };\n\n        this.worker.postMessage({ type: 'INIT' });\n      } catch (err) {\n        console.error('GestureEngine: Failed to create worker', err);\n        reject(err);\n      }\n    });\n  }\n\n  onLandmarks(listener: GestureListener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  async processFrame(video: HTMLVideoElement) {\n    if (!this.isInitialized || !this.worker || this.isProcessing) return;\n\n    // Use OffscreenCanvas or ImageBitmap for efficiency\n    try {\n      const imageBitmap = await createImageBitmap(video);\n      this.isProcessing = true;\n      this.worker.postMessage({\n        type: 'PROCESS_FRAME',\n        payload: {\n          imageBitmap,\n          timestamp: performance.now()\n        }\n      }, [imageBitmap]); // Transfer the bitmap to the worker\n    } catch (e) {\n      console.warn('Frame capture failed', e);\n    }\n  }\n\n  dispose() {\n    this.worker?.terminate();\n    this.worker = null;\n    this.listeners.clear();\n    this.isInitialized = false;\n  }\n}\n\nexport const gestureEngine = new GestureEngine();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gesture/GestureMetricsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[228,231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[228,231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { storageService } from '../storage';\n\nexport interface GestureMetric {\n  id: string;\n  timestamp: number;\n  gestureType: string;\n  confidence: number;\n  success: boolean;\n  latencyMs: number;\n  metadata?: Record<string, any>;\n}\n\nclass GestureMetricsService {\n  private metrics: GestureMetric[] = [];\n  private readonly MAX_LOCAL_METRICS = 100;\n\n  async logMetric(metric: Omit<GestureMetric, 'id' | 'timestamp'>) {\n    const newMetric: GestureMetric = {\n      ...metric,\n      id: crypto.randomUUID(),\n      timestamp: Date.now()\n    };\n\n    this.metrics.push(newMetric);\n    \n    // Periodically save to storage\n    if (this.metrics.length >= 10) {\n      await this.flush();\n    }\n  }\n\n  async flush() {\n    if (this.metrics.length === 0) return;\n    \n    try {\n      const existing = await storageService.getItem('cm_gesture_metrics') || '[]';\n      const parsed = JSON.parse(existing);\n      const updated = [...parsed, ...this.metrics].slice(-this.MAX_LOCAL_METRICS);\n      \n      await storageService.setItem('cm_gesture_metrics', JSON.stringify(updated));\n      this.metrics = [];\n    } catch (e) {\n      console.error('Failed to flush gesture metrics', e);\n    }\n  }\n\n  async getSummary() {\n    try {\n      const data = await storageService.getItem('cm_gesture_metrics') || '[]';\n      const parsed: GestureMetric[] = JSON.parse(data);\n      \n      if (parsed.length === 0) return null;\n      \n      const successCount = parsed.filter(m => m.success).length;\n      const avgLatency = parsed.reduce((sum, m) => sum + m.latencyMs, 0) / parsed.length;\n      \n      return {\n        totalActions: parsed.length,\n        accuracy: (successCount / parsed.length) * 100,\n        averageLatency: avgLatency\n      };\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport const gestureMetricsService = new GestureMetricsService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/gitService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/healthMonitor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[893,896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[893,896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface HealthMetrics {\n  fps: number;\n  memoryUsed: number; // MB\n  memoryLimit: number; // MB\n  aiLatency: number; // ms (last request)\n  status: 'healthy' | 'warning' | 'critical';\n}\n\nclass HealthMonitor {\n  private frameCount = 0;\n  private lastTime = performance.now();\n  private fps = 60;\n  private aiLatency = 0;\n\n  constructor() {\n    this.startFPSLoop();\n  }\n\n  private startFPSLoop() {\n    const loop = () => {\n      this.frameCount++;\n      const time = performance.now();\n      if (time >= this.lastTime + 1000) {\n        this.fps = Math.round((this.frameCount * 1000) / (time - this.lastTime));\n        this.frameCount = 0;\n        this.lastTime = time;\n      }\n      requestAnimationFrame(loop);\n    };\n    requestAnimationFrame(loop);\n  }\n\n  recordAiLatency(ms: number) {\n    this.aiLatency = ms;\n  }\n\n  getMetrics(): HealthMetrics {\n    const memory = (performance as any).memory;\n    const memoryUsed = memory ? Math.round(memory.usedJSHeapSize / 1048576) : 0;\n    const memoryLimit = memory ? Math.round(memory.jsHeapLimit / 1048576) : 0;\n\n    let status: HealthMetrics['status'] = 'healthy';\n    if (this.fps < 30 || (memoryLimit > 0 && memoryUsed / memoryLimit > 0.8)) {\n      status = 'warning';\n    }\n    if (this.fps < 15 || (memoryLimit > 0 && memoryUsed / memoryLimit > 0.95)) {\n      status = 'critical';\n    }\n\n    return {\n      fps: this.fps,\n      memoryUsed,\n      memoryLimit,\n      aiLatency: this.aiLatency,\n      status\n    };\n  }\n}\n\nexport const healthMonitor = new HealthMonitor();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/knowledgeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/liveAudio.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":216,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7680,7683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7680,7683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GoogleGenAI, LiveServerMessage, Modality, Part } from \"@google/genai\";\nimport { MODELS } from \"./gemini/client\";\n\n// Type for webkit prefixed AudioContext (Safari compatibility)\ntype WebkitAudioContext = typeof AudioContext;\ndeclare global {\n  interface Window {\n    webkitAudioContext?: WebkitAudioContext;\n  }\n}\n\n// Extended type for Gemini Live session to support media\ninterface ExtendedSession {\n  sendRealtimeInput: (input: { media: { data: string; mimeType: string } }) => void;\n  sendMedia?: (media: Part[]) => void; // Optional if SDK differs\n  close: () => void;\n}\n\n// Audio configuration constants\nconst INPUT_SAMPLE_RATE = 16000;\nconst OUTPUT_SAMPLE_RATE = 24000;\nconst MODEL_NAME = MODELS.AUDIO_REALTIME;\n\n// Helper for Base64 encoding/decoding\nfunction encode(bytes: Uint8Array) {\n  let binary = '';\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n\nfunction decode(base64: string) {\n  const binaryString = atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\n\n// Convert Float32 audio from microphone to PCM16 Base64 for the model\nfunction pcm16BlobFromFloat32(data: Float32Array): { data: string; mimeType: string } {\n  const l = data.length;\n  const int16 = new Int16Array(l);\n  for (let i = 0; i < l; i++) {\n    // Clamp values\n    const s = Math.max(-1, Math.min(1, data[i]));\n    int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n  }\n  return {\n    data: encode(new Uint8Array(int16.buffer)),\n    mimeType: 'audio/pcm;rate=16000',\n  };\n}\n\n// Decode Raw PCM16 Base64 from model to AudioBuffer for playback\nasync function audioBufferFromPcm16(\n  base64Data: string,\n  ctx: AudioContext\n): Promise<AudioBuffer> {\n  const bytes = decode(base64Data);\n  const dataInt16 = new Int16Array(bytes.buffer);\n  const frameCount = dataInt16.length;\n  const buffer = ctx.createBuffer(1, frameCount, OUTPUT_SAMPLE_RATE);\n  const channelData = buffer.getChannelData(0);\n\n  for (let i = 0; i < frameCount; i++) {\n    channelData[i] = dataInt16[i] / 32768.0;\n  }\n  return buffer;\n}\n\n// Convert Blob to Base64 string for sending image data\nasync function blobToBase64(blob: Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const result = reader.result as string;\n      // Remove the data URL prefix (e.g., \"data:image/png;base64,\")\n      resolve(result.split(',')[1]);\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\nexport class LiveSession {\n  private ai: GoogleGenAI;\n  private inputContext: AudioContext | null = null;\n  private outputContext: AudioContext | null = null;\n  private stream: MediaStream | null = null;\n  private processor: ScriptProcessorNode | null = null;\n  private source: MediaStreamAudioSourceNode | null = null;\n  private outputNode: GainNode | null = null;\n  private session: ExtendedSession | null = null;\n  private nextStartTime = 0;\n  private audioSources = new Set<AudioBufferSourceNode>();\n  private onStatusChange: (status: string) => void;\n  private visualContextInterval: NodeJS.Timeout | null = null;\n  private visualContextProviders: (() => Promise<Blob | null>)[] = [];\n\n  constructor(onStatusChange: (status: string) => void) {\n    this.ai = new GoogleGenAI({ apiKey: process.env.API_KEY });\n    this.onStatusChange = onStatusChange;\n  }\n\n  // Method to set the function that captures the canvas snapshot\n  setVisualContextProviders(providers: (() => Promise<Blob | null>)[]) {\n    this.visualContextProviders = providers;\n  }\n\n  async connect() {\n    try {\n      this.onStatusChange('connecting');\n\n      // Initialize Audio Contexts\n      const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n      if (!AudioContextClass) throw new Error('AudioContext not supported');\n      this.inputContext = new AudioContextClass({ sampleRate: INPUT_SAMPLE_RATE });\n      this.outputContext = new AudioContextClass({ sampleRate: OUTPUT_SAMPLE_RATE });\n\n      this.outputNode = this.outputContext.createGain();\n      this.outputNode.connect(this.outputContext.destination);\n\n      // Get User Media\n      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n      // Connect to Gemini Live\n      const sessionPromise = this.ai.live.connect({\n        model: MODEL_NAME,\n        config: {\n          // Include audio modality by default\n          responseModalities: [Modality.AUDIO],\n          speechConfig: {\n            voiceConfig: { prebuiltVoiceConfig: { voiceName: 'Kore' } },\n          },\n          // System instruction to guide the AI's persona and task\n          systemInstruction:\n            'You are CircuitMind, an advanced electronics AI assistant. Be concise, helpful, and technical. You are talking to a user building circuits. ALWAYS refer to the visual context provided. We may provide multiple images (e.g. digital diagram and physical camera feed). Use them to answer user questions about alignment, missing parts, or physical layout.',\n        },\n        callbacks: {\n          onopen: () => {\n            this.onStatusChange('active');\n            // Cast promise result to ExtendedSession\n            this.startAudioInput(sessionPromise as unknown as Promise<ExtendedSession>);\n            this.startVisualContextStream(sessionPromise as unknown as Promise<ExtendedSession>);\n          },\n          onmessage: async (message: LiveServerMessage) => {\n            this.handleServerMessage(message);\n          },\n          onclose: () => {\n            this.onStatusChange('disconnected');\n            this.cleanup();\n          },\n          onerror: (e) => {\n            console.error(e);\n            this.onStatusChange('error');\n            this.cleanup();\n          },\n        },\n      });\n\n      this.session = (await sessionPromise) as unknown as ExtendedSession;\n    } catch (error) {\n      console.error('Failed to connect live session', error);\n      this.onStatusChange('error');\n      this.cleanup();\n    }\n  }\n\n  private startAudioInput(sessionPromise: Promise<ExtendedSession>) {\n    if (!this.inputContext || !this.stream) return;\n\n    this.source = this.inputContext.createMediaStreamSource(this.stream);\n    // Use ScriptProcessor for raw audio access\n    this.processor = this.inputContext.createScriptProcessor(4096, 1, 1);\n\n    // Cache the resolved session to avoid .then() overhead in every chunk\n    let activeSession: ExtendedSession | null = null;\n    sessionPromise.then(s => activeSession = s);\n\n    this.processor.onaudioprocess = (e) => {\n      const inputData = e.inputBuffer.getChannelData(0);\n      const pcmBlob = pcm16BlobFromFloat32(inputData);\n\n      if (activeSession) {\n        activeSession.sendRealtimeInput({ media: pcmBlob });\n      }\n    };\n\n    this.source.connect(this.processor);\n    this.processor.connect(this.inputContext.destination);\n  }\n\n  private startVisualContextStream(sessionPromise: Promise<ExtendedSession>) {\n    if (this.visualContextProviders.length === 0) {\n      console.warn('No visual context providers set. Cannot stream visuals.');\n      return;\n    }\n\n    // Send visual context every 5 seconds\n    this.visualContextInterval = setInterval(async () => {\n      try {\n        const scheduleSnapshot = (callback: () => void) => {\n          if ('requestIdleCallback' in window) {\n            window.requestIdleCallback(callback);\n          } else {\n            setTimeout(callback, 100);\n          }\n        };\n\n        scheduleSnapshot(async () => {\n          const mediaParts: any[] = [];\n          \n          for (const provider of this.visualContextProviders) {\n            const blob = await provider();\n            if (blob) {\n              const base64Image = await blobToBase64(blob);\n              mediaParts.push({\n                inlineData: {\n                  mimeType: 'image/jpeg',\n                  data: base64Image\n                }\n              });\n            }\n          }\n\n          if (mediaParts.length > 0) {\n            sessionPromise.then((session) => {\n              if (typeof session.sendMedia === 'function') {\n                  session.sendMedia(mediaParts);\n              }\n            });\n          }\n        });\n      } catch (error) {\n        console.error('Failed to capture or send visual snapshots:', error);\n      }\n    }, 5000); \n  }\n\n  private async handleServerMessage(message: LiveServerMessage) {\n    const serverContent = message.serverContent;\n\n    if (serverContent?.interrupted) {\n      this.audioSources.forEach((source) => source.stop());\n      this.audioSources.clear();\n      this.nextStartTime = 0;\n      return;\n    }\n\n    const base64Audio = serverContent?.modelTurn?.parts?.[0]?.inlineData?.data;\n\n    if (base64Audio && this.outputContext && this.outputNode) {\n      const audioBuffer = await audioBufferFromPcm16(base64Audio, this.outputContext);\n\n      this.nextStartTime = Math.max(this.outputContext.currentTime, this.nextStartTime);\n\n      const source = this.outputContext.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(this.outputNode);\n      source.start(this.nextStartTime);\n\n      this.nextStartTime += audioBuffer.duration;\n\n      this.audioSources.add(source);\n      source.onended = () => {\n        this.audioSources.delete(source);\n      };\n    }\n  }\n\n  async disconnect() {\n    if (this.session) {\n      try {\n        if (typeof this.session.close === 'function') {\n          this.session.close();\n        }\n      } catch (_e) { /* ignore */ }\n    }\n    this.cleanup();\n    this.onStatusChange('disconnected');\n  }\n\n  private cleanup() {\n    this.stream?.getTracks().forEach((track) => track.stop());\n    this.processor?.disconnect();\n    this.source?.disconnect();\n    this.inputContext?.close();\n\n    if (this.visualContextInterval) {\n      clearInterval(this.visualContextInterval);\n      this.visualContextInterval = null;\n    }\n\n    this.audioSources.forEach((source) => source.stop());\n    this.audioSources.clear();\n    this.outputContext?.close();\n\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.inputContext = null;\n    this.outputContext = null;\n    this.session = null;\n    this.getCanvasSnapshot = null;\n    this.nextStartTime = 0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/localization/i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/localization/unitConverter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/logging/auditService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/macroEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[573,576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[573,576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ActionIntent } from '../types';\n\nexport interface WorkflowStep {\n  id: string;\n  action: ActionIntent;\n  description: string;\n  delay?: number; // ms\n}\n\nexport interface MacroWorkflow {\n  id: string;\n  name: string;\n  steps: WorkflowStep[];\n  author: 'user' | 'ai' | 'system';\n  created: number;\n}\n\nexport type ExecutionProgress = (stepIndex: number, total: number) => void;\n\nclass MacroEngine {\n  /**\n   * Executes a sequence of actions with optional delays.\n   */\n  async execute(\n    steps: WorkflowStep[], \n    executeAction: (action: ActionIntent) => Promise<any>,\n    onProgress?: ExecutionProgress\n  ): Promise<void> {\n    for (let i = 0; i < steps.length; i++) {\n      const step = steps[i];\n      \n      if (onProgress) onProgress(i, steps.length);\n      \n      await executeAction(step.action);\n      \n      if (step.delay) {\n        await new Promise(resolve => setTimeout(resolve, step.delay));\n      }\n    }\n  }\n}\n\nexport const macroEngine = new MacroEngine();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/partStorageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/peerDiscoveryService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":14,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1209,1212],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1209,1212],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":56,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PeerNode } from './syncService';\n\nclass PeerDiscoveryService {\n  private peers: PeerNode[] = [];\n\n  constructor() {\n    this.loadPeers();\n  }\n\n  private loadPeers() {\n    try {\n      const saved = localStorage.getItem('cm_peers');\n      if (saved) this.peers = JSON.parse(saved);\n    } catch (e) {\n      this.peers = [];\n    }\n  }\n\n  private savePeers() {\n    localStorage.setItem('cm_peers', JSON.stringify(this.peers));\n  }\n\n  getPeers(): PeerNode[] {\n    return this.peers;\n  }\n\n  addPeer(ip: string, name: string): PeerNode {\n    const newPeer: PeerNode = {\n      deviceId: `device-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      lastIp: ip,\n      pairingStatus: 'pending',\n      lastSyncHash: ''\n    };\n    \n    this.peers.push(newPeer);\n    this.savePeers();\n    return newPeer;\n  }\n\n  removePeer(deviceId: string) {\n    this.peers = this.peers.filter(p => p.deviceId !== deviceId);\n    this.savePeers();\n  }\n\n  /**\n   * Pings all known peers to see who is online.\n   */\n  async discover() {\n    const onlinePeers: PeerNode[] = [];\n    \n    for (const peer of this.peers) {\n      try {\n        const response = await fetch(`http://${peer.lastIp}:3000/ping`, { timeout: 2000 } as any);\n        if (response.ok) onlinePeers.push(peer);\n      } catch (e) {\n        // Peer offline\n      }\n    }\n    \n    return onlinePeers;\n  }\n}\n\nexport const peerDiscoveryService = new PeerDiscoveryService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/predictionEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/ragService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/responseParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/search/searchIndexer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/securityAuditor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ElectronicComponent' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WiringDiagram, ElectronicComponent } from '../types';\n\nexport type Severity = 'low' | 'medium' | 'high' | 'critical';\n\nexport interface SecurityViolation {\n  id: string;\n  type: 'code_injection' | 'electrical_safety' | 'privacy_risk' | 'api_exposure';\n  severity: Severity;\n  location: string;\n  message: string;\n  remedy: string;\n}\n\nclass SecurityAuditor {\n  private blockedTokens = [\n    'fetch', 'XMLHttpRequest', 'WebSocket', 'window.location', \n    'localStorage', 'sessionStorage', 'document.cookie', \n    'process.env', 'eval', 'Function', 'setTimeout', 'setInterval'\n  ];\n\n  /**\n   * Scans generated code for potential injection or privacy risks.\n   */\n  scanAIGeneratedCode(code: string): SecurityViolation[] {\n    const violations: SecurityViolation[] = [];\n    \n    this.blockedTokens.forEach(token => {\n      if (code.includes(token)) {\n        violations.push({\n          id: `sec-${crypto.randomUUID().substring(0, 8)}`,\n          type: 'code_injection',\n          severity: 'critical',\n          location: 'threeCode',\n          message: `Forbidden token detected: \"${token}\"`,\n          remedy: 'Remove external network or storage access from the 3D generation logic.'\n        });\n      }\n    });\n\n    return violations;\n  }\n\n  /**\n   * Audits a wiring diagram for physical safety risks.\n   */\n  auditCircuitSafety(diagram: WiringDiagram | null): SecurityViolation[] {\n    const violations: SecurityViolation[] = [];\n    if (!diagram) return violations;\n\n    // 1. Check for VCC-GND Short\n    diagram.connections.forEach((conn, idx) => {\n      const fromPin = conn.fromPin.toUpperCase();\n      const toPin = conn.toPin.toUpperCase();\n      \n      const isPower = (p: string) => p === 'VCC' || p === '5V' || p === '3.3V' || p === 'VIN';\n      const isGround = (p: string) => p === 'GND' || p === 'GROUND';\n\n      if ((isPower(fromPin) && isGround(toPin)) || (isGround(fromPin) && isPower(toPin))) {\n        violations.push({\n          id: `elec-${idx}`,\n          type: 'electrical_safety',\n          severity: 'high',\n          location: `Connection ${idx}`,\n          message: 'Direct Short Circuit detected between Power and Ground.',\n          remedy: 'Remove this connection immediately to prevent hardware damage.'\n        });\n      }\n    });\n\n    return violations;\n  }\n}\n\nexport const securityAuditor = new SecurityAuditor();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/serialService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readableStreamClosed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":74,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Serial Communication Service\n * \n * Handles Web Serial API interactions to read data from physical microcontrollers.\n */\n\nexport interface TelemetryPacket {\n  componentId: string;\n  pin?: string;\n  value: string | number | boolean;\n  unit?: string;\n  timestamp: number;\n}\n\nexport interface SerialOptions {\n  baudRate: number;\n}\n\ninterface SerialPort {\n  open: (options: SerialOptions) => Promise<void>;\n  close: () => Promise<void>;\n  readable: ReadableStream<Uint8Array>;\n  writable: WritableStream<Uint8Array>;\n}\n\nclass SerialService {\n  private port: SerialPort | null = null;\n  private reader: ReadableStreamDefaultReader<string> | null = null;\n  private onDataCallback: ((packet: TelemetryPacket) => void) | null = null;\n  private onRawDataCallback: ((data: string) => void) | null = null;\n  private isReading: boolean = false;\n\n  /**\n   * Request access to a serial port from the user.\n   */\n  async requestPort(): Promise<boolean> {\n    try {\n      if (!('serial' in navigator)) {\n        throw new Error('Web Serial API not supported in this browser.');\n      }\n      this.port = await (navigator as unknown as { serial: { requestPort: () => Promise<SerialPort> } }).serial.requestPort();\n      return true;\n    } catch (e) {\n      console.error('Serial port request failed:', e);\n      return false;\n    }\n  }\n\n  /**\n   * Open the requested port and start the read loop.\n   */\n  async openPort(options: SerialOptions = { baudRate: 115200 }): Promise<void> {\n    if (!this.port) {\n      const success = await this.requestPort();\n      if (!success) return;\n    }\n\n    try {\n      await this.port.open({ baudRate: options.baudRate });\n      this.isReading = true;\n      this.readLoop();\n    } catch (e) {\n      console.error('Failed to open serial port:', e);\n      throw e;\n    }\n  }\n\n  /**\n   * Background loop to read serial data.\n   */\n  private async readLoop() {\n    while (this.port?.readable && this.isReading) {\n      const textDecoder = new TextDecoderStream();\n      const readableStreamClosed = this.port.readable.pipeTo(textDecoder.writable);\n      this.reader = textDecoder.readable.getReader();\n\n      try {\n        let buffer = '';\n        while (true) {\n          const { value, done } = await this.reader.read();\n          if (done) break;\n          if (value) {\n            buffer += value;\n            // Process complete lines\n            if (buffer.includes('\\n')) {\n              const lines = buffer.split('\\n');\n              buffer = lines.pop() || ''; // Keep partial line in buffer\n              for (const line of lines) {\n                this.processLine(line.trim());\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Serial read error:', error);\n        break;\n      } finally {\n        this.reader.releaseLock();\n      }\n    }\n  }\n\n  /**\n   * Parse a single line of serial data into a telemetry packet.\n   */\n  private processLine(line: string) {\n    if (!line) return;\n    \n    if (this.onRawDataCallback) {\n      this.onRawDataCallback(line);\n    }\n\n    // Protocol Parser:\n    // Pattern 1: \"COMP_ID:PIN:VALUE\" (e.g. \"esp32:13:1\")\n    // Pattern 2: \"PIN:VALUE\" (e.g. \"13:HIGH\")\n    // Pattern 3: \"KEY=VALUE\" (e.g. \"TEMP=24.5\")\n    \n    let packet: TelemetryPacket | null = null;\n\n    if (line.includes(':')) {\n      const parts = line.split(':');\n      if (parts.length === 3) {\n        packet = {\n          componentId: parts[0],\n          pin: parts[1],\n          value: parts[2],\n          timestamp: Date.now()\n        };\n      } else if (parts.length === 2) {\n        packet = {\n          componentId: 'auto', // Context-aware mapping will handle this\n          pin: parts[0],\n          value: parts[1],\n          timestamp: Date.now()\n        };\n      }\n    } else if (line.includes('=')) {\n      const [key, val] = line.split('=');\n      packet = {\n        componentId: 'auto',\n        pin: key.trim(),\n        value: val.trim(),\n        timestamp: Date.now()\n      };\n    }\n\n    if (packet && this.onDataCallback) {\n      this.onDataCallback(packet);\n    }\n  }\n\n  /**\n   * Register callback for parsed telemetry packets.\n   */\n  onData(callback: (packet: TelemetryPacket) => void) {\n    this.onDataCallback = callback;\n  }\n\n  /**\n   * Register callback for raw serial strings (for terminal).\n   */\n  onRawData(callback: (data: string) => void) {\n    this.onRawDataCallback = callback;\n  }\n\n  /**\n   * Close the connection and stop the loop.\n   */\n  async close() {\n    this.isReading = false;\n    if (this.reader) {\n      await this.reader.cancel();\n    }\n    if (this.port) {\n      await this.port.close();\n    }\n  }\n}\n\nexport const serialService = new SerialService();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/simulationEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ElectronicComponent' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WiringDiagram, WireConnection, ElectronicComponent } from '../types';\n\n/**\n * SimNodeState represents the electrical state of a single pin or net.\n */\nexport interface SimNodeState {\n  voltage: number;\n  current: number;\n  logicState: 'HIGH' | 'LOW' | 'FLOATING' | 'ERROR';\n}\n\n/**\n * SimulationResult contains the state of all pins in the diagram.\n */\nexport interface SimulationResult {\n  pinStates: Record<string, SimNodeState>; // Key: \"componentId:pin\"\n  isShortCircuit: boolean;\n  warnings: string[];\n}\n\n/**\n * SimulationEngine performs a lightweight DC nodal analysis and logic propagation.\n */\nclass SimulationEngine {\n  /**\n   * Run one tick of the simulation.\n   */\n  solve(diagram: WiringDiagram): SimulationResult {\n    const pinStates: Record<string, SimNodeState> = {};\n    const isShortCircuit = false;\n    const warnings: string[] = [];\n\n    // 1. Initialize all pins to FLOATING\n    diagram.components.forEach(comp => {\n      comp.pins?.forEach(pin => {\n        pinStates[`${comp.id}:${pin}`] = {\n          voltage: 0,\n          current: 0,\n          logicState: 'FLOATING'\n        };\n      });\n    });\n\n    // 2. Identify Nets (connected pins)\n    const nets = this.buildNets(diagram.connections);\n\n    // 3. Set Power Sources\n    diagram.components.forEach(comp => {\n      if (comp.type === 'power') {\n        const vccPin = comp.pins?.find(p => p.toUpperCase() === 'VCC' || p.toUpperCase() === 'VIN' || p === '5V' || p === '3V3');\n        const gndPin = comp.pins?.find(p => p.toUpperCase() === 'GND');\n\n        if (vccPin) {\n          const voltage = comp.name.includes('3.3V') ? 3.3 : 5.0;\n          this.propagateNet(vccPin, comp.id, voltage, 'HIGH', nets, pinStates);\n        }\n        if (gndPin) {\n          this.propagateNet(gndPin, comp.id, 0, 'LOW', nets, pinStates);\n        }\n      }\n    });\n\n    // 4. Check for Short Circuits (VCC connected directly to GND)\n    // This is simplified: check if any net has both 5V and 0V sources\n    // In a real solver, this would be a low resistance path.\n\n    return { pinStates, isShortCircuit, warnings };\n  }\n\n  private buildNets(connections: WireConnection[]): Map<string, string[]> {\n    const nets = new Map<string, string[]>();\n    \n    connections.forEach(conn => {\n      const p1 = `${conn.fromComponentId}:${conn.fromPin}`;\n      const p2 = `${conn.toComponentId}:${conn.toPin}`;\n      \n      if (!nets.has(p1)) nets.set(p1, []);\n      if (!nets.has(p2)) nets.set(p2, []);\n      \n      nets.get(p1)!.push(p2);\n      nets.get(p2)!.push(p1);\n    });\n\n    return nets;\n  }\n\n  private propagateNet(\n    startPin: string, \n    compId: string, \n    voltage: number, \n    logic: 'HIGH' | 'LOW',\n    nets: Map<string, string[]>,\n    states: Record<string, SimNodeState>\n  ) {\n    const visited = new Set<string>();\n    const stack = [`${compId}:${startPin}`];\n\n    while (stack.length > 0) {\n      const current = stack.pop()!;\n      if (visited.has(current)) continue;\n      visited.add(current);\n\n      if (states[current]) {\n        // If already set to a different voltage, we have a problem (simplified)\n        if (states[current].logicState !== 'FLOATING' && states[current].logicState !== logic) {\n          states[current].logicState = 'ERROR';\n        } else {\n          states[current].voltage = voltage;\n          states[current].logicState = logic;\n        }\n      }\n\n      const neighbors = nets.get(current) || [];\n      neighbors.forEach(n => stack.push(n));\n    }\n  }\n}\n\nexport const simulationEngine = new SimulationEngine();\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/standardsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[455,458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[455,458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ipcData from '../assets/standards/ipc_dimensions.json';\n\nexport interface IPCPackage {\n  body_width: number;\n  body_length: number;\n  height: number;\n  pitch?: number;\n  pin_count: number;\n  pin_type: 'gullwing' | 'through-hole' | 'chip';\n}\n\nexport interface BoardComponentMap {\n  name: string;\n  width: number;\n  length: number;\n  components: {\n    type: string;\n    name: string;\n    x: number;\n    z: number;\n    rotation?: number;\n    params?: any;\n  }[];\n}\n\nconst BOARD_MAPS: Record<string, BoardComponentMap> = {\n  \"ARDUINO-UNO-R3\": {\n    name: \"Arduino Uno R3\",\n    width: 68.6,\n    length: 53.3,\n    components: [\n      { type: 'MCU', name: 'ATmega328P', x: 15, z: 0, params: { type: 'DIP-28' } },\n      { type: 'USB', name: 'USB-B', x: -28, z: 15, rotation: Math.PI / 2 },\n      { type: 'DC', name: 'Barrel Jack', x: -28, z: -15, rotation: Math.PI / 2 },\n      { type: 'HEADER', name: 'Digital', x: 10, z: 24, params: { count: 10, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Digital Low', x: -15, z: 24, params: { count: 8, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Analog', x: 15, z: -24, params: { count: 6, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Power', x: -10, z: -24, params: { count: 8, pitch: 2.54 } },\n      { type: 'OSCILLATOR', name: '16MHz', x: -5, z: 5 },\n      { type: 'BUTTON', name: 'Reset', x: -30, z: 22 },\n    ]\n  },\n  \"ESP32-WROOM-32\": {\n    name: \"ESP32 DevKit V1\",\n    width: 28.0,\n    length: 54.6,\n    components: [\n      { type: 'CHIP', name: 'ESP32-WROOM', x: 0, z: -15, params: { width: 18, length: 25.5, height: 3 } },\n      { type: 'USB', name: 'Micro-USB', x: 0, z: 25, rotation: 0 },\n      { type: 'HEADER', name: 'Left Pins', x: -12, z: 0, params: { count: 15, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Right Pins', x: 12, z: 0, params: { count: 15, pitch: 2.54 } },\n      { type: 'BUTTON', name: 'EN', x: -8, z: 20 },\n      { type: 'BUTTON', name: 'BOOT', x: 8, z: 20 },\n    ]\n  },\n  \"RASPBERRY-PI-PICO\": {\n    name: \"Raspberry Pi Pico\",\n    width: 21.0,\n    length: 51.0,\n    components: [\n      { type: 'CHIP', name: 'RP2040', x: 0, z: 0, params: { width: 7, length: 7, height: 1 } },\n      { type: 'USB', name: 'Micro-USB', x: 0, z: -24, rotation: Math.PI },\n      { type: 'HEADER', name: 'Left', x: -9, z: 0, params: { count: 20, pitch: 2.54 } },\n      { type: 'HEADER', name: 'Right', x: 9, z: 0, params: { count: 20, pitch: 2.54 } },\n      { type: 'BUTTON', name: 'BOOTSEL', x: 0, z: -15 },\n    ]\n  }\n};\n\nexport const standardsService = {\n  getPackage: (name: string): IPCPackage | null => {\n    const packages = ipcData.packages as Record<string, IPCPackage>;\n    \n    // Exact match\n    if (packages[name]) return packages[name];\n    \n    // Fuzzy match (e.g. \"SOIC8\" -> \"SOIC-8\")\n    const normalized = name.toUpperCase().replace(/\\s+/g, '-');\n    if (packages[normalized]) return packages[normalized];\n    \n    // Check for substrings\n    for (const key of Object.keys(packages)) {\n      if (normalized.includes(key.toUpperCase())) return packages[key];\n    }\n    \n    return null;\n  },\n  getBoardMap: (name: string): BoardComponentMap | null => {\n    const normalized = name.toUpperCase().replace(/\\s+/g, '-');\n    if (BOARD_MAPS[normalized]) return BOARD_MAPS[normalized];\n    for (const key of Object.keys(BOARD_MAPS)) {\n      if (normalized.includes(key)) return BOARD_MAPS[key];\n    }\n    return null;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/storage.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3444,3447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3444,3447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ElectronicComponent, ActionRecord, Conversation, EnhancedChatMessage } from '../types';\n\n/**\n * Storage Service\n * \n * Provides a safe wrapper for localStorage with quota protection\n * AND IndexedDB persistence for heavy/structured data.\n */\n\n// ============================================================================\n// INDEXED DB CONFIG\n// ============================================================================\n\nconst DB_NAME = 'CircuitMindDB';\nconst DB_VERSION = 3;\nconst STORES = {\n  INVENTORY: 'inventory',\n  STATE: 'app_state',\n  ACTION_HISTORY: 'action_history',\n  CONVERSATIONS: 'conversations',\n  MESSAGES: 'messages',\n  PARTS: 'parts' // Store for binary FZPZ data and cached views\n};\n\nconst openDB = (): Promise<IDBDatabase> => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n      \n      if (!db.objectStoreNames.contains(STORES.INVENTORY)) {\n        db.createObjectStore(STORES.INVENTORY, { keyPath: 'id' });\n      }\n      if (!db.objectStoreNames.contains(STORES.STATE)) {\n        db.createObjectStore(STORES.STATE, { keyPath: 'key' });\n      }\n      if (!db.objectStoreNames.contains(STORES.ACTION_HISTORY)) {\n        db.createObjectStore(STORES.ACTION_HISTORY, { keyPath: 'id' });\n      }\n      if (!db.objectStoreNames.contains(STORES.CONVERSATIONS)) {\n        db.createObjectStore(STORES.CONVERSATIONS, { keyPath: 'id' });\n      }\n      if (!db.objectStoreNames.contains(STORES.MESSAGES)) {\n        const messageStore = db.createObjectStore(STORES.MESSAGES, { keyPath: 'id' });\n        messageStore.createIndex('conversationId', 'conversationId', { unique: false });\n      }\n      if (!db.objectStoreNames.contains(STORES.PARTS)) {\n        db.createObjectStore(STORES.PARTS, { keyPath: 'id' });\n      }\n    };\n\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n};\n\n// ============================================================================\n// LOCAL STORAGE WRAPPER (With Quota Protection)\n// ============================================================================\n\nexport const storageService = {\n  setItem: (key: string, value: string): boolean => {\n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch (e: unknown) {\n      if (e instanceof DOMException && (\n        e.code === 22 || \n        e.code === 1014 || \n        e.name === 'QuotaExceededError' || \n        e.name === 'NS_ERROR_DOM_QUOTA_REACHED')\n      ) {\n        console.warn('LocalStorage quota exceeded. Attempting purge...');\n        return storageService.handleQuotaExceeded(key, value);\n      }\n      return false;\n    }\n  },\n\n  getItem: (key: string): string | null => {\n    return localStorage.getItem(key);\n  },\n\n  handleQuotaExceeded: (key: string, value: string): boolean => {\n    const keys = Object.keys(localStorage);\n    \n    // 1. Purge 3D code cache\n    const cacheKeys = keys.filter(k => k.startsWith('cm_3d_code_cache_'));\n    cacheKeys.forEach(k => localStorage.removeItem(k));\n    \n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch {\n      // 2. Prune inventory images if it's the inventory failing\n      if (key === 'cm_inventory') {\n        try {\n          const inv = JSON.parse(value);\n          const pruned = inv.map((item: any) => ({\n            ...item,\n            imageUrl: item.imageUrl?.length > 5000 ? null : item.imageUrl,\n            threeCode: null\n          }));\n          localStorage.setItem(key, JSON.stringify(pruned));\n          return true;\n        } catch { return false; }\n      }\n      return false;\n    }\n  }\n};\n\n// ============================================================================\n// INDEXED DB OPERATIONS (Action History)\n// ============================================================================\n\n/**\n * Sanitizes an object to ensure it's serializable for IndexedDB.\n * Removes non-cloneable objects like Events, Functions, etc.\n * Handles circular references gracefully.\n */\nconst sanitizeForDB = (obj: unknown): unknown => {\n  try {\n    // structuredClone is native and handles circular refs + many types better than JSON\n    return window.structuredClone(obj);\n  } catch (_e) {\n    // If it fails (e.g. contains functions or complex circular refs), \n    // use a robust custom stringifier that drops circularities.\n    try {\n      const cache = new Set();\n      const stringified = JSON.stringify(obj, (key, value) => {\n        if (typeof value === 'object' && value !== null) {\n          if (cache.has(value)) return '[Circular]';\n          cache.add(value);\n        }\n        return value;\n      });\n      return JSON.parse(stringified);\n    } catch (err) {\n      console.error('Failed to sanitize object for DB:', err, obj);\n      return null;\n    }\n  }\n};\n\nexport const recordAction = async (action: ActionRecord) => {\n  if (!action || !action.id) {\n    console.error('Cannot record action: Missing ID');\n    return;\n  }\n\n  const db = await openDB();\n  const sanitizedAction = sanitizeForDB(action);\n  if (!sanitizedAction) return;\n\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.ACTION_HISTORY, 'readwrite');\n    tx.objectStore(STORES.ACTION_HISTORY).put(sanitizedAction);\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const getRecentActions = async (limit: number = 10): Promise<ActionRecord[]> => {\n  const db = await openDB();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORES.ACTION_HISTORY, 'readonly');\n    const store = tx.objectStore(STORES.ACTION_HISTORY);\n    const request = store.getAll();\n    \n    request.onsuccess = () => {\n      const results = request.result as ActionRecord[];\n      resolve(results.sort((a, b) => b.timestamp - a.timestamp).slice(0, limit));\n    };\n    request.onerror = () => reject(request.error);\n  });\n};\n\nexport const deleteAction = async (id: string) => {\n  if (!id) return;\n  const db = await openDB();\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.ACTION_HISTORY, 'readwrite');\n    tx.objectStore(STORES.ACTION_HISTORY).delete(id);\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\n// ============================================================================\n// INDEXED DB OPERATIONS (Conversations & Messages)\n// ============================================================================\n\nexport const saveConversation = async (conv: Conversation) => {\n  if (!conv || !conv.id) {\n    console.error('Cannot save conversation: Missing ID');\n    return;\n  }\n\n  const db = await openDB();\n  const sanitizedConv = sanitizeForDB(conv);\n  if (!sanitizedConv) return;\n\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.CONVERSATIONS, 'readwrite');\n    tx.objectStore(STORES.CONVERSATIONS).put(sanitizedConv);\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const listConversations = async (limit: number = 50): Promise<Conversation[]> => {\n  const db = await openDB();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORES.CONVERSATIONS, 'readonly');\n    const request = tx.objectStore(STORES.CONVERSATIONS).getAll();\n    request.onsuccess = () => {\n      const results = request.result as Conversation[];\n      resolve(results.sort((a, b) => b.updatedAt - a.updatedAt).slice(0, limit));\n    };\n    request.onerror = () => reject(request.error);\n  });\n};\n\nexport const deleteConversation = async (id: string) => {\n  if (!id) return;\n  const db = await openDB();\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction([STORES.CONVERSATIONS, STORES.MESSAGES], 'readwrite');\n    tx.objectStore(STORES.CONVERSATIONS).delete(id);\n    \n    // Also delete all messages for this conversation\n    const msgStore = tx.objectStore(STORES.MESSAGES);\n    const index = msgStore.index('conversationId');\n    const request = index.openKeyCursor(IDBKeyRange.only(id));\n    request.onsuccess = () => {\n      const cursor = request.result;\n      if (cursor) {\n        msgStore.delete(cursor.primaryKey);\n        cursor.continue();\n      }\n    };\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const getPrimaryConversation = async (): Promise<Conversation | null> => {\n  const convs = await listConversations(100);\n  return convs.find(c => c.isPrimary) || null;\n};\n\nexport const saveMessage = async (msg: EnhancedChatMessage) => {\n  if (!msg || !msg.id) {\n    console.error('Cannot save message: Missing ID');\n    return;\n  }\n\n  const db = await openDB();\n  const sanitizedMsg = sanitizeForDB(msg);\n  if (!sanitizedMsg) return;\n\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.MESSAGES, 'readwrite');\n    tx.objectStore(STORES.MESSAGES).put(sanitizedMsg);\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const loadMessages = async (conversationId: string): Promise<EnhancedChatMessage[]> => {\n  if (!conversationId) {\n    console.warn('loadMessages called without conversationId');\n    return [];\n  }\n\n  const db = await openDB();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORES.MESSAGES, 'readonly');\n    const index = tx.objectStore(STORES.MESSAGES).index('conversationId');\n    const request = index.getAll(IDBKeyRange.only(conversationId));\n    request.onsuccess = () => {\n      const results = request.result as EnhancedChatMessage[];\n      resolve(results.sort((a, b) => a.timestamp - b.timestamp));\n    };\n    request.onerror = () => reject(request.error);\n  });\n};\n\n// ============================================================================\n// INDEXED DB OPERATIONS (Inventory)\n// ============================================================================\n\nexport const saveInventoryToDB = async (items: ElectronicComponent[]) => {\n  if (!Array.isArray(items)) return;\n\n  const db = await openDB();\n  return new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(STORES.INVENTORY, 'readwrite');\n    const store = tx.objectStore(STORES.INVENTORY);\n    \n    store.clear().onsuccess = () => {\n      items.forEach(item => {\n        const sanitized = sanitizeForDB(item);\n        if (sanitized && sanitized.id) {\n          store.put(sanitized);\n        }\n      });\n    };\n\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n  });\n};\n\nexport const loadInventoryFromDB = async (): Promise<ElectronicComponent[]> => {\n  const db = await openDB();\n  const tx = db.transaction(STORES.INVENTORY, 'readonly');\n  const request = tx.objectStore(STORES.INVENTORY).getAll();\n  return new Promise((resolve) => {\n    request.onsuccess = () => resolve(request.result || []);\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/syncService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threeCodeRunner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[119,122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[119,122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ThreeCodeWorker from './threeCodeRunner.worker?worker';\n\nexport const executeInWorker = (code: string): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    const worker = new ThreeCodeWorker();\n    \n    // 5s execution timeout to prevent infinite loops freezing the app\n    const timeout = setTimeout(() => {\n        worker.terminate();\n        reject(new Error('Execution timed out (5s limit). Infinite loop detected?'));\n    }, 5000);\n\n    worker.onmessage = (e) => {\n        clearTimeout(timeout);\n        if (e.data.success) {\n            resolve(e.data.json);\n        } else {\n            reject(new Error(e.data.error || 'Worker execution failed'));\n        }\n        worker.terminate();\n    };\n\n    worker.onerror = (err) => {\n        clearTimeout(timeout);\n        reject(new Error('Worker error: ' + err.message));\n        worker.terminate();\n    };\n\n    worker.postMessage({ code });\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threeCodeRunner.worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threeCodeValidator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threePrimitives.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/threeWorkerPolyfill.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/tutorialValidator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/userProfileService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/visionAnalysisService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/viz/vizEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/wtyler/circuitmind-ai/services/webRTCService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":48,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1695,1698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1695,1698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"class WebRTCService {\n  private peerConnection: RTCPeerConnection | null = null;\n  private dataChannel: RTCDataChannel | null = null;\n\n  async createOffer() {\n    this.peerConnection = new RTCPeerConnection({\n      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]\n    });\n\n    this.dataChannel = this.peerConnection.createDataChannel('git-sync');\n    this.setupDataChannel();\n\n    const offer = await this.peerConnection.createOffer();\n    await this.peerConnection.setLocalDescription(offer);\n\n    return JSON.stringify(offer);\n  }\n\n  async acceptOffer(offerStr: string) {\n    const offer = JSON.parse(offerStr);\n    this.peerConnection = new RTCPeerConnection({\n      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]\n    });\n\n    this.peerConnection.ondatachannel = (event) => {\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    await this.peerConnection.setRemoteDescription(offer);\n    const answer = await this.peerConnection.createAnswer();\n    await this.peerConnection.setLocalDescription(answer);\n\n    return JSON.stringify(answer);\n  }\n\n  async acceptAnswer(answerStr: string) {\n    if (!this.peerConnection) return;\n    const answer = JSON.parse(answerStr);\n    await this.peerConnection.setRemoteDescription(answer);\n  }\n\n  private setupDataChannel() {\n    if (!this.dataChannel) return;\n\n    this.dataChannel.onopen = () => {};\n    this.dataChannel.onclose = () => {};\n    this.dataChannel.onmessage = (event) => {\n      // Handle Git packfile or JSON data\n    };\n  }\n\n  send(data: string | ArrayBuffer | Blob | ArrayBufferView) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(data as any); // RTCDataChannel.send accepts these types, but TS definitions vary.\n    }\n  }\n}\n\nexport const webRTCService = new WebRTCService();\n","usedDeprecatedRules":[]}]
